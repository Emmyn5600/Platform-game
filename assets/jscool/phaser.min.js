!(function (t, e) { typeof exports === 'object' && typeof module === 'object' ? module.exports = e() : typeof define === 'function' && define.amd ? define('Phaser', [], e) : typeof exports === 'object' ? exports.Phaser = e() : t.Phaser = e(); }(window, () => (function (t) { const e = {}; function i(n) { if (e[n]) return e[n].exports; const s = e[n] = { i: n, l: !1, exports: {} }; return t[n].call(s.exports, s, s.exports, i), s.l = !0, s.exports; } return i.m = t, i.c = e, i.d = function (t, e, n) { i.o(t, e) || Object.defineProperty(t, e, { configurable: !1, enumerable: !0, get: n }); }, i.r = function (t) { Object.defineProperty(t, '__esModule', { value: !0 }); }, i.n = function (t) { const e = t && t.__esModule ? function () { return t.default; } : function () { return t; }; return i.d(e, 'a', e), e; }, i.o = function (t, e) { return Object.prototype.hasOwnProperty.call(t, e); }, i.p = '', i(i.s = 1127); }([function (t, e) { function i(t, e, i) { let n = i ? t[e] : Object.getOwnPropertyDescriptor(t, e); return !i && n.value && typeof n.value === 'object' && (n = n.value), !(!n || !(function (t) { return !!t.get && typeof t.get === 'function' || !!t.set && typeof t.set === 'function'; }(n))) && (void 0 === n.enumerable && (n.enumerable = !0), void 0 === n.configurable && (n.configurable = !0), n); } function n(t, e) { let i = Object.getOwnPropertyDescriptor(t, e); return !!i && (i.value && typeof i.value === 'object' && (i = i.value), !1 === i.configurable); } function s(t, e, s, r) { for (const a in e) if (e.hasOwnProperty(a)) { const h = i(e, a, s); if (!1 !== h) { if (n((r || t).prototype, a)) { if (o.ignoreFinals) continue; throw new Error(`cannot override final property '${a}', set Class.ignoreFinals = true to skip`); }Object.defineProperty(t.prototype, a, h); } else t.prototype[a] = e[a]; } } function r(t, e) { if (e) { Array.isArray(e) || (e = [e]); for (let i = 0; i < e.length; i++)s(t, e[i].prototype || e[i]); } } function o(t) { let e; let i; if (t || (t = {}), t.initialize) { if (typeof t.initialize !== 'function') throw new Error('initialize must be a function'); e = t.initialize, delete t.initialize; } else if (t.Extends) { const n = t.Extends; e = function () { n.apply(this, arguments); }; } else e = function () {}; t.Extends ? (e.prototype = Object.create(t.Extends.prototype), e.prototype.constructor = e, i = t.Extends, delete t.Extends) : e.prototype.constructor = e; let o = null; return t.Mixins && (o = t.Mixins, delete t.Mixins), r(e, o), s(e, t, !0, i), e; }o.extend = s, o.mixin = r, o.ignoreFinals = !1, t.exports = o; }, function (t, e) { t.exports = function () {}; }, function (t, e) { t.exports = function (t, e, i) { const n = typeof t; return t && n !== 'number' && n !== 'string' && t.hasOwnProperty(e) && void 0 !== t[e] ? t[e] : i; }; }, function (t, e, i) {
  var n = new (i(0))({
    initialize(t, e) { this.x = 0, this.y = 0, typeof t === 'object' ? (this.x = t.x || 0, this.y = t.y || 0) : (void 0 === e && (e = t), this.x = t || 0, this.y = e || 0); }, clone() { return new n(this.x, this.y); }, copy(t) { return this.x = t.x || 0, this.y = t.y || 0, this; }, setFromObject(t) { return this.x = t.x || 0, this.y = t.y || 0, this; }, set(t, e) { return void 0 === e && (e = t), this.x = t, this.y = e, this; }, setTo(t, e) { return this.set(t, e); }, setToPolar(t, e) { return e == null && (e = 1), this.x = Math.cos(t) * e, this.y = Math.sin(t) * e, this; }, equals(t) { return this.x === t.x && this.y === t.y; }, angle() { let t = Math.atan2(this.y, this.x); return t < 0 && (t += 2 * Math.PI), t; }, add(t) { return this.x += t.x, this.y += t.y, this; }, subtract(t) { return this.x -= t.x, this.y -= t.y, this; }, multiply(t) { return this.x *= t.x, this.y *= t.y, this; }, scale(t) { return isFinite(t) ? (this.x *= t, this.y *= t) : (this.x = 0, this.y = 0), this; }, divide(t) { return this.x /= t.x, this.y /= t.y, this; }, negate() { return this.x = -this.x, this.y = -this.y, this; }, distance(t) { const e = t.x - this.x; const i = t.y - this.y; return Math.sqrt(e * e + i * i); }, distanceSq(t) { const e = t.x - this.x; const i = t.y - this.y; return e * e + i * i; }, length() { const t = this.x; const e = this.y; return Math.sqrt(t * t + e * e); }, lengthSq() { const t = this.x; const e = this.y; return t * t + e * e; }, normalize() { const t = this.x; const e = this.y; let i = t * t + e * e; return i > 0 && (i = 1 / Math.sqrt(i), this.x = t * i, this.y = e * i), this; }, normalizeRightHand() { const t = this.x; return this.x = -1 * this.y, this.y = t, this; }, dot(t) { return this.x * t.x + this.y * t.y; }, cross(t) { return this.x * t.y - this.y * t.x; }, lerp(t, e) { void 0 === e && (e = 0); const i = this.x; const n = this.y; return this.x = i + e * (t.x - i), this.y = n + e * (t.y - n), this; }, transformMat3(t) { const e = this.x; const i = this.y; const n = t.val; return this.x = n[0] * e + n[3] * i + n[6], this.y = n[1] * e + n[4] * i + n[7], this; }, transformMat4(t) { const e = this.x; const i = this.y; const n = t.val; return this.x = n[0] * e + n[4] * i + n[12], this.y = n[1] * e + n[5] * i + n[13], this; }, reset() { return this.x = 0, this.y = 0, this; },
  }); n.ZERO = new n(), t.exports = n;
}, function (t, e) { t.exports = function (t, e, i) { if (t && typeof t !== 'number') { if (t.hasOwnProperty(e)) return t[e]; if (e.indexOf('.')) { for (var n = e.split('.'), s = t, r = i, o = 0; o < n.length; o++) { if (!s.hasOwnProperty(n[o])) { r = i; break; }r = s[n[o]], s = s[n[o]]; } return r; } return i; } return i; }; }, function (t, e, i) {
  const n = i(0); const s = i(15); const r = new n({
    initialize(t) { this.scene = t, this.systems = t.sys, this.displayList, this.updateList, t.sys.events.once('boot', this.boot, this), t.sys.events.on('start', this.start, this); }, boot() { this.displayList = this.systems.displayList, this.updateList = this.systems.updateList, this.systems.events.once('destroy', this.destroy, this); }, start() { this.systems.events.once('shutdown', this.shutdown, this); }, existing(t) { return (t.renderCanvas || t.renderWebGL) && this.displayList.add(t), t.preUpdate && this.updateList.add(t), t; }, shutdown() { this.systems.events.off('shutdown', this.shutdown, this); }, destroy() { this.shutdown(), this.scene.sys.events.off('start', this.start, this), this.scene = null, this.systems = null, this.displayList = null, this.updateList = null; },
  }); r.register = function (t, e) { r.prototype.hasOwnProperty(t) || (r.prototype[t] = e); }, s.register('GameObjectFactory', r, 'add'), t.exports = r;
}, function (t, e, i) { const n = new (i(0))({ initialize(t, e) { void 0 === t && (t = 0), void 0 === e && (e = t), this.x = t, this.y = e; }, setTo(t, e) { return void 0 === t && (t = 0), void 0 === e && (e = t), this.x = t, this.y = e, this; } }); t.exports = n; }, function (t, e) { let i = {}; const n = { install(t) { for (const e in i)t[e] = i[e]; }, register(t, e) { i[t] = e; }, destroy() { i = {}; } }; t.exports = n; }, function (t, e) { t.exports = function (t) { if (typeof t !== 'object' || t.nodeType || t === t.window) return !1; try { if (t.constructor && !{}.hasOwnProperty.call(t.constructor.prototype, 'isPrototypeOf')) return !1; } catch (t) { return !1; } return !0; }; }, function (t, e, i) {
  const n = i(0); const s = i(39); const r = i(190); const o = i(398); const a = i(54); const h = i(187); const l = new n({
    initialize(t, e, i, n) { void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), this.x = t, this.y = e, this.width = i, this.height = n; }, contains(t, e) { return s(this, t, e); }, getPoint(t, e) { return r(this, t, e); }, getPoints(t, e, i) { return o(this, t, e, i); }, getRandomPoint(t) { return h(this, t); }, setTo(t, e, i, n) { return this.x = t, this.y = e, this.width = i, this.height = n, this; }, setEmpty() { return this.setTo(0, 0, 0, 0); }, setPosition(t, e) { return void 0 === e && (e = t), this.x = t, this.y = e, this; }, setSize(t, e) { return void 0 === e && (e = t), this.width = t, this.height = e, this; }, isEmpty() { return this.width <= 0 || this.height <= 0; }, getLineA(t) { return void 0 === t && (t = new a()), t.setTo(this.x, this.y, this.right, this.y), t; }, getLineB(t) { return void 0 === t && (t = new a()), t.setTo(this.right, this.y, this.right, this.bottom), t; }, getLineC(t) { return void 0 === t && (t = new a()), t.setTo(this.right, this.bottom, this.x, this.bottom), t; }, getLineD(t) { return void 0 === t && (t = new a()), t.setTo(this.x, this.bottom, this.x, this.y), t; }, left: { get() { return this.x; }, set(t) { t >= this.right ? this.width = 0 : this.width = this.right - t, this.x = t; } }, right: { get() { return this.x + this.width; }, set(t) { t <= this.x ? this.width = 0 : this.width = t - this.x; } }, top: { get() { return this.y; }, set(t) { t >= this.bottom ? this.height = 0 : this.height = this.bottom - t, this.y = t; } }, bottom: { get() { return this.y + this.height; }, set(t) { t <= this.y ? this.height = 0 : this.height = t - this.y; } }, centerX: { get() { return this.x + this.width / 2; }, set(t) { this.x = t - this.width / 2; } }, centerY: { get() { return this.y + this.height / 2; }, set(t) { this.y = t - this.height / 2; } },
  }); t.exports = l;
}, function (t, e) {
  t.exports = {
    getTintFromFloats(t, e, i, n) { return ((255 & (255 * n | 0)) << 24 | (255 & (255 * t | 0)) << 16 | (255 & (255 * e | 0)) << 8 | 255 & (255 * i | 0)) >>> 0; }, getTintAppendFloatAlpha(t, e) { return ((255 & (255 * e | 0)) << 24 | t) >>> 0; }, getTintAppendFloatAlphaAndSwap(t, e) { return ((255 & (255 * e | 0)) << 24 | (255 & (0 | t)) << 16 | (255 & (t >> 8 | 0)) << 8 | 255 & (t >> 16 | 0)) >>> 0; }, getFloatsFromUintRGB(t) { return [(255 & (t >> 16 | 0)) / 255, (255 & (t >> 8 | 0)) / 255, (255 & (0 | t)) / 255]; }, getComponentCount(t, e) { for (var i = 0, n = 0; n < t.length; ++n) { const s = t[n]; s.type === e.FLOAT ? i += s.size : i += 1; } return i; },
  };
}, function (t, e, i) {
  const n = Object.prototype.hasOwnProperty; let s = '~'; function r() {} function o(t, e, i, n, r) { if (typeof i !== 'function') throw new TypeError('The listener must be a function'); const o = new function (t, e, i) { this.fn = t, this.context = e, this.once = i || !1; }(i, n || t, r); const a = s ? s + e : e; return t._events[a] ? t._events[a].fn ? t._events[a] = [t._events[a], o] : t._events[a].push(o) : (t._events[a] = o, t._eventsCount++), t; } function a(t, e) { --t._eventsCount == 0 ? t._events = new r() : delete t._events[e]; } function h() { this._events = new r(), this._eventsCount = 0; }Object.create && (r.prototype = Object.create(null), (new r()).__proto__ || (s = !1)), h.prototype.eventNames = function () { let t; let e; const i = []; if (this._eventsCount === 0) return i; for (e in t = this._events)n.call(t, e) && i.push(s ? e.slice(1) : e); return Object.getOwnPropertySymbols ? i.concat(Object.getOwnPropertySymbols(t)) : i; }, h.prototype.listeners = function (t) { const e = s ? s + t : t; const i = this._events[e]; if (!i) return []; if (i.fn) return [i.fn]; for (var n = 0, r = i.length, o = new Array(r); n < r; n++)o[n] = i[n].fn; return o; }, h.prototype.listenerCount = function (t) { const e = s ? s + t : t; const i = this._events[e]; return i ? i.fn ? 1 : i.length : 0; }, h.prototype.emit = function (t, e, i, n, r, o) { const a = s ? s + t : t; if (!this._events[a]) return !1; let h; let l; const u = this._events[a]; const c = arguments.length; if (u.fn) { switch (u.once && this.removeListener(t, u.fn, void 0, !0), c) { case 1: return u.fn.call(u.context), !0; case 2: return u.fn.call(u.context, e), !0; case 3: return u.fn.call(u.context, e, i), !0; case 4: return u.fn.call(u.context, e, i, n), !0; case 5: return u.fn.call(u.context, e, i, n, r), !0; case 6: return u.fn.call(u.context, e, i, n, r, o), !0; } for (l = 1, h = new Array(c - 1); l < c; l++)h[l - 1] = arguments[l]; u.fn.apply(u.context, h); } else { let d; const f = u.length; for (l = 0; l < f; l++) switch (u[l].once && this.removeListener(t, u[l].fn, void 0, !0), c) { case 1: u[l].fn.call(u[l].context); break; case 2: u[l].fn.call(u[l].context, e); break; case 3: u[l].fn.call(u[l].context, e, i); break; case 4: u[l].fn.call(u[l].context, e, i, n); break; default: if (!h) for (d = 1, h = new Array(c - 1); d < c; d++)h[d - 1] = arguments[d]; u[l].fn.apply(u[l].context, h); } } return !0; }, h.prototype.on = function (t, e, i) { return o(this, t, e, i, !1); }, h.prototype.once = function (t, e, i) { return o(this, t, e, i, !0); }, h.prototype.removeListener = function (t, e, i, n) { const r = s ? s + t : t; if (!this._events[r]) return this; if (!e) return a(this, r), this; const o = this._events[r]; if (o.fn)o.fn !== e || n && !o.once || i && o.context !== i || a(this, r); else { for (var h = 0, l = [], u = o.length; h < u; h++)(o[h].fn !== e || n && !o[h].once || i && o[h].context !== i) && l.push(o[h]); l.length ? this._events[r] = l.length === 1 ? l[0] : l : a(this, r); } return this; }, h.prototype.removeAllListeners = function (t) { let e; return t ? (e = s ? s + t : t, this._events[e] && a(this, e)) : (this._events = new r(), this._eventsCount = 0), this; }, h.prototype.off = h.prototype.removeListener, h.prototype.addListener = h.prototype.on, h.prefixed = s, h.EventEmitter = h, t.exports = h;
}, function (t, e, i) { const n = i(16); const s = i(4); t.exports = function (t, e, i) { const r = s(t, e, null); if (r === null) return i; if (Array.isArray(r)) return n.RND.pick(r); if (typeof r === 'object') { if (r.hasOwnProperty('randInt')) return n.RND.integerInRange(r.randInt[0], r.randInt[1]); if (r.hasOwnProperty('randFloat')) return n.RND.realInRange(r.randFloat[0], r.randFloat[1]); } else if (typeof r === 'function') return r(e); return r; }; }, function (t, e, i) {
  const n = i(0); const s = i(15); const r = new n({
    initialize(t) { this.scene = t, this.systems = t.sys, this.displayList, this.updateList, t.sys.events.once('boot', this.boot, this), t.sys.events.on('start', this.start, this); }, boot() { this.displayList = this.systems.displayList, this.updateList = this.systems.updateList, this.systems.events.once('destroy', this.destroy, this); }, start() { this.systems.events.once('shutdown', this.shutdown, this); }, shutdown() { this.systems.events.off('shutdown', this.shutdown, this); }, destroy() { this.shutdown(), this.scene.sys.events.off('start', this.start, this), this.scene = null, this.systems = null, this.displayList = null, this.updateList = null; },
  }); r.register = function (t, e) { r.prototype.hasOwnProperty(t) || (r.prototype[t] = e); }, s.register('GameObjectCreator', r, 'make'), t.exports = r;
}, function (t, e, i) {
  t.exports = {
    Alpha: i(401), Animation: i(427), BlendMode: i(400), ComputedSize: i(1045), Crop: i(1044), Depth: i(399), Flip: i(1043), GetBounds: i(1042), Mask: i(395), Origin: i(1041), Pipeline: i(186), ScaleMode: i(1040), ScrollFactor: i(392), Size: i(1039), Texture: i(1038), TextureCrop: i(1037), Tint: i(1036), ToJSON: i(391), Transform: i(390), TransformMatrix: i(38), Visible: i(389),
  };
}, function (t, e) {
  const i = {}; const n = {}; const s = {
    register(t, e, n, s) { void 0 === s && (s = !1), i[t] = { plugin: e, mapping: n, custom: s }; }, registerCustom(t, e, i, s) { n[t] = { plugin: e, mapping: i, data: s }; }, hasCore(t) { return i.hasOwnProperty(t); }, hasCustom(t) { return n.hasOwnProperty(t); }, getCore(t) { return i[t]; }, getCustom(t) { return n[t]; }, getCustomClass(t) { return n.hasOwnProperty(t) ? n[t].plugin : null; }, remove(t) { i.hasOwnProperty(t) && delete i[t]; }, removeCustom(t) { n.hasOwnProperty(t) && delete n[t]; }, destroyCorePlugins() { for (const t in i)i.hasOwnProperty(t) && delete i[t]; }, destroyCustomPlugins() { for (const t in n)n.hasOwnProperty(t) && delete n[t]; },
  }; t.exports = s;
}, function (t, e, i) {
  const n = i(404); const s = {
    PI2: 2 * Math.PI, TAU: 0.5 * Math.PI, EPSILON: 1e-6, DEG_TO_RAD: Math.PI / 180, RAD_TO_DEG: 180 / Math.PI, RND: new n(),
  }; t.exports = s;
}, function (t, e, i) { const n = i(2); t.exports = function (t, e, i, s, r, o) { void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = o.width), void 0 === s && (s = o.height); const a = n(r, 'isNotEmpty', !1); const h = n(r, 'isColliding', !1); const l = n(r, 'hasInterestingFace', !1); t < 0 && (i += t, t = 0), e < 0 && (s += e, e = 0), t + i > o.width && (i = Math.max(o.width - t, 0)), e + s > o.height && (s = Math.max(o.height - e, 0)); for (var u = [], c = e; c < e + s; c++) for (let d = t; d < t + i; d++) { const f = o.data[c][d]; if (f !== null) { if (a && f.index === -1) continue; if (h && !f.collides) continue; if (l && !f.hasInterestingFace) continue; u.push(f); } } return u; }; }, function (t, e) {
  t.exports = {
    LOADER_IDLE: 0, LOADER_LOADING: 1, LOADER_PROCESSING: 2, LOADER_COMPLETE: 3, LOADER_SHUTDOWN: 4, LOADER_DESTROYED: 5, FILE_PENDING: 10, FILE_LOADING: 11, FILE_LOADED: 12, FILE_FAILED: 13, FILE_PROCESSING: 14, FILE_ERRORED: 16, FILE_COMPLETE: 17, FILE_DESTROYED: 18, FILE_POPULATED: 19,
  };
}, function (t, e, i) {
  const n = i(0); const s = i(391); const r = i(123); const o = i(11); var a = new n({
    Extends: o, initialize(t, e) { o.call(this), this.scene = t, this.type = e, this.parentContainer = null, this.name = '', this.active = !0, this.tabIndex = -1, this.data = null, this.renderFlags = 15, this.cameraFilter = 0, this.input = null, this.body = null, this.ignoreDestroy = !1, t.sys.queueDepthSort(); }, setActive(t) { return this.active = t, this; }, setName(t) { return this.name = t, this; }, setDataEnabled() { return this.data || (this.data = new r(this)), this; }, setData(t, e) { return this.data || (this.data = new r(this)), this.data.set(t, e), this; }, getData(t) { return this.data || (this.data = new r(this)), this.data.get(t); }, setInteractive(t, e, i) { return this.scene.sys.input.enable(this, t, e, i), this; }, disableInteractive() { return this.input && (this.input.enabled = !1), this; }, removeInteractive() { return this.scene.sys.input.clear(this), this.input = void 0, this; }, update() {}, toJSON() { return s(this); }, willRender(t) { return !(a.RENDER_MASK !== this.renderFlags || this.cameraFilter > 0 && this.cameraFilter & t.id); }, getIndexList() { for (var t = this, e = this.parentContainer, i = []; e && (i.unshift(e.getIndex(t)), t = e, e.parentContainer);)e = e.parentContainer; return i.unshift(this.scene.sys.displayList.getIndex(t)), i; }, destroy(t) { if (void 0 === t && (t = !1), this.scene && !this.ignoreDestroy) { this.preDestroy && this.preDestroy.call(this), this.emit('destroy', this); const e = this.scene.sys; t || (e.displayList.remove(this), e.updateList.remove(this)), this.input && (e.input.clear(this), this.input = void 0), this.data && (this.data.destroy(), this.data = void 0), this.body && (this.body.destroy(), this.body = void 0), t || e.queueDepthSort(), this.active = !1, this.visible = !1, this.scene = void 0, this.parentContainer = void 0, this.removeAllListeners(); } },
  }); a.RENDER_MASK = 15, t.exports = a;
}, function (t, e, i) { const n = i(8); var s = function () { let t; let e; let i; let r; let o; let a; let h = arguments[0] || {}; let l = 1; const u = arguments.length; let c = !1; for (typeof h === 'boolean' && (c = h, h = arguments[1] || {}, l = 2), u === l && (h = this, --l); l < u; l++) if ((t = arguments[l]) != null) for (e in t)i = h[e], h !== (r = t[e]) && (c && r && (n(r) || (o = Array.isArray(r))) ? (o ? (o = !1, a = i && Array.isArray(i) ? i : []) : a = i && n(i) ? i : {}, h[e] = s(c, a, r)) : void 0 !== r && (h[e] = r)); return h; }; t.exports = s; }, function (t, e, i) {
  const n = i(0); const s = i(18); const r = i(2); const o = i(141); const a = i(140); const h = i(254); const l = i(105); const u = new n({
    initialize(t, e) { this.loader = t, this.cache = r(e, 'cache', !1), this.type = r(e, 'type', !1), this.key = r(e, 'key', !1); const i = this.key; if (t.prefix && t.prefix !== '' && (this.key = t.prefix + i), !this.type || !this.key) throw new Error(`Error calling 'Loader.${this.type}' invalid key provided.`); this.url = r(e, 'url'), void 0 === this.url ? this.url = `${t.path + i}.${r(e, 'extension', '')}` : typeof this.url !== 'function' && (this.url = t.path + this.url), this.src = '', this.xhrSettings = l(r(e, 'responseType', void 0)), r(e, 'xhrSettings', !1) && (this.xhrSettings = a(this.xhrSettings, r(e, 'xhrSettings', {}))), this.xhrLoader = null, this.state = typeof this.url === 'function' ? s.FILE_POPULATED : s.FILE_PENDING, this.bytesTotal = 0, this.bytesLoaded = -1, this.percentComplete = -1, this.crossOrigin = void 0, this.data = void 0, this.config = r(e, 'config', {}), this.multiFile, this.linkFile; }, setLink(t) { this.linkFile = t, t.linkFile = this; }, resetXHR() { this.xhrLoader && (this.xhrLoader.onload = void 0, this.xhrLoader.onerror = void 0, this.xhrLoader.onprogress = void 0); }, load() { this.state === s.FILE_POPULATED ? this.loader.nextFile(this, !0) : (this.src = o(this, this.loader.baseURL), this.src.indexOf('data:') === 0 ? console.warn(`Local data URIs are not supported: ${this.key}`) : this.xhrLoader = h(this, this.loader.xhr)); }, onLoad(t, e) { let i = !(e.target && e.target.status !== 200); t.readyState === 4 && t.status >= 400 && t.status <= 599 && (i = !1), this.resetXHR(), this.loader.nextFile(this, i); }, onError() { this.resetXHR(), this.loader.nextFile(this, !1); }, onProgress(t) { t.lengthComputable && (this.bytesLoaded = t.loaded, this.bytesTotal = t.total, this.percentComplete = Math.min(this.bytesLoaded / this.bytesTotal, 1), this.loader.emit('fileprogress', this, this.percentComplete)); }, onProcess() { this.state = s.FILE_PROCESSING, this.onProcessComplete(); }, onProcessComplete() { this.state = s.FILE_COMPLETE, this.multiFile && this.multiFile.onFileComplete(this), this.loader.fileProcessComplete(this); }, onProcessError() { this.state = s.FILE_ERRORED, this.multiFile && this.multiFile.onFileFailed(this), this.loader.fileProcessComplete(this); }, hasCacheConflict() { return this.cache && this.cache.exists(this.key); }, addToCache() { this.cache && this.cache.add(this.key, this.data), this.pendingDestroy(); }, pendingDestroy(t) { void 0 === t && (t = this.data); const e = this.key; const i = this.type; this.loader.emit('filecomplete', e, i, t), this.loader.emit(`filecomplete-${i}-${e}`, e, i, t), this.loader.flagForRemoval(this); }, destroy() { this.loader = null, this.cache = null, this.xhrSettings = null, this.multiFile = null, this.linkFile = null, this.data = null; },
  }); u.createObjectURL = function (t, e, i) { if (typeof URL === 'function')t.src = URL.createObjectURL(e); else { const n = new FileReader(); n.onload = function () { t.removeAttribute('crossOrigin'), t.src = `data:${e.type || i};base64,${n.result.split(',')[1]}`; }, n.onerror = t.onerror, n.readAsDataURL(e); } }, u.revokeObjectURL = function (t) { typeof URL === 'function' && URL.revokeObjectURL(t.src); }, t.exports = u;
}, function (t, e) { t.exports = function (t, e, i, n, s) { const r = n.alpha * i.alpha; if (r <= 0) return !1; const o = t._tempMatrix1.copyFromArray(n.matrix.matrix); const a = t._tempMatrix2.applyITRS(i.x, i.y, i.rotation, i.scaleX, i.scaleY); const h = t._tempMatrix3; return s ? (o.multiplyWithOffset(s, -n.scrollX * i.scrollFactorX, -n.scrollY * i.scrollFactorY), a.e = i.x, a.f = i.y, o.multiply(a, h)) : (a.e -= n.scrollX * i.scrollFactorX, a.f -= n.scrollY * i.scrollFactorY, o.multiply(a, h)), e.globalCompositeOperation = t.blendModes[i.blendMode], e.globalAlpha = r, e.save(), h.setToContext(e), !0; }; }, function (t, e) { t.exports = function (t, e, i) { return Math.max(e, Math.min(i, t)); }; }, function (t, e, i) {
  let n; let s; let r; const o = i(26); const a = i(120); const h = []; let l = !1; t.exports = {
    create2D(t, e, i) { return n(t, e, i, o.CANVAS); }, create: n = function (t, e, i, n, r) { let u; void 0 === e && (e = 1), void 0 === i && (i = 1), void 0 === n && (n = o.CANVAS), void 0 === r && (r = !1); let c = s(n); return c === null ? (c = { parent: t, canvas: document.createElement('canvas'), type: n }, n === o.CANVAS && h.push(c), u = c.canvas) : (c.parent = t, u = c.canvas), r && (c.parent = u), u.width = e, u.height = i, l && n === o.CANVAS && a.disable(u.getContext('2d')), u; }, createWebGL(t, e, i) { return n(t, e, i, o.WEBGL); }, disableSmoothing() { l = !0; }, enableSmoothing() { l = !1; }, first: s = function (t) { if (void 0 === t && (t = o.CANVAS), t === o.WEBGL) return null; for (let e = 0; e < h.length; e++) { const i = h[e]; if (!i.parent && i.type === t) return i; } return null; }, free() { return h.length - r(); }, pool: h, remove(t) { const e = t instanceof HTMLCanvasElement; h.forEach((i) => { (e && i.canvas === t || !e && i.parent === t) && (i.parent = null, i.canvas.width = 1, i.canvas.height = 1); }); }, total: r = function () { let t = 0; return h.forEach((e) => { e.parent && t++; }), t; },
  };
}, function (t, e) { t.exports = function (t, e, i, n, s, r) { let o; void 0 === n && (n = 0), void 0 === s && (s = 0), void 0 === r && (r = 1); let a = 0; const h = t.length; if (r === 1) for (o = s; o < h; o++)t[o][e] = i + a * n, a++; else for (o = s; o >= 0; o--)t[o][e] = i + a * n, a++; return t; }; }, function (t, e, i) {
  const n = {
    VERSION: '3.15.1', BlendModes: i(66), ScaleModes: i(94), AUTO: 0, CANVAS: 1, WEBGL: 2, HEADLESS: 3, FOREVER: -1, NONE: 4, UP: 5, DOWN: 6, LEFT: 7, RIGHT: 8,
  }; t.exports = n;
}, function (t, e, i) {
  const n = i(0); const s = i(14); const r = i(19); const o = i(54); const a = new n({
    Extends: r, Mixins: [s.Alpha, s.BlendMode, s.ComputedSize, s.Depth, s.GetBounds, s.Mask, s.Origin, s.Pipeline, s.ScaleMode, s.ScrollFactor, s.Transform, s.Visible], initialize(t, e, i) { void 0 === e && (e = 'Shape'), r.call(this, t, e), this.geom = i, this.pathData = [], this.pathIndexes = [], this.fillColor = 16777215, this.fillAlpha = 1, this.strokeColor = 16777215, this.strokeAlpha = 1, this.lineWidth = 1, this.isFilled = !1, this.isStroked = !1, this.closePath = !0, this._tempLine = new o(), this.initPipeline(); }, setFillStyle(t, e) { return void 0 === e && (e = 1), void 0 === t ? this.isFilled = !1 : (this.fillColor = t, this.fillAlpha = e, this.isFilled = !0), this; }, setStrokeStyle(t, e, i) { return void 0 === i && (i = 1), void 0 === t ? this.isStroked = !1 : (this.lineWidth = t, this.strokeColor = e, this.strokeAlpha = i, this.isStroked = !0), this; }, setClosePath(t) { return this.closePath = t, this; }, preDestroy() { this.geom = null, this._tempLine = null, this.pathData = [], this.pathIndexes = []; },
  }); t.exports = a;
}, function (t, e, i) { const n = i(66); const s = i(12); const r = i(94); t.exports = function (t, e, i) { e.x = s(i, 'x', 0), e.y = s(i, 'y', 0), e.depth = s(i, 'depth', 0), e.flipX = s(i, 'flipX', !1), e.flipY = s(i, 'flipY', !1); const o = s(i, 'scale', null); typeof o === 'number' ? e.setScale(o) : o !== null && (e.scaleX = s(o, 'x', 1), e.scaleY = s(o, 'y', 1)); const a = s(i, 'scrollFactor', null); typeof a === 'number' ? e.setScrollFactor(a) : a !== null && (e.scrollFactorX = s(a, 'x', 1), e.scrollFactorY = s(a, 'y', 1)), e.rotation = s(i, 'rotation', 0); const h = s(i, 'angle', null); h !== null && (e.angle = h), e.alpha = s(i, 'alpha', 1); const l = s(i, 'origin', null); if (typeof l === 'number')e.setOrigin(l); else if (l !== null) { const u = s(l, 'x', 0.5); const c = s(l, 'y', 0.5); e.setOrigin(u, c); } return e.scaleMode = s(i, 'scaleMode', r.DEFAULT), e.blendMode = s(i, 'blendMode', n.NORMAL), e.visible = s(i, 'visible', !0), s(i, 'add', !0) && t.sys.displayList.add(e), e.preUpdate && t.sys.updateList.add(e), e; }; }, function (t, e) {
  t.exports = {
    CSV: 0, TILED_JSON: 1, ARRAY_2D: 2, WELTMEISTER: 3,
  };
}, function (t, e) { t.exports = function (t, e, i) { const n = i || e.fillColor; const s = e.fillAlpha; const r = (16711680 & n) >>> 16; const o = (65280 & n) >>> 8; const a = 255 & n; t.fillStyle = `rgba(${r},${o},${a},${s})`; }; }, function (t, e, i) { const n = i(16); t.exports = function (t) { return t * n.DEG_TO_RAD; }; }, function (t, e) { t.exports = function (t, e, i, n, s, r) { let o; void 0 === n && (n = 0), void 0 === s && (s = 0), void 0 === r && (r = 1); let a = 0; const h = t.length; if (r === 1) for (o = s; o < h; o++)t[o][e] += i + a * n, a++; else for (o = s; o >= 0; o--)t[o][e] += i + a * n, a++; return t; }; }, function (t, e, i) { (function (e) { const i = {}; t.exports = i, (function () { i._nextId = 0, i._seed = 0, i._nowStartTime = +new Date(), i.extend = function (t, e) { let n; let s; typeof e === 'boolean' ? (n = 2, s = e) : (n = 1, s = !0); for (let r = n; r < arguments.length; r++) { const o = arguments[r]; if (o) for (const a in o)s && o[a] && o[a].constructor === Object ? t[a] && t[a].constructor !== Object ? t[a] = o[a] : (t[a] = t[a] || {}, i.extend(t[a], s, o[a])) : t[a] = o[a]; } return t; }, i.clone = function (t, e) { return i.extend({}, e, t); }, i.keys = function (t) { if (Object.keys) return Object.keys(t); const e = []; for (const i in t)e.push(i); return e; }, i.values = function (t) { const e = []; if (Object.keys) { for (let i = Object.keys(t), n = 0; n < i.length; n++)e.push(t[i[n]]); return e; } for (const s in t)e.push(t[s]); return e; }, i.get = function (t, e, i, n) { e = e.split('.').slice(i, n); for (let s = 0; s < e.length; s += 1)t = t[e[s]]; return t; }, i.set = function (t, e, n, s, r) { const o = e.split('.').slice(s, r); return i.get(t, e, 0, -1)[o[o.length - 1]] = n, n; }, i.shuffle = function (t) { for (let e = t.length - 1; e > 0; e--) { const n = Math.floor(i.random() * (e + 1)); const s = t[e]; t[e] = t[n], t[n] = s; } return t; }, i.choose = function (t) { return t[Math.floor(i.random() * t.length)]; }, i.isElement = function (t) { return typeof HTMLElement !== 'undefined' ? t instanceof HTMLElement : !!(t && t.nodeType && t.nodeName); }, i.isArray = function (t) { return Object.prototype.toString.call(t) === '[object Array]'; }, i.isFunction = function (t) { return typeof t === 'function'; }, i.isPlainObject = function (t) { return typeof t === 'object' && t.constructor === Object; }, i.isString = function (t) { return toString.call(t) === '[object String]'; }, i.clamp = function (t, e, i) { return t < e ? e : t > i ? i : t; }, i.sign = function (t) { return t < 0 ? -1 : 1; }, i.now = function () { if (window.performance) { if (window.performance.now) return window.performance.now(); if (window.performance.webkitNow) return window.performance.webkitNow(); } return new Date() - i._nowStartTime; }, i.random = function (e, i) { return e = void 0 !== e ? e : 0, i = void 0 !== i ? i : 1, e + t() * (i - e); }; var t = function () { return i._seed = (9301 * i._seed + 49297) % 233280, i._seed / 233280; }; i.colorToNumber = function (t) { return (t = t.replace('#', '')).length == 3 && (t = t.charAt(0) + t.charAt(0) + t.charAt(1) + t.charAt(1) + t.charAt(2) + t.charAt(2)), parseInt(t, 16); }, i.logLevel = 1, i.log = function () { console && i.logLevel > 0 && i.logLevel <= 3 && console.log.apply(console, ['matter-js:'].concat(Array.prototype.slice.call(arguments))); }, i.info = function () { console && i.logLevel > 0 && i.logLevel <= 2 && console.info.apply(console, ['matter-js:'].concat(Array.prototype.slice.call(arguments))); }, i.warn = function () { console && i.logLevel > 0 && i.logLevel <= 3 && console.warn.apply(console, ['matter-js:'].concat(Array.prototype.slice.call(arguments))); }, i.nextId = function () { return i._nextId++; }, i.indexOf = function (t, e) { if (t.indexOf) return t.indexOf(e); for (let i = 0; i < t.length; i++) if (t[i] === e) return i; return -1; }, i.map = function (t, e) { if (t.map) return t.map(e); for (var i = [], n = 0; n < t.length; n += 1)i.push(e(t[n])); return i; }, i.topologicalSort = function (t) { const e = []; const n = []; const s = []; for (const r in t)n[r] || s[r] || i._topologicalSort(r, n, s, t, e); return e; }, i._topologicalSort = function (t, e, n, s, r) { const o = s[t] || []; n[t] = !0; for (let a = 0; a < o.length; a += 1) { const h = o[a]; n[h] || (e[h] || i._topologicalSort(h, e, n, s, r)); }n[t] = !1, e[t] = !0, r.push(t); }, i.chain = function () { for (var t = [], e = 0; e < arguments.length; e += 1) { const i = arguments[e]; i._chained ? t.push.apply(t, i._chained) : t.push(i); } const n = function () { for (var e, i = new Array(arguments.length), n = 0, s = arguments.length; n < s; n++)i[n] = arguments[n]; for (n = 0; n < t.length; n += 1) { const r = t[n].apply(e, i); void 0 !== r && (e = r); } return e; }; return n._chained = t, n; }, i.chainPathBefore = function (t, e, n) { return i.set(t, e, i.chain(n, i.get(t, e))); }, i.chainPathAfter = function (t, e, n) { return i.set(t, e, i.chain(i.get(t, e), n)); }, i._requireGlobal = function (t, i) { return typeof window !== 'undefined' ? window[t] : void 0 !== e ? e[t] : null; }; }()); }).call(this, i(200)); }, function (t, e, i) { const n = i(102); const s = i(17); t.exports = function (t, e, i, r, o) { for (let a = null, h = null, l = null, u = null, c = s(t, e, i, r, null, o), d = 0; d < c.length; d++) { const f = c[d]; f && (f.collides ? (a = n(f.x, f.y - 1, !0, o), h = n(f.x, f.y + 1, !0, o), l = n(f.x - 1, f.y, !0, o), u = n(f.x + 1, f.y, !0, o), f.faceTop = !a || !a.collides, f.faceBottom = !h || !h.collides, f.faceLeft = !l || !l.collides, f.faceRight = !u || !u.collides) : f.resetFaces()); } }; }, function (t, e) {
  t.exports = {
    DYNAMIC_BODY: 0, STATIC_BODY: 1, GROUP: 2, TILEMAPLAYER: 3, FACING_NONE: 10, FACING_UP: 11, FACING_DOWN: 12, FACING_LEFT: 13, FACING_RIGHT: 14,
  };
}, function (t, e) { t.exports = function (t, e) { const i = e.strokeColor; const n = e.strokeAlpha; const s = (16711680 & i) >>> 16; const r = (65280 & i) >>> 8; const o = 255 & i; t.strokeStyle = `rgba(${s},${r},${o},${n})`, t.lineWidth = e.lineWidth; }; }, function (t, e, i) {
  const n = i(0); const s = i(177); const r = i(376); const o = i(176); const a = i(375); var h = new n({
    initialize(t, e, i, n) { void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 255), this.r = 0, this.g = 0, this.b = 0, this.a = 255, this._h = 0, this._s = 0, this._v = 0, this._locked = !1, this.gl = [0, 0, 0, 1], this._color = 0, this._color32 = 0, this._rgba = '', this.setTo(t, e, i, n); }, transparent() { return this._locked = !0, this.red = 0, this.green = 0, this.blue = 0, this.alpha = 0, this._locked = !1, this.update(!0); }, setTo(t, e, i, n, s) { return void 0 === n && (n = 255), void 0 === s && (s = !0), this._locked = !0, this.red = t, this.green = e, this.blue = i, this.alpha = n, this._locked = !1, this.update(s); }, setGLTo(t, e, i, n) { return void 0 === n && (n = 1), this._locked = !0, this.redGL = t, this.greenGL = e, this.blueGL = i, this.alphaGL = n, this._locked = !1, this.update(!0); }, setFromRGB(t) { return this._locked = !0, this.red = t.r, this.green = t.g, this.blue = t.b, t.hasOwnProperty('a') && (this.alpha = t.a), this._locked = !1, this.update(!0); }, setFromHSV(t, e, i) { return o(t, e, i, this); }, update(t) { if (void 0 === t && (t = !1), this._locked) return this; const e = this.r; const i = this.g; const n = this.b; const o = this.a; return this._color = s(e, i, n), this._color32 = r(e, i, n, o), this._rgba = `rgba(${e},${i},${n},${o / 255})`, t && a(e, i, n, this), this; }, updateHSV() { const t = this.r; const e = this.g; const i = this.b; return a(t, e, i, this), this; }, clone() { return new h(this.r, this.g, this.b, this.a); }, gray(t) { return this.setTo(t, t, t); }, random(t, e) { void 0 === t && (t = 0), void 0 === e && (e = 255); const i = Math.floor(t + Math.random() * (e - t)); const n = Math.floor(t + Math.random() * (e - t)); const s = Math.floor(t + Math.random() * (e - t)); return this.setTo(i, n, s); }, randomGray(t, e) { void 0 === t && (t = 0), void 0 === e && (e = 255); const i = Math.floor(t + Math.random() * (e - t)); return this.setTo(i, i, i); }, saturate(t) { return this.s += t / 100, this; }, desaturate(t) { return this.s -= t / 100, this; }, lighten(t) { return this.v += t / 100, this; }, darken(t) { return this.v -= t / 100, this; }, brighten(t) { let e = this.r; let i = this.g; let n = this.b; return e = Math.max(0, Math.min(255, e - Math.round(-t / 100 * 255))), i = Math.max(0, Math.min(255, i - Math.round(-t / 100 * 255))), n = Math.max(0, Math.min(255, n - Math.round(-t / 100 * 255))), this.setTo(e, i, n); }, color: { get() { return this._color; } }, color32: { get() { return this._color32; } }, rgba: { get() { return this._rgba; } }, redGL: { get() { return this.gl[0]; }, set(t) { this.gl[0] = Math.min(Math.abs(t), 1), this.r = Math.floor(255 * this.gl[0]), this.update(!0); } }, greenGL: { get() { return this.gl[1]; }, set(t) { this.gl[1] = Math.min(Math.abs(t), 1), this.g = Math.floor(255 * this.gl[1]), this.update(!0); } }, blueGL: { get() { return this.gl[2]; }, set(t) { this.gl[2] = Math.min(Math.abs(t), 1), this.b = Math.floor(255 * this.gl[2]), this.update(!0); } }, alphaGL: { get() { return this.gl[3]; }, set(t) { this.gl[3] = Math.min(Math.abs(t), 1), this.a = Math.floor(255 * this.gl[3]), this.update(); } }, red: { get() { return this.r; }, set(t) { t = Math.floor(Math.abs(t)), this.r = Math.min(t, 255), this.gl[0] = t / 255, this.update(!0); } }, green: { get() { return this.g; }, set(t) { t = Math.floor(Math.abs(t)), this.g = Math.min(t, 255), this.gl[1] = t / 255, this.update(!0); } }, blue: { get() { return this.b; }, set(t) { t = Math.floor(Math.abs(t)), this.b = Math.min(t, 255), this.gl[2] = t / 255, this.update(!0); } }, alpha: { get() { return this.a; }, set(t) { t = Math.floor(Math.abs(t)), this.a = Math.min(t, 255), this.gl[3] = t / 255, this.update(); } }, h: { get() { return this._h; }, set(t) { this._h = t, o(t, this._s, this._v, this); } }, s: { get() { return this._s; }, set(t) { this._s = t, o(this._h, t, this._v, this); } }, v: { get() { return this._v; }, set(t) { this._v = t, o(this._h, this._s, t, this); } },
  }); t.exports = h;
}, function (t, e, i) {
  const n = i(0); const s = i(3); const r = new n({
    initialize(t, e, i, n, s, r) {
      void 0 === t && (t = 1), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 1), void 0 === s && (s = 0), void 0 === r && (r = 0), this.matrix = new Float32Array([t, e, i, n, s, r, 0, 0, 1]), this.decomposedMatrix = {
        translateX: 0, translateY: 0, scaleX: 1, scaleY: 1, rotation: 0,
      };
    },
    a: { get() { return this.matrix[0]; }, set(t) { this.matrix[0] = t; } },
    b: { get() { return this.matrix[1]; }, set(t) { this.matrix[1] = t; } },
    c: { get() { return this.matrix[2]; }, set(t) { this.matrix[2] = t; } },
    d: { get() { return this.matrix[3]; }, set(t) { this.matrix[3] = t; } },
    e: { get() { return this.matrix[4]; }, set(t) { this.matrix[4] = t; } },
    f: { get() { return this.matrix[5]; }, set(t) { this.matrix[5] = t; } },
    tx: { get() { return this.matrix[4]; }, set(t) { this.matrix[4] = t; } },
    ty: { get() { return this.matrix[5]; }, set(t) { this.matrix[5] = t; } },
    rotation: { get() { return Math.acos(this.a / this.scaleX) * (Math.atan(-this.c / this.a) < 0 ? -1 : 1); } },
    scaleX: { get() { return Math.sqrt(this.a * this.a + this.c * this.c); } },
    scaleY: { get() { return Math.sqrt(this.b * this.b + this.d * this.d); } },
    loadIdentity() { const t = this.matrix; return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0, t[5] = 0, this; },
    translate(t, e) { const i = this.matrix; return i[4] = i[0] * t + i[2] * e + i[4], i[5] = i[1] * t + i[3] * e + i[5], this; },
    scale(t, e) { const i = this.matrix; return i[0] *= t, i[1] *= t, i[2] *= e, i[3] *= e, this; },
    rotate(t) { const e = Math.sin(t); const i = Math.cos(t); const n = this.matrix; const s = n[0]; const r = n[1]; const o = n[2]; const a = n[3]; return n[0] = s * i + o * e, n[1] = r * i + a * e, n[2] = s * -e + o * i, n[3] = r * -e + a * i, this; },
    multiply(t, e) { const i = this.matrix; const n = t.matrix; const s = i[0]; const r = i[1]; const o = i[2]; const a = i[3]; const h = i[4]; const l = i[5]; const u = n[0]; const c = n[1]; const d = n[2]; const f = n[3]; const p = n[4]; const g = n[5]; const v = void 0 === e ? this : e; return v.a = u * s + c * o, v.b = u * r + c * a, v.c = d * s + f * o, v.d = d * r + f * a, v.e = p * s + g * o + h, v.f = p * r + g * a + l, v; },
    multiplyWithOffset(t, e, i) { const n = this.matrix; const s = t.matrix; const r = n[0]; const o = n[1]; const a = n[2]; const h = n[3]; const l = e * r + i * a + n[4]; const u = e * o + i * h + n[5]; const c = s[0]; const d = s[1]; const f = s[2]; const p = s[3]; const g = s[4]; const v = s[5]; return n[0] = c * r + d * a, n[1] = c * o + d * h, n[2] = f * r + p * a, n[3] = f * o + p * h, n[4] = g * r + v * a + l, n[5] = g * o + v * h + u, this; },
    transform(t, e, i, n, s, r) { const o = this.matrix; const a = o[0]; const h = o[1]; const l = o[2]; const u = o[3]; const c = o[4]; const d = o[5]; return o[0] = t * a + e * l, o[1] = t * h + e * u, o[2] = i * a + n * l, o[3] = i * h + n * u, o[4] = s * a + r * l + c, o[5] = s * h + r * u + d, this; },
    transformPoint(t, e, i) { void 0 === i && (i = { x: 0, y: 0 }); const n = this.matrix; const s = n[0]; const r = n[1]; const o = n[2]; const a = n[3]; const h = n[4]; const l = n[5]; return i.x = t * s + e * o + h, i.y = t * r + e * a + l, i; },
    invert() { const t = this.matrix; const e = t[0]; const i = t[1]; const n = t[2]; const s = t[3]; const r = t[4]; const o = t[5]; const a = e * s - i * n; return t[0] = s / a, t[1] = -i / a, t[2] = -n / a, t[3] = e / a, t[4] = (n * o - s * r) / a, t[5] = -(e * o - i * r) / a, this; },
    copyFrom(t) { const e = this.matrix; return e[0] = t.a, e[1] = t.b, e[2] = t.c, e[3] = t.d, e[4] = t.e, e[5] = t.f, this; },
    copyFromArray(t) { const e = this.matrix; return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], this; },
    copyToContext(t) { const e = this.matrix; return t.transform(e[0], e[1], e[2], e[3], e[4], e[5]), t; },
    setToContext(t) { const e = this.matrix; return t.setTransform(e[0], e[1], e[2], e[3], e[4], e[5]), t; },
    copyToArray(t) { const e = this.matrix; return void 0 === t ? t = [e[0], e[1], e[2], e[3], e[4], e[5]] : (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5]), t; },
    setTransform(t, e, i, n, s, r) { const o = this.matrix; return o[0] = t, o[1] = e, o[2] = i, o[3] = n, o[4] = s, o[5] = r, this; },
    decomposeMatrix() { const t = this.decomposedMatrix; const e = this.matrix; const i = e[0]; const n = e[1]; const s = e[2]; const r = e[3]; const o = i * i; const a = n * n; const h = s * s; const l = r * r; const u = Math.sqrt(o + h); const c = Math.sqrt(a + l); return t.translateX = e[4], t.translateY = e[5], t.scaleX = u, t.scaleY = c, t.rotation = Math.acos(i / u) * (Math.atan(-s / i) < 0 ? -1 : 1), t; },
    applyITRS(t, e, i, n, s) { const r = this.matrix; const o = Math.sin(i); const a = Math.cos(i); return r[4] = t, r[5] = e, r[0] = a * n, r[1] = o * n, r[2] = -o * s, r[3] = a * s, this; },
    applyInverse(t, e, i) { void 0 === i && (i = new s()); const n = this.matrix; const r = n[0]; const o = n[1]; const a = n[2]; const h = n[3]; const l = n[4]; const u = n[5]; const c = 1 / (r * h + a * -o); return i.x = h * c * t + -a * c * e + (u * a - l * h) * c, i.y = r * c * e + -o * c * t + (-u * r + l * o) * c, i; },
    getX(t, e) { return t * this.a + e * this.c + this.e; },
    getY(t, e) { return t * this.b + e * this.d + this.f; },
    getCSSMatrix() { const t = this.matrix; return `matrix(${t[0]},${t[1]},${t[2]},${t[3]},${t[4]},${t[5]})`; },
    destroy() { this.matrix = null, this.decomposedMatrix = null; },
  }); t.exports = r;
}, function (t, e) { t.exports = function (t, e, i) { return !(t.width <= 0 || t.height <= 0) && t.x <= e && t.x + t.width >= e && t.y <= i && t.y + t.height >= i; }; }, function (t, e) { t.exports = function (t, e, i) { return t.radius > 0 && e >= t.left && e <= t.right && i >= t.top && i <= t.bottom && (t.x - e) * (t.x - e) + (t.y - i) * (t.y - i) <= t.radius * t.radius; }; }, function (t, e) { t.exports = function (t, e) { return t.y = e + t.height * t.originY, t; }; }, function (t, e) { t.exports = function (t) { return t.y - t.height * t.originY; }; }, function (t, e) { t.exports = function (t, e) { return t.x = e - t.width + t.width * t.originX, t; }; }, function (t, e) { t.exports = function (t) { return t.x + t.width - t.width * t.originX; }; }, function (t, e) { t.exports = function (t, e) { return t.x = e + t.width * t.originX, t; }; }, function (t, e) { t.exports = function (t) { return t.x - t.width * t.originX; }; }, function (t, e) { t.exports = function (t, e) { return t.y = e - t.height + t.height * t.originY, t; }; }, function (t, e) { t.exports = function (t) { return t.y + t.height - t.height * t.originY; }; }, function (t, e) { t.exports = function (t, e, i, n) { void 0 === e && (e = !0); let s = n.baseTileHeight; const r = n.tilemapLayer; return r && (void 0 === i && (i = r.scene.cameras.main), t -= r.y + i.scrollY * (1 - r.scrollFactorY), s *= r.scaleY), e ? Math.floor(t / s) : t / s; }; }, function (t, e) { t.exports = function (t, e, i, n) { void 0 === e && (e = !0); let s = n.baseTileWidth; const r = n.tilemapLayer; return r && (void 0 === i && (i = r.scene.cameras.main), t -= r.x + i.scrollX * (1 - r.scrollFactorX), s *= r.scaleX), e ? Math.floor(t / s) : t / s; }; }, function (t, e, i) {
  const n = i(0); const s = i(18); const r = i(21); const o = i(7); const a = i(2); const h = i(4); const l = i(8); const u = new n({
    Extends: r,
    initialize(t, e, i, n, o) {
      let u = 'json'; if (l(e)) { const c = e; e = a(c, 'key'), i = a(c, 'url'), n = a(c, 'xhrSettings'), u = a(c, 'extension', u), o = a(c, 'dataKey', o); } const d = {
        type: 'json', cache: t.cacheManager.json, extension: u, responseType: 'text', key: e, url: i, xhrSettings: n, config: o,
      }; r.call(this, t, d), l(i) && (this.data = o ? h(i, o) : i, this.state = s.FILE_POPULATED);
    },
    onProcess() { if (this.state !== s.FILE_POPULATED) { this.state = s.FILE_PROCESSING; const t = JSON.parse(this.xhrLoader.responseText); const e = this.config; this.data = typeof e === 'string' ? h(t, e, t) : t; } this.onProcessComplete(); },
  }); o.register('json', function (t, e, i, n) { if (Array.isArray(t)) for (let s = 0; s < t.length; s++) this.addFile(new u(this, t[s])); else this.addFile(new u(this, t, e, n, i)); return this; }), t.exports = u;
}, function (t, e) { t.exports = function (t, e, i, n) { const s = t - i; const r = e - n; return Math.sqrt(s * s + r * r); }; }, function (t, e) { t.exports = function (t, e, i) { const n = i - e; return e + ((t - e) % n + n) % n; }; }, function (t, e, i) {
  const n = i(0); const s = i(397); const r = i(189); const o = i(188); const a = i(3); const h = new n({
    initialize(t, e, i, n) { void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), this.x1 = t, this.y1 = e, this.x2 = i, this.y2 = n; }, getPoint(t, e) { return s(this, t, e); }, getPoints(t, e, i) { return r(this, t, e, i); }, getRandomPoint(t) { return o(this, t); }, setTo(t, e, i, n) { return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), this.x1 = t, this.y1 = e, this.x2 = i, this.y2 = n, this; }, getPointA(t) { return void 0 === t && (t = new a()), t.set(this.x1, this.y1), t; }, getPointB(t) { return void 0 === t && (t = new a()), t.set(this.x2, this.y2), t; }, left: { get() { return Math.min(this.x1, this.x2); }, set(t) { this.x1 <= this.x2 ? this.x1 = t : this.x2 = t; } }, right: { get() { return Math.max(this.x1, this.x2); }, set(t) { this.x1 > this.x2 ? this.x1 = t : this.x2 = t; } }, top: { get() { return Math.min(this.y1, this.y2); }, set(t) { this.y1 <= this.y2 ? this.y1 = t : this.y2 = t; } }, bottom: { get() { return Math.max(this.y1, this.y2); }, set(t) { this.y1 > this.y2 ? this.y1 = t : this.y2 = t; } },
  }); t.exports = h;
}, function (t, e, i) {
  const n = i(0); const s = i(14); const r = i(265); const o = new n({
    Mixins: [s.Alpha, s.Flip, s.Visible], initialize(t, e, i, n, s, r, o, a) { this.layer = t, this.index = e, this.x = i, this.y = n, this.width = s, this.height = r, this.baseWidth = void 0 !== o ? o : s, this.baseHeight = void 0 !== a ? a : r, this.pixelX = 0, this.pixelY = 0, this.updatePixelXY(), this.properties = {}, this.rotation = 0, this.collideLeft = !1, this.collideRight = !1, this.collideUp = !1, this.collideDown = !1, this.faceLeft = !1, this.faceRight = !1, this.faceTop = !1, this.faceBottom = !1, this.collisionCallback = null, this.collisionCallbackContext = this, this.tint = 16777215, this.physics = {}; }, containsPoint(t, e) { return !(t < this.pixelX || e < this.pixelY || t > this.right || e > this.bottom); }, copy(t) { return this.index = t.index, this.alpha = t.alpha, this.properties = t.properties, this.visible = t.visible, this.setFlip(t.flipX, t.flipY), this.tint = t.tint, this.rotation = t.rotation, this.collideUp = t.collideUp, this.collideDown = t.collideDown, this.collideLeft = t.collideLeft, this.collideRight = t.collideRight, this.collisionCallback = t.collisionCallback, this.collisionCallbackContext = t.collisionCallbackContext, this; }, getCollisionGroup() { return this.tileset ? this.tileset.getTileCollisionGroup(this.index) : null; }, getTileData() { return this.tileset ? this.tileset.getTileData(this.index) : null; }, getLeft(t) { const e = this.tilemapLayer; return e ? e.tileToWorldX(this.x, t) : this.x * this.baseWidth; }, getRight(t) { const e = this.tilemapLayer; return e ? this.getLeft(t) + this.width * e.scaleX : this.getLeft(t) + this.width; }, getTop(t) { const e = this.tilemapLayer; return e ? e.tileToWorldY(this.y, t) - (this.height - this.baseHeight) * e.scaleY : this.y * this.baseHeight - (this.height - this.baseHeight); }, getBottom(t) { const e = this.tilemapLayer; return e ? this.getTop(t) + this.height * e.scaleY : this.getTop(t) + this.height; }, getBounds(t, e) { return void 0 === e && (e = new r()), e.x = this.getLeft(), e.y = this.getTop(), e.width = this.getRight() - e.x, e.height = this.getBottom() - e.y, e; }, getCenterX(t) { return this.getLeft(t) + this.width / 2; }, getCenterY(t) { return this.getTop(t) + this.height / 2; }, destroy() { this.collisionCallback = void 0, this.collisionCallbackContext = void 0, this.properties = void 0; }, intersects(t, e, i, n) { return !(i <= this.pixelX || n <= this.pixelY || t >= this.right || e >= this.bottom); }, isInteresting(t, e) { return t && e ? this.canCollide || this.hasInterestingFace : t ? this.collides : !!e && this.hasInterestingFace; }, resetCollision(t) { (void 0 === t && (t = !0), this.collideLeft = !1, this.collideRight = !1, this.collideUp = !1, this.collideDown = !1, this.faceTop = !1, this.faceBottom = !1, this.faceLeft = !1, this.faceRight = !1, t) && (this.tilemapLayer && this.tilemapLayer.calculateFacesAt(this.x, this.y)); return this; }, resetFaces() { return this.faceTop = !1, this.faceBottom = !1, this.faceLeft = !1, this.faceRight = !1, this; }, setCollision(t, e, i, n, s) { (void 0 === e && (e = t), void 0 === i && (i = t), void 0 === n && (n = t), void 0 === s && (s = !0), this.collideLeft = t, this.collideRight = e, this.collideUp = i, this.collideDown = n, this.faceLeft = t, this.faceRight = e, this.faceTop = i, this.faceBottom = n, s) && (this.tilemapLayer && this.tilemapLayer.calculateFacesAt(this.x, this.y)); return this; }, setCollisionCallback(t, e) { return t === null ? (this.collisionCallback = void 0, this.collisionCallbackContext = void 0) : (this.collisionCallback = t, this.collisionCallbackContext = e), this; }, setSize(t, e, i, n) { return void 0 !== t && (this.width = t), void 0 !== e && (this.height = e), void 0 !== i && (this.baseWidth = i), void 0 !== n && (this.baseHeight = n), this.updatePixelXY(), this; }, updatePixelXY() { return this.pixelX = this.x * this.baseWidth, this.pixelY = this.y * this.baseHeight - (this.height - this.baseHeight), this; }, canCollide: { get() { return this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.collisionCallback; } }, collides: { get() { return this.collideLeft || this.collideRight || this.collideUp || this.collideDown; } }, hasInterestingFace: { get() { return this.faceTop || this.faceBottom || this.faceLeft || this.faceRight; } }, tileset: { get() { const t = this.tilemapLayer; return t ? t.tileset : null; } }, tilemapLayer: { get() { return this.layer.tilemapLayer; } }, tilemap: { get() { const t = this.tilemapLayer; return t ? t.tilemap : null; } },
  }); t.exports = o;
}, function (t, e) { t.exports = function (t, e) { e ? t.setCollision(!0, !0, !0, !0, !1) : t.resetCollision(!1); }; }, function (t, e, i) {
  const n = new (i(0))({
    initialize(t, e, i, n) { this.loader = t, this.type = e, this.key = i, this.files = n, this.complete = !1, this.pending = n.length, this.failed = 0, this.config = {}; for (let s = 0; s < n.length; s++)n[s].multiFile = this; }, isReadyToProcess() { return this.pending === 0 && this.failed === 0 && !this.complete; }, addToMultiFile(t) { return this.files.push(t), t.multiFile = this, this.pending++, this.complete = !1, this; }, onFileComplete(t) { this.files.indexOf(t) !== -1 && this.pending--; }, onFileFailed(t) { this.files.indexOf(t) !== -1 && this.failed++; },
  }); t.exports = n;
}, function (t, e, i) {
  const n = i(0); const s = i(18); const r = i(21); const o = i(7); const a = i(2); const h = i(8); const l = new n({
    Extends: r,
    initialize: function t(e, i, n, s, o) {
      let l; let u = 'png'; if (h(i)) { const c = i; i = a(c, 'key'), n = a(c, 'url'), l = a(c, 'normalMap'), s = a(c, 'xhrSettings'), u = a(c, 'extension', u), o = a(c, 'frameConfig'); }Array.isArray(n) && (l = n[1], n = n[0]); const d = {
        type: 'image', cache: e.textureManager, extension: u, responseType: 'blob', key: i, url: n, xhrSettings: s, config: o,
      }; if (r.call(this, e, d), l) { const f = new t(e, this.key, l, s, o); f.type = 'normalMap', this.setLink(f), e.addFile(f); }
    },
    onProcess() { this.state = s.FILE_PROCESSING, this.data = new Image(), this.data.crossOrigin = this.crossOrigin; const t = this; this.data.onload = function () { r.revokeObjectURL(t.data), t.onProcessComplete(); }, this.data.onerror = function () { r.revokeObjectURL(t.data), t.onProcessError(); }, r.createObjectURL(this.data, this.xhrLoader.response, 'image/png'); },
    addToCache() { let t; const e = this.linkFile; e && e.state === s.FILE_COMPLETE ? (t = this.type === 'image' ? this.cache.addImage(this.key, this.data, e.data) : this.cache.addImage(e.key, e.data, this.data), this.pendingDestroy(t), e.pendingDestroy(t)) : e || (t = this.cache.addImage(this.key, this.data), this.pendingDestroy(t)); },
  }); o.register('image', function (t, e, i) { if (Array.isArray(t)) for (let n = 0; n < t.length; n++) this.addFile(new l(this, t[n])); else this.addFile(new l(this, t, e, i)); return this; }), t.exports = l;
}, function (t, e, i) {
  const n = i(0); const s = i(69); const r = i(278); const o = i(277); const a = i(54); const h = i(184); const l = new n({
    initialize(t, e, i, n, s, r) { void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), void 0 === s && (s = 0), void 0 === r && (r = 0), this.x1 = t, this.y1 = e, this.x2 = i, this.y2 = n, this.x3 = s, this.y3 = r; }, contains(t, e) { return s(this, t, e); }, getPoint(t, e) { return r(this, t, e); }, getPoints(t, e, i) { return o(this, t, e, i); }, getRandomPoint(t) { return h(this, t); }, setTo(t, e, i, n, s, r) { return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), void 0 === s && (s = 0), void 0 === r && (r = 0), this.x1 = t, this.y1 = e, this.x2 = i, this.y2 = n, this.x3 = s, this.y3 = r, this; }, getLineA(t) { return void 0 === t && (t = new a()), t.setTo(this.x1, this.y1, this.x2, this.y2), t; }, getLineB(t) { return void 0 === t && (t = new a()), t.setTo(this.x2, this.y2, this.x3, this.y3), t; }, getLineC(t) { return void 0 === t && (t = new a()), t.setTo(this.x3, this.y3, this.x1, this.y1), t; }, left: { get() { return Math.min(this.x1, this.x2, this.x3); }, set(t) { let e = 0; e = this.x1 <= this.x2 && this.x1 <= this.x3 ? this.x1 - t : this.x2 <= this.x1 && this.x2 <= this.x3 ? this.x2 - t : this.x3 - t, this.x1 -= e, this.x2 -= e, this.x3 -= e; } }, right: { get() { return Math.max(this.x1, this.x2, this.x3); }, set(t) { let e = 0; e = this.x1 >= this.x2 && this.x1 >= this.x3 ? this.x1 - t : this.x2 >= this.x1 && this.x2 >= this.x3 ? this.x2 - t : this.x3 - t, this.x1 -= e, this.x2 -= e, this.x3 -= e; } }, top: { get() { return Math.min(this.y1, this.y2, this.y3); }, set(t) { let e = 0; e = this.y1 <= this.y2 && this.y1 <= this.y3 ? this.y1 - t : this.y2 <= this.y1 && this.y2 <= this.y3 ? this.y2 - t : this.y3 - t, this.y1 -= e, this.y2 -= e, this.y3 -= e; } }, bottom: { get() { return Math.max(this.y1, this.y2, this.y3); }, set(t) { let e = 0; e = this.y1 >= this.y2 && this.y1 >= this.y3 ? this.y1 - t : this.y2 >= this.y1 && this.y2 >= this.y3 ? this.y2 - t : this.y3 - t, this.y1 -= e, this.y2 -= e, this.y3 -= e; } },
  }); t.exports = l;
}, function (t, e, i) { const n = i(10); t.exports = function (t, e, i, s, r) { const o = t.strokeTint; const a = n.getTintAppendFloatAlphaAndSwap(e.strokeColor, e.strokeAlpha * i); o.TL = a, o.TR = a, o.BL = a, o.BR = a; const h = e.pathData; let l = h.length - 1; const u = e.lineWidth; const c = u / 2; let d = h[0] - s; let f = h[1] - r; e.closePath || (l -= 2); for (let p = 2; p < l; p += 2) { const g = h[p] - s; const v = h[p + 1] - r; t.setTexture2D(), t.batchLine(d, f, g, v, c, c, u, p - 2, !!e.closePath && p === l - 1), d = g, f = v; } }; }, function (t, e, i) {
  const n = i(0); const s = i(14); const r = i(19); const o = i(829); const a = new n({
    Extends: r, Mixins: [s.Alpha, s.BlendMode, s.Depth, s.Flip, s.GetBounds, s.Mask, s.Origin, s.Pipeline, s.ScaleMode, s.ScrollFactor, s.Size, s.TextureCrop, s.Tint, s.Transform, s.Visible, o], initialize(t, e, i, n, o) { r.call(this, t, 'Sprite'), this._crop = this.resetCropObject(), this.anims = new s.Animation(this), this.setTexture(n, o), this.setPosition(e, i), this.setSizeToFrame(), this.setOriginFromFrame(), this.initPipeline(); }, preUpdate(t, e) { this.anims.update(t, e); }, play(t, e, i) { return this.anims.play(t, e, i), this; }, toJSON() { return s.ToJSON(this); }, preDestroy() { this.anims.destroy(), this.anims = void 0; },
  }); t.exports = a;
}, function (t, e) { t.exports = function (t, e, i, n) { const s = t.length; if (e < 0 || e > s || e >= i || i > s || e + i > s) { if (n) throw new Error('Range Error: Values outside acceptable range'); return !1; } return !0; }; }, function (t, e) { t.exports = function (t) { const e = {}; for (const i in t)Array.isArray(t[i]) ? e[i] = t[i].slice(0) : e[i] = t[i]; return e; }; }, function (t, e, i) {
  function n(t, e, i) { i = i || 2; let n; let a; let h; let l; let u; let f; let g; const v = e && e.length; const y = v ? e[0] * i : t.length; let m = s(t, 0, y, i, !0); const x = []; if (!m) return x; if (v && (m = (function (t, e, i, n) { let o; let a; let h; let l; let u; const f = []; for (o = 0, a = e.length; o < a; o++)h = e[o] * n, l = o < a - 1 ? e[o + 1] * n : t.length, (u = s(t, h, l, n, !1)) === u.next && (u.steiner = !0), f.push(p(u)); for (f.sort(c), o = 0; o < f.length; o++)d(f[o], i), i = r(i, i.next); return i; }(t, e, m, i))), t.length > 80 * i) { n = h = t[0], a = l = t[1]; for (let w = i; w < y; w += i)u = t[w], f = t[w + 1], u < n && (n = u), f < a && (a = f), u > h && (h = u), f > l && (l = f); g = Math.max(h - n, l - a); } return o(m, x, i, n, a, g), x; } function s(t, e, i, n, s) { let r; let o; if (s === A(t, e, i, n) > 0) for (r = e; r < i; r += n)o = T(r, t[r], t[r + 1], o); else for (r = i - n; r >= e; r -= n)o = T(r, t[r], t[r + 1], o); return o && m(o, o.next) && (S(o), o = o.next), o; } function r(t, e) { if (!t) return t; e || (e = t); let i; let n = t; do { if (i = !1, n.steiner || !m(n, n.next) && y(n.prev, n, n.next) !== 0)n = n.next; else { if (S(n), (n = e = n.prev) === n.next) return null; i = !0; } } while (i || n !== e);return e; } function o(t, e, i, n, s, c, d) { if (t) { !d && c && (function (t, e, i, n) { let s = t; do { s.z === null && (s.z = f(s.x, s.y, e, i, n)), s.prevZ = s.prev, s.nextZ = s.next, s = s.next; } while (s !== t);s.prevZ.nextZ = null, s.prevZ = null, (function (t) { let e; let i; let n; let s; let r; let o; let a; let h; let l = 1; do { for (i = t, t = null, r = null, o = 0; i;) { for (o++, n = i, a = 0, e = 0; e < l && (a++, n = n.nextZ); e++);for (h = l; a > 0 || h > 0 && n;)a !== 0 && (h === 0 || !n || i.z <= n.z) ? (s = i, i = i.nextZ, a--) : (s = n, n = n.nextZ, h--), r ? r.nextZ = s : t = s, s.prevZ = r, r = s; i = n; }r.nextZ = null, l *= 2; } while (o > 1); }(s)); }(t, n, s, c)); for (var p, g, v = t; t.prev !== t.next;) if (p = t.prev, g = t.next, c ? h(t, n, s, c) : a(t))e.push(p.i / i), e.push(t.i / i), e.push(g.i / i), S(t), t = g.next, v = g.next; else if ((t = g) === v) { d ? d === 1 ? o(t = l(t, e, i), e, i, n, s, c, 2) : d === 2 && u(t, e, i, n, s, c) : o(r(t), e, i, n, s, c, 1); break; } } } function a(t) { const e = t.prev; const i = t; const n = t.next; if (y(e, i, n) >= 0) return !1; for (let s = t.next.next; s !== t.prev;) { if (g(e.x, e.y, i.x, i.y, n.x, n.y, s.x, s.y) && y(s.prev, s, s.next) >= 0) return !1; s = s.next; } return !0; } function h(t, e, i, n) { const s = t.prev; const r = t; const o = t.next; if (y(s, r, o) >= 0) return !1; for (var a = s.x < r.x ? s.x < o.x ? s.x : o.x : r.x < o.x ? r.x : o.x, h = s.y < r.y ? s.y < o.y ? s.y : o.y : r.y < o.y ? r.y : o.y, l = s.x > r.x ? s.x > o.x ? s.x : o.x : r.x > o.x ? r.x : o.x, u = s.y > r.y ? s.y > o.y ? s.y : o.y : r.y > o.y ? r.y : o.y, c = f(a, h, e, i, n), d = f(l, u, e, i, n), p = t.nextZ; p && p.z <= d;) { if (p !== t.prev && p !== t.next && g(s.x, s.y, r.x, r.y, o.x, o.y, p.x, p.y) && y(p.prev, p, p.next) >= 0) return !1; p = p.nextZ; } for (p = t.prevZ; p && p.z >= c;) { if (p !== t.prev && p !== t.next && g(s.x, s.y, r.x, r.y, o.x, o.y, p.x, p.y) && y(p.prev, p, p.next) >= 0) return !1; p = p.prevZ; } return !0; } function l(t, e, i) { let n = t; do { const s = n.prev; const r = n.next.next; !m(s, r) && x(s, n, n.next, r) && w(s, r) && w(r, s) && (e.push(s.i / i), e.push(n.i / i), e.push(r.i / i), S(n), S(n.next), n = t = r), n = n.next; } while (n !== t);return n; } function u(t, e, i, n, s, a) { let h = t; do { for (let l = h.next.next; l !== h.prev;) { if (h.i !== l.i && v(h, l)) { let u = b(h, l); return h = r(h, h.next), u = r(u, u.next), o(h, e, i, n, s, a), void o(u, e, i, n, s, a); }l = l.next; }h = h.next; } while (h !== t); } function c(t, e) { return t.x - e.x; } function d(t, e) { if (e = (function (t, e) { let i; let n = e; const s = t.x; const r = t.y; let o = -1 / 0; do { if (r <= n.y && r >= n.next.y && n.next.y !== n.y) { const a = n.x + (r - n.y) * (n.next.x - n.x) / (n.next.y - n.y); if (a <= s && a > o) { if (o = a, a === s) { if (r === n.y) return n; if (r === n.next.y) return n.next; }i = n.x < n.next.x ? n : n.next; } }n = n.next; } while (n !== e);if (!i) return null; if (s === o) return i.prev; let h; const l = i; const u = i.x; const c = i.y; let d = 1 / 0; n = i.next; for (;n !== l;)s >= n.x && n.x >= u && s !== n.x && g(r < c ? s : o, r, u, c, r < c ? o : s, r, n.x, n.y) && ((h = Math.abs(r - n.y) / (s - n.x)) < d || h === d && n.x > i.x) && w(n, t) && (i = n, d = h), n = n.next; return i; }(t, e))) { const i = b(e, t); r(i, i.next); } } function f(t, e, i, n, s) { return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - i) / s) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - n) / s) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1; } function p(t) { let e = t; let i = t; do { e.x < i.x && (i = e), e = e.next; } while (e !== t);return i; } function g(t, e, i, n, s, r, o, a) { return (s - o) * (e - a) - (t - o) * (r - a) >= 0 && (t - o) * (n - a) - (i - o) * (e - a) >= 0 && (i - o) * (r - a) - (s - o) * (n - a) >= 0; } function v(t, e) { return t.next.i !== e.i && t.prev.i !== e.i && !(function (t, e) { let i = t; do { if (i.i !== t.i && i.next.i !== t.i && i.i !== e.i && i.next.i !== e.i && x(i, i.next, t, e)) return !0; i = i.next; } while (i !== t);return !1; }(t, e)) && w(t, e) && w(e, t) && (function (t, e) { let i = t; let n = !1; const s = (t.x + e.x) / 2; const r = (t.y + e.y) / 2; do { i.y > r != i.next.y > r && i.next.y !== i.y && s < (i.next.x - i.x) * (r - i.y) / (i.next.y - i.y) + i.x && (n = !n), i = i.next; } while (i !== t);return n; }(t, e)); } function y(t, e, i) { return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y); } function m(t, e) { return t.x === e.x && t.y === e.y; } function x(t, e, i, n) { return !!(m(t, e) && m(i, n) || m(t, n) && m(i, e)) || y(t, e, i) > 0 != y(t, e, n) > 0 && y(i, n, t) > 0 != y(i, n, e) > 0; } function w(t, e) { return y(t.prev, t, t.next) < 0 ? y(t, e, t.next) >= 0 && y(t, t.prev, e) >= 0 : y(t, e, t.prev) < 0 || y(t, t.next, e) < 0; } function b(t, e) { const i = new _(t.i, t.x, t.y); const n = new _(e.i, e.x, e.y); const s = t.next; const r = e.prev; return t.next = e, e.prev = t, i.next = s, s.prev = i, n.next = i, i.prev = n, r.next = n, n.prev = r, n; } function T(t, e, i, n) { const s = new _(t, e, i); return n ? (s.next = n.next, s.prev = n, n.next.prev = s, n.next = s) : (s.prev = s, s.next = s), s; } function S(t) { t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ); } function _(t, e, i) { this.i = t, this.x = e, this.y = i, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1; } function A(t, e, i, n) { for (var s = 0, r = e, o = i - n; r < i; r += n)s += (t[o] - t[r]) * (t[r + 1] + t[o + 1]), o = r; return s; }t.exports = n, n.deviation = function (t, e, i, n) { const s = e && e.length; const r = s ? e[0] * i : t.length; let o = Math.abs(A(t, 0, r, i)); if (s) for (var a = 0, h = e.length; a < h; a++) { const l = e[a] * i; const u = a < h - 1 ? e[a + 1] * i : t.length; o -= Math.abs(A(t, l, u, i)); } let c = 0; for (a = 0; a < n.length; a += 3) { const d = n[a] * i; const f = n[a + 1] * i; const p = n[a + 2] * i; c += Math.abs((t[d] - t[p]) * (t[f + 1] - t[d + 1]) - (t[d] - t[f]) * (t[p + 1] - t[d + 1])); } return o === 0 && c === 0 ? 0 : Math.abs((c - o) / o); }, n.flatten = function (t) { for (var e = t[0][0].length, i = { vertices: [], holes: [], dimensions: e }, n = 0, s = 0; s < t.length; s++) { for (let r = 0; r < t[s].length; r++) for (let o = 0; o < e; o++)i.vertices.push(t[s][r][o]); s > 0 && (n += t[s - 1].length, i.holes.push(n)); } return i; };
}, function (t, e) { t.exports = function (t) { return Math.sqrt((t.x2 - t.x1) * (t.x2 - t.x1) + (t.y2 - t.y1) * (t.y2 - t.y1)); }; }, function (t, e) {
  t.exports = {
    SKIP_CHECK: -1, NORMAL: 0, ADD: 1, MULTIPLY: 2, SCREEN: 3, OVERLAY: 4, DARKEN: 5, LIGHTEN: 6, COLOR_DODGE: 7, COLOR_BURN: 8, HARD_LIGHT: 9, SOFT_LIGHT: 10, DIFFERENCE: 11, EXCLUSION: 12, HUE: 13, SATURATION: 14, COLOR: 15, LUMINOSITY: 16,
  };
}, function (t, e, i) {
  const n = {}; t.exports = n; const s = i(76); const r = i(81); const o = i(222); const a = i(33); const h = i(80); const l = i(505); !(function () {
    n._inertiaScale = 4, n._nextCollidingGroupId = 1, n._nextNonCollidingGroupId = -1, n._nextCategory = 1, n.create = function (e) {
      const i = {
        id: a.nextId(),
        type: 'body',
        label: 'Body',
        gameObject: null,
        parts: [],
        plugin: {},
        angle: 0,
        vertices: s.fromPath('L 0 0 L 40 0 L 40 40 L 0 40'),
        position: { x: 0, y: 0 },
        force: { x: 0, y: 0 },
        torque: 0,
        positionImpulse: { x: 0, y: 0 },
        previousPositionImpulse: { x: 0, y: 0 },
        constraintImpulse: { x: 0, y: 0, angle: 0 },
        totalContacts: 0,
        speed: 0,
        angularSpeed: 0,
        velocity: { x: 0, y: 0 },
        angularVelocity: 0,
        isSensor: !1,
        isStatic: !1,
        isSleeping: !1,
        ignoreGravity: !1,
        ignorePointer: !1,
        motion: 0,
        sleepThreshold: 60,
        density: 0.001,
        restitution: 0,
        friction: 0.1,
        frictionStatic: 0.5,
        frictionAir: 0.01,
        collisionFilter: { category: 1, mask: 4294967295, group: 0 },
        slop: 0.05,
        timeScale: 1,
        render: {
          visible: !0,
          opacity: 1,
          sprite: {
            xScale: 1, yScale: 1, xOffset: 0, yOffset: 0,
          },
          lineWidth: 0,
        },
        events: null,
        bounds: null,
        chamfer: null,
        circleRadius: 0,
        positionPrev: null,
        anglePrev: 0,
        parent: null,
        axes: null,
        area: 0,
        mass: 0,
        inertia: 0,
        _original: null,
      }; const n = a.extend(i, e); return t(n, e), n;
    }, n.nextGroup = function (t) { return t ? n._nextNonCollidingGroupId-- : n._nextCollidingGroupId++; }, n.nextCategory = function () { return n._nextCategory <<= 1, n._nextCategory; }; var t = function (t, e) {
      e = e || {}, n.set(t, {
        bounds: t.bounds || h.create(t.vertices), positionPrev: t.positionPrev || r.clone(t.position), anglePrev: t.anglePrev || t.angle, vertices: t.vertices, parts: t.parts || [t], isStatic: t.isStatic, isSleeping: t.isSleeping, parent: t.parent || t,
      }), s.rotate(t.vertices, t.angle, t.position), l.rotate(t.axes, t.angle), h.update(t.bounds, t.vertices, t.velocity), n.set(t, {
        axes: e.axes || t.axes, area: e.area || t.area, mass: e.mass || t.mass, inertia: e.inertia || t.inertia,
      }); const i = t.isStatic ? '#2e2b44' : a.choose(['#006BA6', '#0496FF', '#FFBC42', '#D81159', '#8F2D56']); t.render.fillStyle = t.render.fillStyle || i, t.render.strokeStyle = t.render.strokeStyle || '#000', t.render.sprite.xOffset += -(t.bounds.min.x - t.position.x) / (t.bounds.max.x - t.bounds.min.x), t.render.sprite.yOffset += -(t.bounds.min.y - t.position.y) / (t.bounds.max.y - t.bounds.min.y);
    }; n.set = function (t, e, i) { let s; for (s in typeof e === 'string' && (s = e, (e = {})[s] = i), e) if (e.hasOwnProperty(s)) switch (i = e[s], s) { case 'isStatic': n.setStatic(t, i); break; case 'isSleeping': o.set(t, i); break; case 'mass': n.setMass(t, i); break; case 'density': n.setDensity(t, i); break; case 'inertia': n.setInertia(t, i); break; case 'vertices': n.setVertices(t, i); break; case 'position': n.setPosition(t, i); break; case 'angle': n.setAngle(t, i); break; case 'velocity': n.setVelocity(t, i); break; case 'angularVelocity': n.setAngularVelocity(t, i); break; case 'parts': n.setParts(t, i); break; default: t[s] = i; } }, n.setStatic = function (t, e) {
      for (let i = 0; i < t.parts.length; i++) {
        const n = t.parts[i]; n.isStatic = e, e ? (n._original = {
          restitution: n.restitution, friction: n.friction, mass: n.mass, inertia: n.inertia, density: n.density, inverseMass: n.inverseMass, inverseInertia: n.inverseInertia,
        }, n.restitution = 0, n.friction = 1, n.mass = n.inertia = n.density = 1 / 0, n.inverseMass = n.inverseInertia = 0, n.positionPrev.x = n.position.x, n.positionPrev.y = n.position.y, n.anglePrev = n.angle, n.angularVelocity = 0, n.speed = 0, n.angularSpeed = 0, n.motion = 0) : n._original && (n.restitution = n._original.restitution, n.friction = n._original.friction, n.mass = n._original.mass, n.inertia = n._original.inertia, n.density = n._original.density, n.inverseMass = n._original.inverseMass, n.inverseInertia = n._original.inverseInertia, n._original = null);
      }
    }, n.setMass = function (t, e) { const i = t.inertia / (t.mass / 6); t.inertia = i * (e / 6), t.inverseInertia = 1 / t.inertia, t.mass = e, t.inverseMass = 1 / t.mass, t.density = t.mass / t.area; }, n.setDensity = function (t, e) { n.setMass(t, e * t.area), t.density = e; }, n.setInertia = function (t, e) { t.inertia = e, t.inverseInertia = 1 / t.inertia; }, n.setVertices = function (t, e) { e[0].body === t ? t.vertices = e : t.vertices = s.create(e, t), t.axes = l.fromVertices(t.vertices), t.area = s.area(t.vertices), n.setMass(t, t.density * t.area); const i = s.centre(t.vertices); s.translate(t.vertices, i, -1), n.setInertia(t, n._inertiaScale * s.inertia(t.vertices, t.mass)), s.translate(t.vertices, t.position), h.update(t.bounds, t.vertices, t.velocity); }, n.setParts = function (t, e, i) { let r; for (e = e.slice(0), t.parts.length = 0, t.parts.push(t), t.parent = t, r = 0; r < e.length; r++) { const o = e[r]; o !== t && (o.parent = t, t.parts.push(o)); } if (t.parts.length !== 1) { if (i = void 0 === i || i) { let a = []; for (r = 0; r < e.length; r++)a = a.concat(e[r].vertices); s.clockwiseSort(a); const h = s.hull(a); const l = s.centre(h); n.setVertices(t, h), s.translate(t.vertices, l); } const u = n._totalProperties(t); t.area = u.area, t.parent = t, t.position.x = u.centre.x, t.position.y = u.centre.y, t.positionPrev.x = u.centre.x, t.positionPrev.y = u.centre.y, n.setMass(t, u.mass), n.setInertia(t, u.inertia), n.setPosition(t, u.centre); } }, n.setPosition = function (t, e) { const i = r.sub(e, t.position); t.positionPrev.x += i.x, t.positionPrev.y += i.y; for (let n = 0; n < t.parts.length; n++) { const o = t.parts[n]; o.position.x += i.x, o.position.y += i.y, s.translate(o.vertices, i), h.update(o.bounds, o.vertices, t.velocity); } }, n.setAngle = function (t, e) { const i = e - t.angle; t.anglePrev += i; for (let n = 0; n < t.parts.length; n++) { const o = t.parts[n]; o.angle += i, s.rotate(o.vertices, i, t.position), l.rotate(o.axes, i), h.update(o.bounds, o.vertices, t.velocity), n > 0 && r.rotateAbout(o.position, i, t.position, o.position); } }, n.setVelocity = function (t, e) { t.positionPrev.x = t.position.x - e.x, t.positionPrev.y = t.position.y - e.y, t.velocity.x = e.x, t.velocity.y = e.y, t.speed = r.magnitude(t.velocity); }, n.setAngularVelocity = function (t, e) { t.anglePrev = t.angle - e, t.angularVelocity = e, t.angularSpeed = Math.abs(t.angularVelocity); }, n.translate = function (t, e) { n.setPosition(t, r.add(t.position, e)); }, n.rotate = function (t, e, i) { if (i) { const s = Math.cos(e); const r = Math.sin(e); const o = t.position.x - i.x; const a = t.position.y - i.y; n.setPosition(t, { x: i.x + (o * s - a * r), y: i.y + (o * r + a * s) }), n.setAngle(t, t.angle + e); } else n.setAngle(t, t.angle + e); }, n.scale = function (t, e, i, r) { let o = 0; let a = 0; r = r || t.position; for (let u = 0; u < t.parts.length; u++) { const c = t.parts[u]; s.scale(c.vertices, e, i, r), c.axes = l.fromVertices(c.vertices), c.area = s.area(c.vertices), n.setMass(c, t.density * c.area), s.translate(c.vertices, { x: -c.position.x, y: -c.position.y }), n.setInertia(c, n._inertiaScale * s.inertia(c.vertices, c.mass)), s.translate(c.vertices, { x: c.position.x, y: c.position.y }), u > 0 && (o += c.area, a += c.inertia), c.position.x = r.x + (c.position.x - r.x) * e, c.position.y = r.y + (c.position.y - r.y) * i, h.update(c.bounds, c.vertices, t.velocity); }t.parts.length > 1 && (t.area = o, t.isStatic || (n.setMass(t, t.density * o), n.setInertia(t, a))), t.circleRadius && (e === i ? t.circleRadius *= e : t.circleRadius = null); }, n.update = function (t, e, i, n) { const o = Math.pow(e * i * t.timeScale, 2); const a = 1 - t.frictionAir * i * t.timeScale; const u = t.position.x - t.positionPrev.x; const c = t.position.y - t.positionPrev.y; t.velocity.x = u * a * n + t.force.x / t.mass * o, t.velocity.y = c * a * n + t.force.y / t.mass * o, t.positionPrev.x = t.position.x, t.positionPrev.y = t.position.y, t.position.x += t.velocity.x, t.position.y += t.velocity.y, t.angularVelocity = (t.angle - t.anglePrev) * a * n + t.torque / t.inertia * o, t.anglePrev = t.angle, t.angle += t.angularVelocity, t.speed = r.magnitude(t.velocity), t.angularSpeed = Math.abs(t.angularVelocity); for (let d = 0; d < t.parts.length; d++) { const f = t.parts[d]; s.translate(f.vertices, t.velocity), d > 0 && (f.position.x += t.velocity.x, f.position.y += t.velocity.y), t.angularVelocity !== 0 && (s.rotate(f.vertices, t.angularVelocity, t.position), l.rotate(f.axes, t.angularVelocity), d > 0 && r.rotateAbout(f.position, t.angularVelocity, t.position, f.position)), h.update(f.bounds, f.vertices, t.velocity); } }, n.applyForce = function (t, e, i) { t.force.x += i.x, t.force.y += i.y; const n = e.x - t.position.x; const s = e.y - t.position.y; t.torque += n * i.y - s * i.x; }, n._totalProperties = function (t) {
      for (var e = {
          mass: 0, area: 0, inertia: 0, centre: { x: 0, y: 0 },
        }, i = t.parts.length === 1 ? 0 : 1; i < t.parts.length; i++) { const n = t.parts[i]; const s = n.mass !== 1 / 0 ? n.mass : 1; e.mass += s, e.area += n.area, e.inertia += n.inertia, e.centre = r.add(e.centre, r.mult(n.position, s)); } return e.centre = r.div(e.centre, e.mass), e;
    };
  }());
}, function (t, e) { t.exports = function (t) { return Math.atan2(t.y2 - t.y1, t.x2 - t.x1); }; }, function (t, e) { t.exports = function (t, e, i) { const n = t.x3 - t.x1; const s = t.y3 - t.y1; const r = t.x2 - t.x1; const o = t.y2 - t.y1; const a = e - t.x1; const h = i - t.y1; const l = n * n + s * s; const u = n * r + s * o; const c = n * a + s * h; const d = r * r + o * o; const f = r * a + o * h; const p = l * d - u * u; const g = p === 0 ? 0 : 1 / p; const v = (d * c - u * f) * g; const y = (l * f - u * c) * g; return v >= 0 && y >= 0 && v + y < 1; }; }, function (t, e, i) {
  const n = i(0); const s = i(173); const r = i(9); const o = i(3); const a = new n({
    initialize(t) { this.type = t, this.defaultDivisions = 5, this.arcLengthDivisions = 100, this.cacheArcLengths = [], this.needsUpdate = !0, this.active = !0, this._tmpVec2A = new o(), this._tmpVec2B = new o(); }, draw(t, e) { return void 0 === e && (e = 32), t.strokePoints(this.getPoints(e)); }, getBounds(t, e) { t || (t = new r()), void 0 === e && (e = 16); const i = this.getLength(); e > i && (e = i / 2); const n = Math.max(1, Math.round(i / e)); return s(this.getSpacedPoints(n), t); }, getDistancePoints(t) { const e = this.getLength(); const i = Math.max(1, e / t); return this.getSpacedPoints(i); }, getEndPoint(t) { return void 0 === t && (t = new o()), this.getPointAt(1, t); }, getLength() { const t = this.getLengths(); return t[t.length - 1]; }, getLengths(t) { if (void 0 === t && (t = this.arcLengthDivisions), this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths; this.needsUpdate = !1; let e; const i = []; const n = this.getPoint(0, this._tmpVec2A); let s = 0; i.push(0); for (let r = 1; r <= t; r++)s += (e = this.getPoint(r / t, this._tmpVec2B)).distance(n), i.push(s), n.copy(e); return this.cacheArcLengths = i, i; }, getPointAt(t, e) { const i = this.getUtoTmapping(t); return this.getPoint(i, e); }, getPoints(t) { void 0 === t && (t = this.defaultDivisions); for (var e = [], i = 0; i <= t; i++)e.push(this.getPoint(i / t)); return e; }, getRandomPoint(t) { return void 0 === t && (t = new o()), this.getPoint(Math.random(), t); }, getSpacedPoints(t) { void 0 === t && (t = this.defaultDivisions); for (var e = [], i = 0; i <= t; i++) { const n = this.getUtoTmapping(i / t, null, t); e.push(this.getPoint(n)); } return e; }, getStartPoint(t) { return void 0 === t && (t = new o()), this.getPointAt(0, t); }, getTangent(t, e) { void 0 === e && (e = new o()); let i = t - 1e-4; let n = t + 1e-4; return i < 0 && (i = 0), n > 1 && (n = 1), this.getPoint(i, this._tmpVec2A), this.getPoint(n, e), e.subtract(this._tmpVec2A).normalize(); }, getTangentAt(t, e) { const i = this.getUtoTmapping(t); return this.getTangent(i, e); }, getTFromDistance(t, e) { return t <= 0 ? 0 : this.getUtoTmapping(0, t, e); }, getUtoTmapping(t, e, i) { let n; const s = this.getLengths(i); let r = 0; const o = s.length; n = e ? Math.min(e, s[o - 1]) : t * s[o - 1]; for (var a, h = 0, l = o - 1; h <= l;) if ((a = s[r = Math.floor(h + (l - h) / 2)] - n) < 0)h = r + 1; else { if (!(a > 0)) { l = r; break; }l = r - 1; } if (s[r = l] === n) return r / (o - 1); const u = s[r]; return (r + (n - u) / (s[r + 1] - u)) / (o - 1); }, updateArcLengths() { this.needsUpdate = !0, this.getLengths(); },
  }); t.exports = a;
}, function (t, e, i) {
  const n = i(0); const s = i(40); const r = i(405); const o = i(403); const a = i(191); const h = new n({
    initialize(t, e, i) { void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), this.x = t, this.y = e, this._radius = i, this._diameter = 2 * i; }, contains(t, e) { return s(this, t, e); }, getPoint(t, e) { return r(this, t, e); }, getPoints(t, e, i) { return o(this, t, e, i); }, getRandomPoint(t) { return a(this, t); }, setTo(t, e, i) { return this.x = t, this.y = e, this._radius = i, this._diameter = 2 * i, this; }, setEmpty() { return this._radius = 0, this._diameter = 0, this; }, setPosition(t, e) { return void 0 === e && (e = t), this.x = t, this.y = e, this; }, isEmpty() { return this._radius <= 0; }, radius: { get() { return this._radius; }, set(t) { this._radius = t, this._diameter = 2 * t; } }, diameter: { get() { return this._diameter; }, set(t) { this._diameter = t, this._radius = 0.5 * t; } }, left: { get() { return this.x - this._radius; }, set(t) { this.x = t + this._radius; } }, right: { get() { return this.x + this._radius; }, set(t) { this.x = t - this._radius; } }, top: { get() { return this.y - this._radius; }, set(t) { this.y = t + this._radius; } }, bottom: { get() { return this.y + this._radius; }, set(t) { this.y = t - this._radius; } },
  }); t.exports = h;
}, function (t, e) { t.exports = function (t) { return t.y - t.height * t.originY + 0.5 * t.height; }; }, function (t, e) { t.exports = function (t, e) { const i = t.height * t.originY; return t.y = e + i - 0.5 * t.height, t; }; }, function (t, e) { t.exports = function (t, e) { const i = t.width * t.originX; return t.x = e + i - 0.5 * t.width, t; }; }, function (t, e) { t.exports = function (t) { return t.x - t.width * t.originX + 0.5 * t.width; }; }, function (t, e, i) {
  const n = {}; t.exports = n; const s = i(81); const r = i(33); n.create = function (t, e) {
    for (var i = [], n = 0; n < t.length; n++) {
      const s = t[n]; const r = {
        x: s.x, y: s.y, index: n, body: e, isInternal: !1, contact: null,
      }; r.contact = { vertex: r, normalImpulse: 0, tangentImpulse: 0 }, i.push(r);
    } return i;
  }, n.fromPath = function (t, e) { const i = []; return t.replace(/L?\s*([\-\d\.e]+)[\s,]*([\-\d\.e]+)*/gi, (t, e, n) => { i.push({ x: parseFloat(e), y: parseFloat(n) }); }), n.create(i, e); }, n.centre = function (t) { for (var e, i, r, o = n.area(t, !0), a = { x: 0, y: 0 }, h = 0; h < t.length; h++)r = (h + 1) % t.length, e = s.cross(t[h], t[r]), i = s.mult(s.add(t[h], t[r]), e), a = s.add(a, i); return s.div(a, 6 * o); }, n.mean = function (t) { for (var e = { x: 0, y: 0 }, i = 0; i < t.length; i++)e.x += t[i].x, e.y += t[i].y; return s.div(e, t.length); }, n.area = function (t, e) { for (var i = 0, n = t.length - 1, s = 0; s < t.length; s++)i += (t[n].x - t[s].x) * (t[n].y + t[s].y), n = s; return e ? i / 2 : Math.abs(i) / 2; }, n.inertia = function (t, e) { for (var i, n, r = 0, o = 0, a = t, h = 0; h < a.length; h++)n = (h + 1) % a.length, r += (i = Math.abs(s.cross(a[n], a[h]))) * (s.dot(a[n], a[n]) + s.dot(a[n], a[h]) + s.dot(a[h], a[h])), o += i; return e / 6 * (r / o); }, n.translate = function (t, e, i) { let n; if (i) for (n = 0; n < t.length; n++)t[n].x += e.x * i, t[n].y += e.y * i; else for (n = 0; n < t.length; n++)t[n].x += e.x, t[n].y += e.y; return t; }, n.rotate = function (t, e, i) { if (e !== 0) { for (let n = Math.cos(e), s = Math.sin(e), r = 0; r < t.length; r++) { const o = t[r]; const a = o.x - i.x; const h = o.y - i.y; o.x = i.x + (a * n - h * s), o.y = i.y + (a * s + h * n); } return t; } }, n.contains = function (t, e) { for (let i = 0; i < t.length; i++) { const n = t[i]; const s = t[(i + 1) % t.length]; if ((e.x - n.x) * (s.y - n.y) + (e.y - n.y) * (n.x - s.x) > 0) return !1; } return !0; }, n.scale = function (t, e, i, r) { if (e === 1 && i === 1) return t; let o; let a; r = r || n.centre(t); for (let h = 0; h < t.length; h++)o = t[h], a = s.sub(o, r), t[h].x = r.x + a.x * e, t[h].y = r.y + a.y * i; return t; }, n.chamfer = function (t, e, i, n, o) { e = typeof e === 'number' ? [e] : e || [8], i = void 0 !== i ? i : -1, n = n || 2, o = o || 14; for (var a = [], h = 0; h < t.length; h++) { const l = t[h - 1 >= 0 ? h - 1 : t.length - 1]; const u = t[h]; const c = t[(h + 1) % t.length]; const d = e[h < e.length ? h : e.length - 1]; if (d !== 0) { const f = s.normalise({ x: u.y - l.y, y: l.x - u.x }); const p = s.normalise({ x: c.y - u.y, y: u.x - c.x }); const g = Math.sqrt(2 * Math.pow(d, 2)); const v = s.mult(r.clone(f), d); const y = s.normalise(s.mult(s.add(f, p), 0.5)); const m = s.sub(u, s.mult(y, g)); let x = i; i === -1 && (x = 1.75 * Math.pow(d, 0.32)), (x = r.clamp(x, n, o)) % 2 == 1 && (x += 1); for (let w = Math.acos(s.dot(f, p)) / x, b = 0; b < x; b++)a.push(s.add(s.rotate(v, w * b), m)); } else a.push(u); } return a; }, n.clockwiseSort = function (t) { const e = n.mean(t); return t.sort((t, i) => s.angle(e, t) - s.angle(e, i)), t; }, n.isConvex = function (t) { let e; let i; let n; let s; let r = 0; const o = t.length; if (o < 3) return null; for (e = 0; e < o; e++) if (n = (e + 2) % o, s = (t[i = (e + 1) % o].x - t[e].x) * (t[n].y - t[i].y), (s -= (t[i].y - t[e].y) * (t[n].x - t[i].x)) < 0 ? r |= 1 : s > 0 && (r |= 2), r === 3) return !1; return r !== 0 || null; }, n.hull = function (t) { let e; let i; const n = []; const r = []; for ((t = t.slice(0)).sort((t, e) => { const i = t.x - e.x; return i !== 0 ? i : t.y - e.y; }), i = 0; i < t.length; i += 1) { for (e = t[i]; r.length >= 2 && s.cross3(r[r.length - 2], r[r.length - 1], e) <= 0;)r.pop(); r.push(e); } for (i = t.length - 1; i >= 0; i -= 1) { for (e = t[i]; n.length >= 2 && s.cross3(n[n.length - 2], n[n.length - 1], e) <= 0;)n.pop(); n.push(e); } return n.pop(), r.pop(), n.concat(r); };
}, function (t, e, i) { const n = i(0); const s = i(2); const r = new n({ initialize(t) { void 0 === t && (t = {}), this.name = s(t, 'name', 'map'), this.width = s(t, 'width', 0), this.height = s(t, 'height', 0), this.tileWidth = s(t, 'tileWidth', 0), this.tileHeight = s(t, 'tileHeight', 0), this.widthInPixels = s(t, 'widthInPixels', this.width * this.tileWidth), this.heightInPixels = s(t, 'heightInPixels', this.height * this.tileHeight), this.format = s(t, 'format', null), this.orientation = s(t, 'orientation', 'orthogonal'), this.renderOrder = s(t, 'renderOrder', 'right-down'), this.version = s(t, 'version', '1'), this.properties = s(t, 'properties', {}), this.layers = s(t, 'layers', []), this.images = s(t, 'images', []), this.objects = s(t, 'objects', {}), this.collision = s(t, 'collision', {}), this.tilesets = s(t, 'tilesets', []), this.imageCollections = s(t, 'imageCollections', []), this.tiles = s(t, 'tiles', []); } }); t.exports = r; }, function (t, e, i) { const n = i(0); const s = i(2); const r = new n({ initialize(t) { void 0 === t && (t = {}), this.name = s(t, 'name', 'layer'), this.x = s(t, 'x', 0), this.y = s(t, 'y', 0), this.width = s(t, 'width', 0), this.height = s(t, 'height', 0), this.tileWidth = s(t, 'tileWidth', 0), this.tileHeight = s(t, 'tileHeight', 0), this.baseTileWidth = s(t, 'baseTileWidth', this.tileWidth), this.baseTileHeight = s(t, 'baseTileHeight', this.tileHeight), this.widthInPixels = s(t, 'widthInPixels', this.width * this.baseTileWidth), this.heightInPixels = s(t, 'heightInPixels', this.height * this.baseTileHeight), this.alpha = s(t, 'alpha', 1), this.visible = s(t, 'visible', !0), this.properties = s(t, 'properties', {}), this.indexes = s(t, 'indexes', []), this.collideIndexes = s(t, 'collideIndexes', []), this.callbacks = s(t, 'callbacks', []), this.bodies = s(t, 'bodies', []), this.data = s(t, 'data', []), this.tilemapLayer = s(t, 'tilemapLayer', null); } }); t.exports = r; }, function (t, e) { t.exports = function (t, e, i) { return t >= 0 && t < i.width && e >= 0 && e < i.height; }; }, function (t, e) { const i = {}; t.exports = i, i.create = function (t) { const e = { min: { x: 0, y: 0 }, max: { x: 0, y: 0 } }; return t && i.update(e, t), e; }, i.update = function (t, e, i) { t.min.x = 1 / 0, t.max.x = -1 / 0, t.min.y = 1 / 0, t.max.y = -1 / 0; for (let n = 0; n < e.length; n++) { const s = e[n]; s.x > t.max.x && (t.max.x = s.x), s.x < t.min.x && (t.min.x = s.x), s.y > t.max.y && (t.max.y = s.y), s.y < t.min.y && (t.min.y = s.y); }i && (i.x > 0 ? t.max.x += i.x : t.min.x += i.x, i.y > 0 ? t.max.y += i.y : t.min.y += i.y); }, i.contains = function (t, e) { return e.x >= t.min.x && e.x <= t.max.x && e.y >= t.min.y && e.y <= t.max.y; }, i.overlaps = function (t, e) { return t.min.x <= e.max.x && t.max.x >= e.min.x && t.max.y >= e.min.y && t.min.y <= e.max.y; }, i.translate = function (t, e) { t.min.x += e.x, t.max.x += e.x, t.min.y += e.y, t.max.y += e.y; }, i.shift = function (t, e) { const i = t.max.x - t.min.x; const n = t.max.y - t.min.y; t.min.x = e.x, t.max.x = e.x + i, t.min.y = e.y, t.max.y = e.y + n; }; }, function (t, e) { const i = {}; t.exports = i, i.create = function (t, e) { return { x: t || 0, y: e || 0 }; }, i.clone = function (t) { return { x: t.x, y: t.y }; }, i.magnitude = function (t) { return Math.sqrt(t.x * t.x + t.y * t.y); }, i.magnitudeSquared = function (t) { return t.x * t.x + t.y * t.y; }, i.rotate = function (t, e, i) { const n = Math.cos(e); const s = Math.sin(e); i || (i = {}); const r = t.x * n - t.y * s; return i.y = t.x * s + t.y * n, i.x = r, i; }, i.rotateAbout = function (t, e, i, n) { const s = Math.cos(e); const r = Math.sin(e); n || (n = {}); const o = i.x + ((t.x - i.x) * s - (t.y - i.y) * r); return n.y = i.y + ((t.x - i.x) * r + (t.y - i.y) * s), n.x = o, n; }, i.normalise = function (t) { const e = i.magnitude(t); return e === 0 ? { x: 0, y: 0 } : { x: t.x / e, y: t.y / e }; }, i.dot = function (t, e) { return t.x * e.x + t.y * e.y; }, i.cross = function (t, e) { return t.x * e.y - t.y * e.x; }, i.cross3 = function (t, e, i) { return (e.x - t.x) * (i.y - t.y) - (e.y - t.y) * (i.x - t.x); }, i.add = function (t, e, i) { return i || (i = {}), i.x = t.x + e.x, i.y = t.y + e.y, i; }, i.sub = function (t, e, i) { return i || (i = {}), i.x = t.x - e.x, i.y = t.y - e.y, i; }, i.mult = function (t, e) { return { x: t.x * e, y: t.y * e }; }, i.div = function (t, e) { return { x: t.x / e, y: t.y / e }; }, i.perp = function (t, e) { return { x: (e = !0 === e ? -1 : 1) * -t.y, y: e * t.x }; }, i.neg = function (t) { return { x: -t.x, y: -t.y }; }, i.angle = function (t, e) { return Math.atan2(e.y - t.y, e.x - t.x); }, i._temp = [i.create(), i.create(), i.create(), i.create(), i.create(), i.create()]; }, function (t, e, i) { const n = i(10); t.exports = function (t, e, i, s, r, o) { for (let a = n.getTintAppendFloatAlphaAndSwap(i.fillColor, i.fillAlpha * s), h = i.pathData, l = i.pathIndexes, u = 0; u < l.length; u += 3) { const c = 2 * l[u]; const d = 2 * l[u + 1]; const f = 2 * l[u + 2]; const p = h[c + 0] - r; const g = h[c + 1] - o; const v = h[d + 0] - r; const y = h[d + 1] - o; const m = h[f + 0] - r; const x = h[f + 1] - o; const w = e.getX(p, g); const b = e.getY(p, g); const T = e.getX(v, y); const S = e.getY(v, y); const _ = e.getX(m, x); const A = e.getY(m, x); t.setTexture2D(), t.batchTri(w, b, T, S, _, A, 0, 0, 1, 1, a, a, a, t.tintEffect); } }; }, function (t, e) {
  t.exports = {
    CREATED: 0, INIT: 1, DELAY: 2, OFFSET_DELAY: 3, PENDING_RENDER: 4, PLAYING_FORWARD: 5, PLAYING_BACKWARD: 6, HOLD_DELAY: 7, REPEAT_DELAY: 8, COMPLETE: 9, PENDING_ADD: 20, PAUSED: 21, LOOP_DELAY: 22, ACTIVE: 23, COMPLETE_DELAY: 24, PENDING_REMOVE: 25, REMOVED: 26,
  };
}, function (t, e) { t.exports = function (t, e, i) { return t && t.hasOwnProperty(e) ? t[e] : i; }; }, function (t, e) { t.exports = function (t, e) { return t.hasOwnProperty(e); }; }, function (t, e, i) { const n = i(174); t.exports = function (t, e) { if (typeof t === 'string' && n.hasOwnProperty(t)) { if (e) { const i = e.slice(0); return i.unshift(0), function (e) { return i[0] = e, n[t].apply(this, i); }; } return n[t]; } return typeof t === 'function' ? t : (Array.isArray(t) && t.length, n.Power0); }; }, function (t, e, i) { const n = i(0); const s = i(14); const r = i(19); const o = i(826); const a = new n({ Extends: r, Mixins: [s.Alpha, s.BlendMode, s.Depth, s.Flip, s.GetBounds, s.Mask, s.Origin, s.Pipeline, s.ScaleMode, s.ScrollFactor, s.Size, s.TextureCrop, s.Tint, s.Transform, s.Visible, o], initialize(t, e, i, n, s) { r.call(this, t, 'Image'), this._crop = this.resetCropObject(), this.setTexture(n, s), this.setPosition(e, i), this.setSizeToFrame(), this.setOriginFromFrame(), this.initPipeline(); } }); t.exports = a; }, function (t, e, i) {
  const n = i(417); const s = i(0); const r = i(2); const o = i(4); const a = i(8); const h = i(312); const l = i(95); const u = i(61); const c = new s({
    initialize(t, e, i) { i ? e && !Array.isArray(e) && (e = [e]) : Array.isArray(e) ? a(e[0]) && (i = e, e = null) : a(e) && (i = e, e = null), this.scene = t, this.children = new l(e), this.isParent = !0, this.classType = r(i, 'classType', u), this.active = r(i, 'active', !0), this.maxSize = r(i, 'maxSize', -1), this.defaultKey = r(i, 'defaultKey', null), this.defaultFrame = r(i, 'defaultFrame', null), this.runChildUpdate = r(i, 'runChildUpdate', !1), this.createCallback = r(i, 'createCallback', null), this.removeCallback = r(i, 'removeCallback', null), this.createMultipleCallback = r(i, 'createMultipleCallback', null), i && this.createMultiple(i); },
    create(t, e, i, n, s, r) { if (void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = this.defaultKey), void 0 === n && (n = this.defaultFrame), void 0 === s && (s = !0), void 0 === r && (r = !0), this.isFull()) return null; const o = new this.classType(this.scene, t, e, i, n); return this.scene.sys.displayList.add(o), o.preUpdate && this.scene.sys.updateList.add(o), o.visible = s, o.setActive(r), this.add(o), o; },
    createMultiple(t) { if (this.isFull()) return []; Array.isArray(t) || (t = [t]); let e = []; if (t[0].key) for (let i = 0; i < t.length; i++) { const n = this.createFromConfig(t[i]); e = e.concat(n); } return e; },
    createFromConfig(t) {
      if (this.isFull()) return []; this.classType = r(t, 'classType', this.classType); let e = r(t, 'key', void 0); let i = r(t, 'frame', null); const s = r(t, 'visible', !0); const a = r(t, 'active', !0); const l = []; if (void 0 === e) return l; Array.isArray(e) || (e = [e]), Array.isArray(i) || (i = [i]); for (let u = r(t, 'repeat', 0), c = r(t, 'randomKey', !1), d = r(t, 'randomFrame', !1), f = r(t, 'yoyo', !1), p = r(t, 'frameQuantity', 1), g = r(t, 'max', 0), v = h(e, i, {
          max: g, qty: p, random: c, randomB: d, repeat: u, yoyo: f,
        }), y = 0; y < v.length; y++) { const m = this.create(0, 0, v[y].a, v[y].b, s, a); if (!m) break; l.push(m); } const x = o(t, 'setXY.x', 0); const w = o(t, 'setXY.y', 0); const b = o(t, 'setXY.stepX', 0); const T = o(t, 'setXY.stepY', 0); n.SetXY(l, x, w, b, T); const S = o(t, 'setRotation.value', 0); const _ = o(t, 'setRotation.step', 0); n.SetRotation(l, S, _); const A = o(t, 'setScale.x', 1); const C = o(t, 'setScale.y', A); const M = o(t, 'setScale.stepX', 0); const P = o(t, 'setScale.stepY', 0); n.SetScale(l, A, C, M, P); const E = o(t, 'setAlpha.value', 1); const k = o(t, 'setAlpha.step', 0); n.SetAlpha(l, E, k); const L = r(t, 'hitArea', null); const F = r(t, 'hitAreaCallback', null); L && n.SetHitArea(l, L, F); const R = r(t, 'gridAlign', !1); return R && n.GridAlign(l, R), this.createMultipleCallback && this.createMultipleCallback.call(this, l), l;
    },
    preUpdate(t, e) { if (this.runChildUpdate && this.children.size !== 0) for (let i = this.children.entries.slice(), n = 0; n < i.length; n++) { const s = i[n]; s.active && s.update(t, e); } },
    add(t, e) { return void 0 === e && (e = !1), this.isFull() ? this : (this.children.set(t), this.createCallback && this.createCallback.call(this, t), e && (this.scene.sys.displayList.add(t), t.preUpdate && this.scene.sys.updateList.add(t)), t.on('destroy', this.remove, this), this); },
    addMultiple(t, e) { if (void 0 === e && (e = !1), Array.isArray(t)) for (let i = 0; i < t.length; i++) this.add(t[i], e); return this; },
    remove(t, e, i) { return void 0 === e && (e = !1), void 0 === i && (i = !1), this.children.contains(t) ? (this.children.delete(t), this.removeCallback && this.removeCallback.call(this, t), t.off('destroy', this.remove, this), i ? t.destroy() : e && (t.scene.sys.displayList.remove(t), t.preUpdate && t.scene.sys.updateList.remove(t)), this) : this; },
    clear(t, e) { void 0 === t && (t = !1), void 0 === e && (e = !1); for (let i = this.children, n = 0; n < i.size; n++) { const s = i.entries[n]; s.off('destroy', this.remove, this), e ? s.destroy() : t && (s.scene.sys.displayList.remove(s), s.preUpdate && s.scene.sys.updateList.remove(s)); } return this.children.clear(), this; },
    contains(t) { return this.children.contains(t); },
    getChildren() { return this.children.entries; },
    getLength() { return this.children.size; },
    getFirst(t, e, i, n, s, r, o) { return this.getHandler(!0, 1, t, e, i, n, s, r, o); },
    getFirstNth(t, e, i, n, s, r, o, a) { return this.getHandler(!0, t, e, i, n, s, r, o, a); },
    getLast(t, e, i, n, s, r, o) { return this.getHandler(!1, 1, t, e, i, n, s, r, o); },
    getLastNth(t, e, i, n, s, r, o, a) { return this.getHandler(!1, t, e, i, n, s, r, o, a); },
    getHandler(t, e, i, n, s, r, o, a, h) { let l; let u; void 0 === i && (i = !1), void 0 === n && (n = !1); let c = 0; const d = this.children.entries; if (t) for (u = 0; u < d.length; u++) if ((l = d[u]).active === i) { if (++c === e) break; } else l = null; else for (u = d.length - 1; u >= 0; u--) if ((l = d[u]).active === i) { if (++c === e) break; } else l = null; return l ? (typeof s === 'number' && (l.x = s), typeof r === 'number' && (l.y = r), l) : n ? this.create(s, r, o, a, h) : null; },
    get(t, e, i, n, s) { return this.getFirst(!1, !0, t, e, i, n, s); },
    getFirstAlive(t, e, i, n, s, r) { return this.getFirst(!0, t, e, i, n, s, r); },
    getFirstDead(t, e, i, n, s, r) { return this.getFirst(!1, t, e, i, n, s, r); },
    playAnimation(t, e) { return n.PlayAnimation(this.children.entries, t, e), this; },
    isFull() { return this.maxSize !== -1 && this.children.size >= this.maxSize; },
    countActive(t) { void 0 === t && (t = !0); for (var e = 0, i = 0; i < this.children.size; i++) this.children.entries[i].active === t && e++; return e; },
    getTotalUsed() { return this.countActive(); },
    getTotalFree() { const t = this.getTotalUsed(); return (this.maxSize === -1 ? 999999999999 : this.maxSize) - t; },
    setDepth(t, e) { return n.SetDepth(this.children.entries, t, e), this; },
    kill(t) { this.children.contains(t) && t.setActive(!1); },
    killAndHide(t) { this.children.contains(t) && (t.setActive(!1), t.setVisible(!1)); },
    toggleVisible() { return n.ToggleVisible(this.children.entries), this; },
    destroy(t) { if (void 0 === t && (t = !1), this.scene && !this.ignoreDestroy) { if (t) for (let e = this.children, i = 0; i < e.size; i++) { const n = e.entries[i]; n.off('destroy', this.remove, this), n.destroy(); } this.children.clear(), this.scene = void 0, this.children = void 0; } },
  }); t.exports = c;
}, function (t, e) { t.exports = function (t, e, i) { if (t.width <= 0 || t.height <= 0) return !1; let n = (e - t.x) / t.width; let s = (i - t.y) / t.height; return (n *= n) + (s *= s) < 0.25; }; }, function (t, e, i) {
  const n = i(0); const s = i(89); const r = i(308); const o = i(307); const a = i(185); const h = new n({
    initialize(t, e, i, n) { void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), this.x = t, this.y = e, this.width = i, this.height = n; }, contains(t, e) { return s(this, t, e); }, getPoint(t, e) { return r(this, t, e); }, getPoints(t, e, i) { return o(this, t, e, i); }, getRandomPoint(t) { return a(this, t); }, setTo(t, e, i, n) { return this.x = t, this.y = e, this.width = i, this.height = n, this; }, setEmpty() { return this.width = 0, this.height = 0, this; }, setPosition(t, e) { return void 0 === e && (e = t), this.x = t, this.y = e, this; }, setSize(t, e) { return void 0 === e && (e = t), this.width = t, this.height = e, this; }, isEmpty() { return this.width <= 0 || this.height <= 0; }, getMinorRadius() { return Math.min(this.width, this.height) / 2; }, getMajorRadius() { return Math.max(this.width, this.height) / 2; }, left: { get() { return this.x - this.width / 2; }, set(t) { this.x = t + this.width / 2; } }, right: { get() { return this.x + this.width / 2; }, set(t) { this.x = t - this.width / 2; } }, top: { get() { return this.y - this.height / 2; }, set(t) { this.y = t + this.height / 2; } }, bottom: { get() { return this.y + this.height / 2; }, set(t) { this.y = t - this.height / 2; } },
  }); t.exports = h;
}, function (t, e) { t.exports = function (t, e) { if (!(e >= t.length)) { for (var i = t.length - 1, n = t[e], s = e; s < i; s++)t[s] = t[s + 1]; return t.length = i, n; } }; }, function (t, e, i) {
  (function (e) {
    const i = {
      android: !1, chromeOS: !1, cocoonJS: !1, cocoonJSApp: !1, cordova: !1, crosswalk: !1, desktop: !1, ejecta: !1, electron: !1, iOS: !1, iOSVersion: 0, iPad: !1, iPhone: !1, kindle: !1, linux: !1, macOS: !1, node: !1, nodeWebkit: !1, pixelRatio: 1, webApp: !1, windows: !1, windowsPhone: !1,
    }; t.exports = (function () { const t = navigator.userAgent; /Windows/.test(t) ? i.windows = !0 : /Mac OS/.test(t) && !/like Mac OS/.test(t) ? i.macOS = !0 : /Android/.test(t) ? i.android = !0 : /Linux/.test(t) ? i.linux = !0 : /iP[ao]d|iPhone/i.test(t) ? (i.iOS = !0, navigator.appVersion.match(/OS (\d+)/), i.iOSVersion = parseInt(RegExp.$1, 10), i.iPhone = t.toLowerCase().indexOf('iphone') !== -1, i.iPad = t.toLowerCase().indexOf('ipad') !== -1) : /Kindle/.test(t) || /\bKF[A-Z][A-Z]+/.test(t) || /Silk.*Mobile Safari/.test(t) ? i.kindle = !0 : /CrOS/.test(t) && (i.chromeOS = !0), (/Windows Phone/i.test(t) || /IEMobile/i.test(t)) && (i.android = !1, i.iOS = !1, i.macOS = !1, i.windows = !0, i.windowsPhone = !0); const n = /Silk/.test(t); if ((i.windows || i.macOS || i.linux && !n || i.chromeOS) && (i.desktop = !0), (i.windowsPhone || /Windows NT/i.test(t) && /Touch/i.test(t)) && (i.desktop = !1), navigator.standalone && (i.webApp = !0), void 0 !== window.cordova && (i.cordova = !0), void 0 !== e && e.versions && e.versions.node && (i.node = !0), i.node && typeof e.versions === 'object' && (i.nodeWebkit = !!e.versions['node-webkit'], i.electron = !!e.versions.electron), navigator.isCocoonJS) { i.cocoonJS = !0; try { i.cocoonJSApp = typeof CocoonJS !== 'undefined'; } catch (t) { i.cocoonJSApp = !1; } } return void 0 !== window.ejecta && (i.ejecta = !0), /Crosswalk/.test(t) && (i.crosswalk = !0), i.pixelRatio = window.devicePixelRatio || 1, i; }());
  }).call(this, i(907));
}, function (t, e, i) { const n = i(23); t.exports = function (t, e, i) { return (i - e) * (t = n(t, 0, 1)); }; }, function (t, e) { t.exports = { DEFAULT: 0, LINEAR: 0, NEAREST: 1 }; }, function (t, e, i) {
  var n = new (i(0))({
    initialize(t) { if (this.entries = [], Array.isArray(t)) for (let e = 0; e < t.length; e++) this.set(t[e]); }, set(t) { return this.entries.indexOf(t) === -1 && this.entries.push(t), this; }, get(t, e) { for (let i = 0; i < this.entries.length; i++) { const n = this.entries[i]; if (n[t] === e) return n; } }, getArray() { return this.entries.slice(0); }, delete(t) { const e = this.entries.indexOf(t); return e > -1 && this.entries.splice(e, 1), this; }, dump() { console.group('Set'); for (let t = 0; t < this.entries.length; t++) { const e = this.entries[t]; console.log(e); }console.groupEnd(); }, each(t, e) { let i; const n = this.entries.slice(); const s = n.length; if (e) for (i = 0; i < s && !1 !== t.call(e, n[i], i); i++);else for (i = 0; i < s && !1 !== t(n[i], i); i++);return this; }, iterate(t, e) { let i; const n = this.entries.length; if (e) for (i = 0; i < n && !1 !== t.call(e, this.entries[i], i); i++);else for (i = 0; i < n && !1 !== t(this.entries[i], i); i++);return this; }, iterateLocal(t) { let e; const i = []; for (e = 1; e < arguments.length; e++)i.push(arguments[e]); const n = this.entries.length; for (e = 0; e < n; e++) { const s = this.entries[e]; s[t].apply(s, i); } return this; }, clear() { return this.entries.length = 0, this; }, contains(t) { return this.entries.indexOf(t) > -1; }, union(t) { const e = new n(); return t.entries.forEach((t) => { e.set(t); }), this.entries.forEach((t) => { e.set(t); }), e; }, intersect(t) { const e = new n(); return this.entries.forEach((i) => { t.contains(i) && e.set(i); }), e; }, difference(t) { const e = new n(); return this.entries.forEach((i) => { t.contains(i) || e.set(i); }), e; }, size: { get() { return this.entries.length; }, set(t) { return t < this.entries.length ? this.entries.length = t : this.entries.length; } },
  }); t.exports = n;
}, function (t, e, i) { const n = i(63); t.exports = function (t, e) { const i = n(t); for (const s in e)i.hasOwnProperty(s) || (i[s] = e[s]); return i; }; }, function (t, e, i) { const n = i(129); const s = i(12); const r = i(84); const o = i(86); const a = i(98); const h = i(205); const l = i(131); const u = i(4); const c = i(130); const d = i(128); const f = i(127); t.exports = function (t, e, i) { void 0 === i && (i = n); for (var p = i.targets ? i.targets : l(e), g = h(e), v = a(e, 'delay', i.delay), y = a(e, 'duration', i.duration), m = u(e, 'easeParams', i.easeParams), x = o(u(e, 'ease', i.ease), m), w = a(e, 'hold', i.hold), b = a(e, 'repeat', i.repeat), T = a(e, 'repeatDelay', i.repeatDelay), S = r(e, 'yoyo', i.yoyo), _ = r(e, 'flipX', i.flipX), A = r(e, 'flipY', i.flipY), C = [], M = 0; M < g.length; M++) for (let P = g[M].key, E = g[M].value, k = 0; k < p.length; k++) { const L = c(P, E); const F = f(p[k], P, L.getEnd, L.getStart, o(u(E, 'ease', x), m), a(E, 'delay', v), a(E, 'duration', y), r(E, 'yoyo', S), a(E, 'hold', w), a(E, 'repeat', b), a(E, 'repeatDelay', T), r(E, 'flipX', _), r(E, 'flipY', A)); C.push(F); } const R = new d(t, C, p); R.offset = s(e, 'offset', null), R.completeDelay = s(e, 'completeDelay', 0), R.loop = Math.round(s(e, 'loop', 0)), R.loopDelay = Math.round(s(e, 'loopDelay', 0)), R.paused = r(e, 'paused', !1), R.useFrames = r(e, 'useFrames', !1); for (let O = u(e, 'callbackScope', R), D = [R, null], B = d.TYPES, I = 0; I < B.length; I++) { const Y = B[I]; const X = u(e, Y, !1); if (X) { const z = u(e, `${Y}Scope`, O); const N = u(e, `${Y}Params`, []); R.setCallback(Y, X, D.concat(N), z); } } return R; }; }, function (t, e) { t.exports = function (t, e, i) { let n; n = t.hasOwnProperty(e) ? typeof t[e] === 'function' ? function (i, n, s) { return t[e](i, n, s); } : function () { return t[e]; } : typeof i === 'function' ? i : function () { return i; }; return n; }; }, function (t, e, i) {
  const n = new (i(0))({
    initialize(t, e, i, n, s, r, o, a) { (void 0 === i || i <= 0) && (i = 32), (void 0 === n || n <= 0) && (n = 32), void 0 === s && (s = 0), void 0 === r && (r = 0), void 0 === o && (o = {}), void 0 === a && (a = {}), this.name = t, this.firstgid = e, this.tileWidth = i, this.tileHeight = n, this.tileMargin = s, this.tileSpacing = r, this.tileProperties = o, this.tileData = a, this.image = null, this.glTexture = null, this.rows = 0, this.columns = 0, this.total = 0, this.texCoordinates = []; }, getTileProperties(t) { return this.containsTileIndex(t) ? this.tileProperties[t - this.firstgid] : null; }, getTileData(t) { return this.containsTileIndex(t) ? this.tileData[t - this.firstgid] : null; }, getTileCollisionGroup(t) { const e = this.getTileData(t); return e && e.objectgroup ? e.objectgroup : null; }, containsTileIndex(t) { return t >= this.firstgid && t < this.firstgid + this.total; }, getTileTextureCoordinates(t) { return this.containsTileIndex(t) ? this.texCoordinates[t - this.firstgid] : null; }, setImage(t) { return this.image = t, this.glTexture = t.get().source.glTexture, this.updateTileData(this.image.source[0].width, this.image.source[0].height), this; }, setTileSize(t, e) { return void 0 !== t && (this.tileWidth = t), void 0 !== e && (this.tileHeight = e), this.image && this.updateTileData(this.image.source[0].width, this.image.source[0].height), this; }, setSpacing(t, e) { return void 0 !== t && (this.tileMargin = t), void 0 !== e && (this.tileSpacing = e), this.image && this.updateTileData(this.image.source[0].width, this.image.source[0].height), this; }, updateTileData(t, e) { let i = (e - 2 * this.tileMargin + this.tileSpacing) / (this.tileHeight + this.tileSpacing); let n = (t - 2 * this.tileMargin + this.tileSpacing) / (this.tileWidth + this.tileSpacing); i % 1 == 0 && n % 1 == 0 || console.warn(`Image tile area not tile size multiple in: ${this.name}`), i = Math.floor(i), n = Math.floor(n), this.rows = i, this.columns = n, this.total = i * n, this.texCoordinates.length = 0; for (let s = this.tileMargin, r = this.tileMargin, o = 0; o < this.rows; o++) { for (let a = 0; a < this.columns; a++) this.texCoordinates.push({ x: s, y: r }), s += this.tileWidth + this.tileSpacing; s = this.tileMargin, r += this.tileHeight + this.tileSpacing; } return this; },
  }); t.exports = n;
}, function (t, e) { t.exports = function (t, e, i) { let n = i.baseTileHeight; const s = i.tilemapLayer; let r = 0; return s && (void 0 === e && (e = s.scene.cameras.main), r = s.y + e.scrollY * (1 - s.scrollFactorY), n *= s.scaleY), r + t * n; }; }, function (t, e) { t.exports = function (t, e, i) { let n = i.baseTileWidth; const s = i.tilemapLayer; let r = 0; return s && (void 0 === e && (e = s.scene.cameras.main), r = s.x + e.scrollX * (1 - s.scrollFactorX), n *= s.scaleX), r + t * n; }; }, function (t, e, i) { const n = i(79); t.exports = function (t, e, i, s) { if (void 0 === i && (i = !1), n(t, e, s)) { const r = s.data[e][t]; return r === null ? null : r.index === -1 ? i ? r : null : r; } return null; }; }, function (t, e, i) {
  t.exports = {
    CalculateFacesAt: i(136), CalculateFacesWithin: i(34), Copy: i(489), CreateFromTiles: i(488), CullTiles: i(487), Fill: i(486), FilterTiles: i(485), FindByIndex: i(484), FindTile: i(483), ForEachTile: i(482), GetTileAt: i(102), GetTileAtWorldXY: i(481), GetTilesWithin: i(17), GetTilesWithinShape: i(480), GetTilesWithinWorldXY: i(479), HasTileAt: i(219), HasTileAtWorldXY: i(478), IsInLayerBounds: i(79), PutTileAt: i(135), PutTileAtWorldXY: i(477), PutTilesAt: i(476), Randomize: i(475), RemoveTileAt: i(218), RemoveTileAtWorldXY: i(474), RenderDebug: i(473), ReplaceByIndex: i(220), SetCollision: i(472), SetCollisionBetween: i(471), SetCollisionByExclusion: i(470), SetCollisionByProperty: i(469), SetCollisionFromCollisionGroup: i(468), SetTileIndexCallback: i(467), SetTileLocationCallback: i(466), Shuffle: i(465), SwapByIndex: i(464), TileToWorldX: i(101), TileToWorldXY: i(463), TileToWorldY: i(100), WeightedRandomize: i(462), WorldToTileX: i(50), WorldToTileXY: i(461), WorldToTileY: i(49),
  };
}, function (t, e, i) { const n = i(0); const s = i(236); const r = i(61); const o = new n({ Extends: r, Mixins: [s.Acceleration, s.Angular, s.Bounce, s.Debug, s.Drag, s.Enable, s.Friction, s.Gravity, s.Immovable, s.Mass, s.Size, s.Velocity], initialize(t, e, i, n, s) { r.call(this, t, e, i, n, s), this.body = null; } }); t.exports = o; }, function (t, e) {
  t.exports = function (t, e, i, n, s) {
    return void 0 === t && (t = ''), void 0 === e && (e = !0), void 0 === i && (i = ''), void 0 === n && (n = ''), void 0 === s && (s = 0), {
      responseType: t, async: e, user: i, password: n, timeout: s, header: void 0, headerValue: void 0, requestedWith: !1, overrideMimeType: void 0,
    };
  };
}, function (t, e, i) {
  const n = i(4); const s = {}; const r = {
    register(t, e, i, n, r) {
      s[t] = {
        plugin: e, mapping: i, settingsKey: n, configKey: r,
      };
    },
    getPlugin(t) { return s[t]; },
    install(t) { const e = t.scene.sys; const i = e.settings.input; const r = e.game.config; for (const o in s) { const a = s[o].plugin; const h = s[o].mapping; const l = s[o].settingsKey; const u = s[o].configKey; n(i, l, r[u]) && (t[h] = new a(t)); } },
    remove(t) { s.hasOwnProperty(t) && delete s[t]; },
  }; t.exports = r;
}, function (t, e, i) { const n = i(6); t.exports = function (t, e, i) { void 0 === i && (i = new n()); const s = t.x1; const r = t.y1; const o = t.x2; const a = t.y2; const h = e.x1; const l = e.y1; const u = e.x2; const c = e.y2; const d = (u - h) * (r - l) - (c - l) * (s - h); const f = (o - s) * (r - l) - (a - r) * (s - h); const p = (c - l) * (o - s) - (u - h) * (a - r); if (p === 0) return !1; const g = d / p; const v = f / p; return g >= 0 && g <= 1 && v >= 0 && v <= 1 && (i.x = s + g * (o - s), i.y = r + g * (a - r), !0); }; }, function (t, e, i) { const n = i(0); const s = i(14); const r = i(19); const o = i(731); const a = new n({ Extends: r, Mixins: [s.Alpha, s.BlendMode, s.Depth, s.Flip, s.GetBounds, s.Mask, s.Origin, s.Pipeline, s.ScaleMode, s.Size, s.Texture, s.Transform, s.Visible, s.ScrollFactor, o], initialize(t, e, i, n, s, o, a, h, l) { if (r.call(this, t, 'Mesh'), n.length !== s.length) throw new Error('Mesh Vertex count must match UV count'); let u; const c = n.length / 2 | 0; if (o.length > 0 && o.length < c) throw new Error('Mesh Color count must match Vertex count'); if (a.length > 0 && a.length < c) throw new Error('Mesh Alpha count must match Vertex count'); if (o.length === 0) for (u = 0; u < c; ++u)o[u] = 16777215; if (a.length === 0) for (u = 0; u < c; ++u)a[u] = 1; this.vertices = new Float32Array(n), this.uv = new Float32Array(s), this.colors = new Uint32Array(o), this.alphas = new Float32Array(a), this.tintFill = !1, this.setTexture(h, l), this.setPosition(e, i), this.setSizeToFrame(), this.setOrigin(), this.initPipeline(); } }); t.exports = a; }, function (t, e, i) {
  const n = i(0); const s = i(14); const r = i(19); const o = i(846); const a = i(845); const h = i(844); var l = new n({
    Extends: r,
    Mixins: [s.Alpha, s.BlendMode, s.Depth, s.Mask, s.Origin, s.Pipeline, s.ScaleMode, s.ScrollFactor, s.Texture, s.Tint, s.Transform, s.Visible, h],
    initialize(t, e, i, n, s, a, h) { void 0 === s && (s = ''), void 0 === h && (h = 0), r.call(this, t, 'BitmapText'), this.font = n; const l = this.scene.sys.cache.bitmapFont.get(n); this.fontData = l.data, this._text = '', this._fontSize = a || this.fontData.size, this._letterSpacing = 0, this._align = h, this._bounds = o(this, !1, this._bounds), this._dirty = !1, this.setTexture(l.texture, l.frame), this.setPosition(e, i), this.setOrigin(0, 0), this.initPipeline(), this.setText(s); },
    setLeftAlign() { return this._align = l.ALIGN_LEFT, this._dirty = !0, this; },
    setCenterAlign() { return this._align = l.ALIGN_CENTER, this._dirty = !0, this; },
    setRightAlign() { return this._align = l.ALIGN_RIGHT, this._dirty = !0, this; },
    setFontSize(t) { return this._fontSize = t, this._dirty = !0, this; },
    setLetterSpacing(t) { return void 0 === t && (t = 0), this._letterSpacing = t, this._dirty = !0, this; },
    setText(t) { return t || t === 0 || (t = ''), Array.isArray(t) && (t = t.join('\n')), t !== this.text && (this._text = t.toString(), this._dirty = !0, this.updateDisplayOrigin()), this; },
    getTextBounds(t) { return this._dirty && o(this, t, this._bounds), this._bounds; },
    setFont(t, e, i) { if (void 0 === e && (e = this._fontSize), void 0 === i && (i = this._align), t !== this.font) { const n = this.scene.sys.cache.bitmapFont.get(t); n && (this.font = t, this.fontData = n.data, this._fontSize = e, this._align = i, this.setTexture(n.texture, n.frame), o(this, !1, this._bounds)); } return this; },
    align: { set(t) { this._align = t, this._dirty = !0; }, get() { return this._align; } },
    text: { set(t) { this.setText(t); }, get() { return this._text; } },
    fontSize: { set(t) { this._fontSize = t, this._dirty = !0; }, get() { return this._fontSize; } },
    letterSpacing: { set(t) { this._letterSpacing = t, this._dirty = !0; }, get() { return this._letterSpacing; } },
    width: { get() { return this.getTextBounds(!1), this._bounds.global.width; } },
    height: { get() { return this.getTextBounds(!1), this._bounds.global.height; } },
    toJSON() {
      const t = s.ToJSON(this); const e = {
        font: this.font, text: this.text, fontSize: this.fontSize, letterSpacing: this.letterSpacing, align: this.align,
      }; return t.data = e, t;
    },
  }); l.ALIGN_LEFT = 0, l.ALIGN_CENTER = 1, l.ALIGN_RIGHT = 2, l.ParseFromAtlas = a, t.exports = l;
}, function (t, e, i) { !(function () { const e = function (t, e) { return i(t.slice(), e); }; function i(t, e) { typeof e !== 'function' && (e = function (t, e) { return String(t).localeCompare(e); }); const i = t.length; if (i <= 1) return t; for (let s = new Array(i), r = 1; r < i; r *= 2) { n(t, e, r, s); const o = t; t = s, s = o; } return t; }e.inplace = function (t, e) { const s = i(t, e); return s !== t && n(s, null, t.length, t), t; }; var n = function (t, e, i, n) { let s; let r; let o; let a; let h; const l = t.length; let u = 0; const c = 2 * i; for (s = 0; s < l; s += c) for (o = (r = s + i) + i, r > l && (r = l), o > l && (o = l), a = s, h = r; ;) if (a < r && h < o)e(t[a], t[h]) <= 0 ? n[u++] = t[a++] : n[u++] = t[h++]; else if (a < r)n[u++] = t[a++]; else { if (!(h < o)) break; n[u++] = t[h++]; } }; t.exports = e; }()); }, function (t, e, i) { const n = i(163); const s = i(315); t.exports = function (t, e) { if (void 0 === e && (e = 90), !n(t)) return null; if (typeof e !== 'string' && (e = (e % 360 + 360) % 360), e === 90 || e === -270 || e === 'rotateLeft')(t = s(t)).reverse(); else if (e === -90 || e === 270 || e === 'rotateRight')t.reverse(), t = s(t); else if (Math.abs(e) === 180 || e === 'rotate180') { for (let i = 0; i < t.length; i++)t[i].reverse(); t.reverse(); } return t; }; }, function (t, e, i) {
  const n = i(164); const s = i(0); const r = i(1); const o = i(110); const a = new s({
    initialize(t) { this.parent = t, this.list = [], this.position = 0, this.addCallback = r, this.removeCallback = r, this._sortKey = ''; }, add(t, e) { return e ? n.Add(this.list, t) : n.Add(this.list, t, 0, this.addCallback, this); }, addAt(t, e, i) { return i ? n.AddAt(this.list, t, e) : n.AddAt(this.list, t, e, 0, this.addCallback, this); }, getAt(t) { return this.list[t]; }, getIndex(t) { return this.list.indexOf(t); }, sort(t) { return t && (this._sortKey = t, o.inplace(this.list, this.sortHandler)), this; }, sortHandler(t, e) { return t[this._sortKey] - e[this._sortKey]; }, getByName(t) { return n.GetFirst(this.list, 'name', t); }, getRandom(t, e) { return n.GetRandom(this.list, t, e); }, getFirst(t, e, i, s) { return n.GetFirstElement(this.list, t, e, i, s); }, getAll(t, e, i, s) { return n.GetAll(this.list, t, e, i, s); }, count(t, e) { return n.CountAllMatching(this.list, t, e); }, swap(t, e) { n.Swap(this.list, t, e); }, moveTo(t, e) { return n.MoveTo(this.list, t, e); }, remove(t, e) { return e ? n.Remove(this.list, t) : n.Remove(this.list, t, this.removeCallback, this); }, removeAt(t, e) { return e ? n.RemoveAt(this.list, t) : n.RemoveAt(this.list, t, this.removeCallback, this); }, removeBetween(t, e, i) { return i ? n.RemoveBetween(this.list, t, e) : n.RemoveBetween(this.list, t, e, this.removeCallback, this); }, removeAll(t) { for (let e = this.list.length; e--;) this.remove(this.list[e], t); return this; }, bringToTop(t) { return n.BringToTop(this.list, t); }, sendToBack(t) { return n.SendToBack(this.list, t); }, moveUp(t) { return n.MoveUp(this.list, t), t; }, moveDown(t) { return n.MoveDown(this.list, t), t; }, reverse() { return this.list.reverse(), this; }, shuffle() { return n.Shuffle(this.list), this; }, replace(t, e) { return n.Replace(this.list, t, e); }, exists(t) { return this.list.indexOf(t) > -1; }, setAll(t, e, i, s) { return n.SetAll(this.list, t, e, i, s), this; }, each(t, e) { for (var i = [null], n = 2; n < arguments.length; n++)i.push(arguments[n]); for (n = 0; n < this.list.length; n++)i[0] = this.list[n], t.apply(e, i); }, shutdown() { this.removeAll(), this.list = []; }, destroy() { this.removeAll(), this.parent = null, this.addCallback = null, this.removeCallback = null; }, length: { get() { return this.list.length; } }, first: { get() { return this.position = 0, this.list.length > 0 ? this.list[0] : null; } }, last: { get() { return this.list.length > 0 ? (this.position = this.list.length - 1, this.list[this.position]) : null; } }, next: { get() { return this.position < this.list.length ? (this.position++, this.list[this.position]) : null; } }, previous: { get() { return this.position > 0 ? (this.position--, this.list[this.position]) : null; } },
  }); t.exports = a;
}, function (t, e, i) {
  const n = i(0); const s = i(23); const r = i(20); var o = new n({
    initialize(t, e, i, n, s, r, o) {
      this.texture = t, this.name = e, this.source = t.source[i], this.sourceIndex = i, this.glTexture = this.source.glTexture, this.cutX, this.cutY, this.cutWidth, this.cutHeight, this.x = 0, this.y = 0, this.width, this.height, this.halfWidth, this.halfHeight, this.centerX, this.centerY, this.pivotX = 0, this.pivotY = 0, this.customPivot = !1, this.rotated = !1, this.autoRound = -1, this.customData = {}, this.u0 = 0, this.v0 = 0, this.u1 = 0, this.v1 = 0, this.data = {
        cut: {
          x: 0, y: 0, w: 0, h: 0, r: 0, b: 0,
        },
        trim: !1,
        sourceSize: { w: 0, h: 0 },
        spriteSourceSize: {
          x: 0, y: 0, w: 0, h: 0, r: 0, b: 0,
        },
        radius: 0,
        drawImage: {
          x: 0, y: 0, width: 0, height: 0,
        },
      }, this.setSize(r, o, n, s);
    },
    setSize(t, e, i, n) { void 0 === i && (i = 0), void 0 === n && (n = 0), this.cutX = i, this.cutY = n, this.cutWidth = t, this.cutHeight = e, this.width = t, this.height = e, this.halfWidth = Math.floor(0.5 * t), this.halfHeight = Math.floor(0.5 * e), this.centerX = Math.floor(t / 2), this.centerY = Math.floor(e / 2); const s = this.data; const r = s.cut; r.x = i, r.y = n, r.w = t, r.h = e, r.r = i + t, r.b = n + e, s.sourceSize.w = t, s.sourceSize.h = e, s.spriteSourceSize.w = t, s.spriteSourceSize.h = e, s.radius = 0.5 * Math.sqrt(t * t + e * e); const o = s.drawImage; return o.x = i, o.y = n, o.width = t, o.height = e, this.updateUVs(); },
    setTrim(t, e, i, n, s, r) { const o = this.data; const a = o.spriteSourceSize; return o.trim = !0, o.sourceSize.w = t, o.sourceSize.h = e, a.x = i, a.y = n, a.w = s, a.h = r, a.r = i + s, a.b = n + r, this.x = i, this.y = n, this.width = s, this.height = r, this.halfWidth = 0.5 * s, this.halfHeight = 0.5 * r, this.centerX = Math.floor(s / 2), this.centerY = Math.floor(r / 2), this.updateUVs(); },
    setCropUVs(t, e, i, n, r, o, a) { const h = this.cutX; const l = this.cutY; const u = this.cutWidth; const c = this.cutHeight; const d = this.realWidth; const f = this.realHeight; let p = h + (e = s(e, 0, d)); let g = l + (i = s(i, 0, f)); let v = n = s(n, 0, d - e); let y = r = s(r, 0, f - i); const m = this.data; if (m.trim) { const x = m.spriteSourceSize; const w = e + (n = s(n, 0, u - e)); const b = i + (r = s(r, 0, c - i)); if (!(x.r < e || x.b < i || x.x > w || x.y > b)) { const T = Math.max(x.x, e); const S = Math.max(x.y, i); const _ = Math.min(x.r, w) - T; const A = Math.min(x.b, b) - S; v = _, y = A, p = o ? h + (u - (T - x.x) - _) : h + (T - x.x), g = a ? l + (c - (S - x.y) - A) : l + (S - x.y), e = T, i = S, n = _, r = A; } else p = 0, g = 0, v = 0, y = 0; } else o && (p = h + (u - e - n)), a && (g = l + (c - i - r)); const C = this.source.width; const M = this.source.height; return t.u0 = Math.max(0, p / C), t.v0 = Math.max(0, g / M), t.u1 = Math.min(1, (p + v) / C), t.v1 = Math.min(1, (g + y) / M), t.x = e, t.y = i, t.cx = p, t.cy = g, t.cw = v, t.ch = y, t.width = n, t.height = r, t.flipX = o, t.flipY = a, t; },
    updateCropUVs(t, e, i) { return this.setCropUVs(t, t.x, t.y, t.width, t.height, e, i); },
    updateUVs() { const t = this.cutX; const e = this.cutY; const i = this.cutWidth; const n = this.cutHeight; const s = this.data.drawImage; s.width = i, s.height = n; const r = this.source.width; const o = this.source.height; return this.u0 = t / r, this.v0 = e / o, this.u1 = (t + i) / r, this.v1 = (e + n) / o, this; },
    updateUVsInverted() { const t = this.source.width; const e = this.source.height; return this.u0 = (this.cutX + this.cutHeight) / t, this.v0 = this.cutY / e, this.u1 = this.cutX / t, this.v1 = (this.cutY + this.cutWidth) / e, this; },
    clone() { const t = new o(this.texture, this.name, this.sourceIndex); return t.cutX = this.cutX, t.cutY = this.cutY, t.cutWidth = this.cutWidth, t.cutHeight = this.cutHeight, t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t.halfWidth = this.halfWidth, t.halfHeight = this.halfHeight, t.centerX = this.centerX, t.centerY = this.centerY, t.rotated = this.rotated, t.data = r(!0, t.data, this.data), t.updateUVs(), t; },
    destroy() { this.texture = null, this.source = null; },
    realWidth: { get() { return this.data.sourceSize.w; } },
    realHeight: { get() { return this.data.sourceSize.h; } },
    radius: { get() { return this.data.radius; } },
    trimmed: { get() { return this.data.trim; } },
    canvasData: { get() { return this.data.drawImage; } },
  }); t.exports = o;
}, function (t, e, i) {
  const n = i(0); const s = i(11); const r = i(20); const o = i(1); const a = new n({
    Extends: s,
    initialize(t, e, i) {
      s.call(this), this.manager = t, this.key = e, this.isPlaying = !1, this.isPaused = !1, this.totalRate = 1, this.duration = this.duration || 0, this.totalDuration = this.totalDuration || 0, this.config = {
        mute: !1, volume: 1, rate: 1, detune: 0, seek: 0, loop: !1, delay: 0,
      }, this.currentConfig = this.config, this.config = r(this.config, i), this.markers = {}, this.currentMarker = null, this.pendingRemove = !1;
    },
    addMarker(t) {
      return !(!t || !t.name || typeof t.name !== 'string') && (this.markers[t.name] ? (console.error(`addMarker ${t.name} already exists in Sound`), !1) : (t = r(!0, {
        name: '',
        start: 0,
        duration: this.totalDuration - (t.start || 0),
        config: {
          mute: !1, volume: 1, rate: 1, detune: 0, seek: 0, loop: !1, delay: 0,
        },
      }, t), this.markers[t.name] = t, !0));
    },
    updateMarker(t) { return !(!t || !t.name || typeof t.name !== 'string') && (this.markers[t.name] ? (this.markers[t.name] = r(!0, this.markers[t.name], t), !0) : (console.warn(`Audio Marker: ${t.name} missing in Sound: ${this.key}`), !1)); },
    removeMarker(t) { const e = this.markers[t]; return e ? (this.markers[t] = null, e) : null; },
    play(t, e) { if (void 0 === t && (t = ''), typeof t === 'object' && (e = t, t = ''), typeof t !== 'string') return !1; if (t) { if (!this.markers[t]) return console.warn(`Marker: ${t} missing in Sound: ${this.key}`), !1; this.currentMarker = this.markers[t], this.currentConfig = this.currentMarker.config, this.duration = this.currentMarker.duration; } else this.currentMarker = null, this.currentConfig = this.config, this.duration = this.totalDuration; return this.resetConfig(), this.currentConfig = r(this.currentConfig, e), this.isPlaying = !0, this.isPaused = !1, !0; },
    pause() { return !(this.isPaused || !this.isPlaying) && (this.isPlaying = !1, this.isPaused = !0, !0); },
    resume() { return !(!this.isPaused || this.isPlaying) && (this.isPlaying = !0, this.isPaused = !1, !0); },
    stop() { return !(!this.isPaused && !this.isPlaying) && (this.isPlaying = !1, this.isPaused = !1, this.resetConfig(), !0); },
    applyConfig() { this.mute = this.currentConfig.mute, this.volume = this.currentConfig.volume, this.rate = this.currentConfig.rate, this.detune = this.currentConfig.detune, this.loop = this.currentConfig.loop; },
    resetConfig() { this.currentConfig.seek = 0, this.currentConfig.delay = 0; },
    update: o,
    calculateRate() { const t = this.currentConfig.detune + this.manager.detune; const e = Math.pow(1.0005777895065548, t); this.totalRate = this.currentConfig.rate * this.manager.rate * e; },
    destroy() { this.pendingRemove || (this.emit('destroy', this), this.pendingRemove = !0, this.manager = null, this.key = '', this.removeAllListeners(), this.isPlaying = !1, this.isPaused = !1, this.config = null, this.currentConfig = null, this.markers = null, this.currentMarker = null); },
  }); t.exports = a;
}, function (t, e, i) {
  const n = i(0); const s = i(63); const r = i(11); const o = i(1); const a = new n({
    Extends: r,
    initialize(t) { r.call(this), this.game = t, this.jsonCache = t.cache.json, this.sounds = [], this.mute = !1, this.volume = 1, this.pauseOnBlur = !0, this._rate = 1, this._detune = 0, this.locked = this.locked || !1, this.unlocked = !1, t.events.on('blur', function () { this.pauseOnBlur && this.onBlur(); }, this), t.events.on('focus', function () { this.pauseOnBlur && this.onFocus(); }, this), t.events.on('prestep', this.update, this), t.events.once('destroy', this.destroy, this); },
    add: o,
    addAudioSprite(t, e) {
      void 0 === e && (e = {}); const i = this.add(t, e); for (const n in i.spritemap = this.jsonCache.get(t).spritemap, i.spritemap) {
        if (i.spritemap.hasOwnProperty(n)) {
          const r = s(e); const o = i.spritemap[n]; r.loop = !!o.hasOwnProperty('loop') && o.loop, i.addMarker({
            name: n, start: o.start, duration: o.end - o.start, config: r,
          });
        }
      } return i;
    },
    play(t, e) { const i = this.add(t); return i.once('ended', i.destroy, i), e ? e.name ? (i.addMarker(e), i.play(e.name)) : i.play(e) : i.play(); },
    playAudioSprite(t, e, i) { const n = this.addAudioSprite(t); return n.once('ended', n.destroy, n), n.play(e, i); },
    remove(t) { const e = this.sounds.indexOf(t); return e !== -1 && (t.destroy(), this.sounds.splice(e, 1), !0); },
    removeByKey(t) { for (var e = 0, i = this.sounds.length - 1; i >= 0; i--) { const n = this.sounds[i]; n.key === t && (n.destroy(), this.sounds.splice(i, 1), e++); } return e; },
    pauseAll() { this.forEachActiveSound((t) => { t.pause(); }), this.emit('pauseall', this); },
    resumeAll() { this.forEachActiveSound((t) => { t.resume(); }), this.emit('resumeall', this); },
    stopAll() { this.forEachActiveSound((t) => { t.stop(); }), this.emit('stopall', this); },
    unlock: o,
    onBlur: o,
    onFocus: o,
    update(t, e) { this.unlocked && (this.unlocked = !1, this.locked = !1, this.emit('unlocked', this)); for (let i = this.sounds.length - 1; i >= 0; i--) this.sounds[i].pendingRemove && this.sounds.splice(i, 1); this.sounds.forEach((i) => { i.update(t, e); }); },
    destroy() { this.removeAllListeners(), this.forEachActiveSound((t) => { t.destroy(); }), this.sounds.length = 0, this.sounds = null, this.game = null; },
    forEachActiveSound(t, e) { const i = this; this.sounds.forEach((n, s) => { n.pendingRemove || t.call(e || i, n, s, i.sounds); }); },
    setRate(t) { return this.rate = t, this; },
    rate: { get() { return this._rate; }, set(t) { this._rate = t, this.forEachActiveSound((t) => { t.calculateRate(); }), this.emit('rate', this, t); } },
    setDetune(t) { return this.detune = t, this; },
    detune: { get() { return this._detune; }, set(t) { this._detune = t, this.forEachActiveSound((t) => { t.calculateRate(); }), this.emit('detune', this, t); } },
  }); t.exports = a;
}, function (t, e) {
  t.exports = {
    PENDING: 0, INIT: 1, START: 2, LOADING: 3, CREATING: 4, RUNNING: 5, PAUSED: 6, SLEEPING: 7, SHUTDOWN: 8, DESTROYED: 9,
  };
}, function (t, e) { t.exports = function (t, e) { return t > 0 && (t & t - 1) == 0 && e > 0 && (e & e - 1) == 0; }; }, function (t, e, i) {
  let n; const s = i(92); const r = {
    chrome: !1, chromeVersion: 0, edge: !1, firefox: !1, firefoxVersion: 0, ie: !1, ieVersion: 0, mobileSafari: !1, opera: !1, safari: !1, safariVersion: 0, silk: !1, trident: !1, tridentVersion: 0,
  }; t.exports = (n = navigator.userAgent, /Edge\/\d+/.test(n) ? r.edge = !0 : /Chrome\/(\d+)/.test(n) && !s.windowsPhone ? (r.chrome = !0, r.chromeVersion = parseInt(RegExp.$1, 10)) : /Firefox\D+(\d+)/.test(n) ? (r.firefox = !0, r.firefoxVersion = parseInt(RegExp.$1, 10)) : /AppleWebKit/.test(n) && s.iOS ? r.mobileSafari = !0 : /MSIE (\d+\.\d+);/.test(n) ? (r.ie = !0, r.ieVersion = parseInt(RegExp.$1, 10)) : /Opera/.test(n) ? r.opera = !0 : /Safari/.test(n) && !s.windowsPhone ? r.safari = !0 : /Trident\/(\d+\.\d+)(.*)rv:(\d+\.\d+)/.test(n) && (r.ie = !0, r.trident = !0, r.tridentVersion = parseInt(RegExp.$1, 10), r.ieVersion = parseInt(RegExp.$3, 10)), /Silk/.test(n) && (r.silk = !0), r);
}, function (t, e) { t.exports = function (t, e, i) { return (e - t) * i + t; }; }, function (t, e) {
  let i; let n = ''; t.exports = {
    disable(t) { return n === '' && (n = i(t)), n && (t[n] = !1), t; }, enable(t) { return n === '' && (n = i(t)), n && (t[n] = !0), t; }, getPrefix: i = function (t) { for (let e = ['i', 'webkitI', 'msI', 'mozI', 'oI'], i = 0; i < e.length; i++) { const n = `${e[i]}mageSmoothingEnabled`; if (n in t) return n; } return null; }, isEnabled(t) { return n !== null ? t[n] : null; },
  };
}, function (t, e, i) {
  const n = i(0); const s = i(14); const r = i(31); const o = i(11); const a = i(9); const h = i(38); const l = i(178); const u = i(3); const c = new n({
    Extends: o,
    Mixins: [s.Alpha, s.Visible],
    initialize(t, e, i, n) { void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), o.call(this), this.scene, this.sceneManager, this.config, this.id = 0, this.name = '', this.resolution = 1, this.roundPixels = !1, this.useBounds = !1, this.worldView = new a(), this.dirty = !0, this._x = t, this._y = e, this._cx = 0, this._cy = 0, this._cw = 0, this._ch = 0, this._width = i, this._height = n, this._bounds = new a(), this._scrollX = 0, this._scrollY = 0, this._zoom = 1, this._rotation = 0, this.matrix = new h(), this.transparent = !0, this.backgroundColor = l('rgba(0,0,0,0)'), this.disableCull = !1, this.culledObjects = [], this.midPoint = new u(i / 2, n / 2), this.originX = 0.5, this.originY = 0.5, this._customViewport = !1; },
    setOrigin(t, e) { return void 0 === t && (t = 0.5), void 0 === e && (e = t), this.originX = t, this.originY = e, this; },
    getScroll(t, e, i) { void 0 === i && (i = new u()); const n = 0.5 * this.width; const s = 0.5 * this.height; return i.x = t - n, i.y = e - s, this.useBounds && (i.x = this.clampX(i.x), i.y = this.clampY(i.y)), i; },
    centerOn(t, e) { const i = 0.5 * this.width; const n = 0.5 * this.height; return this.midPoint.set(t, e), this.scrollX = t - i, this.scrollY = e - n, this.useBounds && (this.scrollX = this.clampX(this.scrollX), this.scrollY = this.clampY(this.scrollY)), this; },
    centerToBounds() { if (this.useBounds) { const t = this._bounds; const e = 0.5 * this.width; const i = 0.5 * this.height; this.midPoint.set(t.centerX, t.centerY), this.scrollX = t.centerX - e, this.scrollY = t.centerY - i; } return this; },
    centerToSize() { return this.scrollX = 0.5 * this.width, this.scrollY = 0.5 * this.height, this; },
    cull(t) { if (this.disableCull) return t; const e = this.matrix.matrix; const i = e[0]; const n = e[1]; const s = e[2]; const r = e[3]; let o = i * r - n * s; if (!o) return t; const a = e[4]; const h = e[5]; const l = this.scrollX; const u = this.scrollY; const c = this.width; const d = this.height; const f = this.culledObjects; const p = t.length; o = 1 / o, f.length = 0; for (let g = 0; g < p; ++g) { const v = t[g]; if (v.hasOwnProperty('width') && !v.parentContainer) { const y = v.width; const m = v.height; const x = v.x - l * v.scrollFactorX - y * v.originX; const w = v.y - u * v.scrollFactorY - m * v.originY; const b = x * i + w * s + a; const T = x * n + w * r + h; const S = (x + y) * i + (w + m) * s + a; const _ = (x + y) * n + (w + m) * r + h; const A = c + y; const C = d + m; b > -y && T > -m && b < A && T < C && S > -y && _ > -m && S < A && _ < C && f.push(v); } else f.push(v); } return f; },
    getWorldPoint(t, e, i) { void 0 === i && (i = new u()); const n = this.matrix.matrix; const s = n[0]; const r = n[1]; const o = n[2]; const a = n[3]; const h = n[4]; const l = n[5]; let c = s * a - r * o; if (!c) return i.x = t, i.y = e, i; const d = a * (c = 1 / c); const f = -r * c; const p = -o * c; const g = s * c; const v = (o * l - a * h) * c; const y = (r * h - s * l) * c; const m = Math.cos(this.rotation); const x = Math.sin(this.rotation); const w = this.zoom; const b = this.resolution; const T = this.scrollX; const S = this.scrollY; const _ = t + (T * m - S * x) * w; const A = e + (T * x + S * m) * w; return i.x = (_ * d + A * p) * b + v, i.y = (_ * f + A * g) * b + y, i; },
    ignore(t) { const e = this.id; Array.isArray(t) || (t = [t]); for (let i = 0; i < t.length; i++) { const n = t[i]; Array.isArray(n) ? this.ignore(n) : n.isParent ? this.ignore(n.getChildren()) : n.cameraFilter |= e; } return this; },
    preRender(t, e) { const i = this.width; const n = this.height; const s = 0.5 * i; const r = 0.5 * n; const o = this.zoom * t; const a = this.matrix; let h = i * this.originX; let l = n * this.originY; let u = this.scrollX; let c = this.scrollY; this.useBounds && (u = this.clampX(u), c = this.clampY(c)), this.roundPixels && (h = Math.round(h), l = Math.round(l)), this.scrollX = u, this.scrollY = c; const d = u + s; const f = c + r; this.midPoint.set(d, f); const p = i / o; const g = n / o; this.worldView.setTo(d - p / 2, f - g / 2, p, g), a.loadIdentity(), a.scale(e, e), a.translate(this.x + h, this.y + l), a.rotate(this.rotation), a.scale(o, o), a.translate(-h, -l); },
    clampX(t) { const e = this._bounds; const i = this.displayWidth; const n = e.x + (i - this.width) / 2; const s = Math.max(n, n + e.width - i); return t < n ? t = n : t > s && (t = s), t; },
    clampY(t) { const e = this._bounds; const i = this.displayHeight; const n = e.y + (i - this.height) / 2; const s = Math.max(n, n + e.height - i); return t < n ? t = n : t > s && (t = s), t; },
    removeBounds() { return this.useBounds = !1, this.dirty = !0, this._bounds.setEmpty(), this; },
    setAngle(t) { return void 0 === t && (t = 0), this.rotation = r(t), this; },
    setBackgroundColor(t) { return void 0 === t && (t = 'rgba(0,0,0,0)'), this.backgroundColor = l(t), this.transparent = this.backgroundColor.alpha === 0, this; },
    setBounds(t, e, i, n, s) { return this._bounds.setTo(t, e, i, n), this.dirty = !0, this.useBounds = !0, s ? this.centerToBounds() : (this.scrollX = this.clampX(this.scrollX), this.scrollY = this.clampY(this.scrollY)), this; },
    setName(t) { return void 0 === t && (t = ''), this.name = t, this; },
    setPosition(t, e) { return void 0 === e && (e = t), this.x = t, this.y = e, this; },
    setRotation(t) { return void 0 === t && (t = 0), this.rotation = t, this; },
    setRoundPixels(t) { return this.roundPixels = t, this; },
    setScene(t) { this.scene && this._customViewport && this.sceneManager.customViewports--, this.scene = t, this.config = t.sys.game.config, this.sceneManager = t.sys.game.scene; const e = this.config.resolution; return this.resolution = e, this._cx = this._x * e, this._cy = this._y * e, this._cw = this._width * e, this._ch = this._height * e, this.updateSystem(), this; },
    setScroll(t, e) { return void 0 === e && (e = t), this.scrollX = t, this.scrollY = e, this; },
    setSize(t, e) { return void 0 === e && (e = t), this.width = t, this.height = e, this; },
    setViewport(t, e, i, n) { return this.x = t, this.y = e, this.width = i, this.height = n, this; },
    setZoom(t) { return void 0 === t && (t = 1), t === 0 && (t = 0.001), this.zoom = t, this; },
    toJSON() {
      const t = {
        name: this.name, x: this.x, y: this.y, width: this.width, height: this.height, zoom: this.zoom, rotation: this.rotation, roundPixels: this.roundPixels, scrollX: this.scrollX, scrollY: this.scrollY, backgroundColor: this.backgroundColor.rgba,
      }; return this.useBounds && (t.bounds = {
        x: this._bounds.x, y: this._bounds.y, width: this._bounds.width, height: this._bounds.height,
      }), t;
    },
    update() {},
    updateSystem() { if (this.config) { const t = this._x !== 0 || this._y !== 0 || this.config.width !== this._width || this.config.height !== this._height; const e = this.sceneManager; t && !this._customViewport ? e.customViewports++ : !t && this._customViewport && e.customViewports--, this.dirty = !0, this._customViewport = t; } },
    destroy() { this.emit('cameradestroy', this), this.removeAllListeners(), this.matrix.destroy(), this.culledObjects = [], this._customViewport && this.sceneManager.customViewports--, this._bounds = null, this.scene = null, this.config = null, this.sceneManager = null; },
    x: { get() { return this._x; }, set(t) { this._x = t, this._cx = t * this.resolution, this.updateSystem(); } },
    y: { get() { return this._y; }, set(t) { this._y = t, this._cy = t * this.resolution, this.updateSystem(); } },
    width: { get() { return this._width; }, set(t) { this._width = t, this._cw = t * this.resolution, this.updateSystem(); } },
    height: { get() { return this._height; }, set(t) { this._height = t, this._ch = t * this.resolution, this.updateSystem(); } },
    scrollX: { get() { return this._scrollX; }, set(t) { this._scrollX = t, this.dirty = !0; } },
    scrollY: { get() { return this._scrollY; }, set(t) { this._scrollY = t, this.dirty = !0; } },
    zoom: { get() { return this._zoom; }, set(t) { this._zoom = t, this.dirty = !0; } },
    rotation: { get() { return this._rotation; }, set(t) { this._rotation = t, this.dirty = !0; } },
    centerX: { get() { return this.x + 0.5 * this.width; } },
    centerY: { get() { return this.y + 0.5 * this.height; } },
    displayWidth: { get() { return this.width / this.zoom; } },
    displayHeight: { get() { return this.height / this.zoom; } },
  }); t.exports = c;
}, function (t, e) { t.exports = function (t) { for (let e = t.length - 1; e > 0; e--) { const i = Math.floor(Math.random() * (e + 1)); const n = t[e]; t[e] = t[i], t[i] = n; } return t; }; }, function (t, e, i) {
  const n = new (i(0))({
    initialize(t, e) { this.parent = t, this.events = e, e || (this.events = t.events ? t.events : t), this.list = {}, this.values = {}, this._frozen = !1, !t.hasOwnProperty('sys') && this.events && this.events.once('destroy', this.destroy, this); },
    get(t) { const e = this.list; if (Array.isArray(t)) { for (var i = [], n = 0; n < t.length; n++)i.push(e[t[n]]); return i; } return e[t]; },
    getAll() { const t = {}; for (const e in this.list) this.list.hasOwnProperty(e) && (t[e] = this.list[e]); return t; },
    query(t) { const e = {}; for (const i in this.list) this.list.hasOwnProperty(i) && i.match(t) && (e[i] = this.list[i]); return e; },
    set(t, e) { if (this._frozen) return this; if (typeof t === 'string') return this.setValue(t, e); for (const i in t) this.setValue(i, t[i]); return this; },
    setValue(t, e) {
      if (this._frozen) return this; if (this.has(t)) this.values[t] = e; else {
        const i = this; const n = this.list; const s = this.events; const r = this.parent; Object.defineProperty(this.values, t, {
          enumerable: !0, configurable: !0, get() { return n[t]; }, set(e) { if (!i._frozen) { const o = n[t]; n[t] = e, s.emit('changedata', r, t, e, o), s.emit(`changedata_${t}`, r, e, o); } },
        }), n[t] = e, s.emit('setdata', r, t, e);
      } return this;
    },
    each(t, e) { for (var i = [this.parent, null, void 0], n = 1; n < arguments.length; n++)i.push(arguments[n]); for (const s in this.list)i[1] = s, i[2] = this.list[s], t.apply(e, i); return this; },
    merge(t, e) { for (const i in void 0 === e && (e = !0), t)t.hasOwnProperty(i) && (e || !e && !this.has(i)) && this.setValue(i, t[i]); return this; },
    remove(t) { if (this._frozen) return this; if (!Array.isArray(t)) return this.removeValue(t); for (let e = 0; e < t.length; e++) this.removeValue(t[e]); return this; },
    removeValue(t) { if (this.has(t)) { const e = this.list[t]; delete this.list[t], delete this.values[t], this.events.emit('removedata', this.parent, t, e); } return this; },
    pop(t) { let e = void 0; return !this._frozen && this.has(t) && (e = this.list[t], delete this.list[t], delete this.values[t], this.events.emit('removedata', this, t, e)), e; },
    has(t) { return this.list.hasOwnProperty(t); },
    setFreeze(t) { return this._frozen = t, this; },
    reset() { for (const t in this.list) delete this.list[t], delete this.values[t]; return this._frozen = !1, this; },
    destroy() { this.reset(), this.events.off('changedata'), this.events.off('setdata'), this.events.off('removedata'), this.parent = null; },
    freeze: { get() { return this._frozen; }, set(t) { this._frozen = !!t; } },
    count: { get() { let t = 0; for (const e in this.list) void 0 !== this.list[e] && t++; return t; } },
  }); t.exports = n;
}, function (t, e) { t.exports = function (t) { return 2 * (t.width + t.height); }; }, function (t, e, i) {
  const n = i(66); const s = i(71); const r = i(40); const o = i(0); const a = i(14); const h = i(19); const l = i(9); const u = i(39); const c = new o({
    Extends: h, Mixins: [a.Depth, a.GetBounds, a.Origin, a.ScaleMode, a.Transform, a.ScrollFactor, a.Visible], initialize(t, e, i, s, r) { void 0 === s && (s = 1), void 0 === r && (r = s), h.call(this, t, 'Zone'), this.setPosition(e, i), this.width = s, this.height = r, this.blendMode = n.NORMAL, this.updateDisplayOrigin(); }, displayWidth: { get() { return this.scaleX * this.width; }, set(t) { this.scaleX = t / this.width; } }, displayHeight: { get() { return this.scaleY * this.height; }, set(t) { this.scaleY = t / this.height; } }, setSize(t, e, i) { return void 0 === i && (i = !0), this.width = t, this.height = e, i && this.input && this.input.hitArea instanceof l && (this.input.hitArea.width = t, this.input.hitArea.height = e), this; }, setDisplaySize(t, e) { return this.displayWidth = t, this.displayHeight = e, this; }, setCircleDropZone(t) { return this.setDropZone(new s(0, 0, t), r); }, setRectangleDropZone(t, e) { return this.setDropZone(new l(0, 0, t, e), u); }, setDropZone(t, e) { return void 0 === t ? this.setRectangleDropZone(this.width, this.height) : this.input || this.setInteractive(t, e, !0), this; }, setAlpha() {}, renderCanvas() {}, renderWebGL() {},
  }); t.exports = c;
}, function (t, e, i) { const n = {}; t.exports = n; const s = i(76); const r = i(33); const o = i(67); const a = i(80); const h = i(81); const l = i(1069); n.rectangle = function (t, e, i, n, a) { a = a || {}; const h = { label: 'Rectangle Body', position: { x: t, y: e }, vertices: s.fromPath(`L 0 0 L ${i} 0 L ${i} ${n} L 0 ${n}`) }; if (a.chamfer) { const l = a.chamfer; h.vertices = s.chamfer(h.vertices, l.radius, l.quality, l.qualityMin, l.qualityMax), delete a.chamfer; } return o.create(r.extend({}, h, a)); }, n.trapezoid = function (t, e, i, n, a, h) { h = h || {}; let l; const u = i * (a *= 0.5); const c = u + (1 - 2 * a) * i; const d = c + u; l = a < 0.5 ? `L 0 0 L ${u} ${-n} L ${c} ${-n} L ${d} 0` : `L 0 0 L ${c} ${-n} L ${d} 0`; const f = { label: 'Trapezoid Body', position: { x: t, y: e }, vertices: s.fromPath(l) }; if (h.chamfer) { const p = h.chamfer; f.vertices = s.chamfer(f.vertices, p.radius, p.quality, p.qualityMin, p.qualityMax), delete h.chamfer; } return o.create(r.extend({}, f, h)); }, n.circle = function (t, e, i, s, o) { s = s || {}; const a = { label: 'Circle Body', circleRadius: i }; o = o || 25; let h = Math.ceil(Math.max(10, Math.min(o, i))); return h % 2 == 1 && (h += 1), n.polygon(t, e, h, i, r.extend({}, a, s)); }, n.polygon = function (t, e, i, a, h) { if (h = h || {}, i < 3) return n.circle(t, e, a, h); for (var l = 2 * Math.PI / i, u = '', c = 0.5 * l, d = 0; d < i; d += 1) { const f = c + d * l; const p = Math.cos(f) * a; const g = Math.sin(f) * a; u += `L ${p.toFixed(3)} ${g.toFixed(3)} `; } const v = { label: 'Polygon Body', position: { x: t, y: e }, vertices: s.fromPath(u) }; if (h.chamfer) { const y = h.chamfer; v.vertices = s.chamfer(v.vertices, y.radius, y.quality, y.qualityMin, y.qualityMax), delete h.chamfer; } return o.create(r.extend({}, v, h)); }, n.fromVertices = function (t, e, i, n, u, c, d) { let f; let p; let g; let v; let y; let m; let x; let w; let b; for (n = n || {}, p = [], u = void 0 !== u && u, c = void 0 !== c ? c : 0.01, d = void 0 !== d ? d : 10, l || r.warn('Bodies.fromVertices: poly-decomp.js required. Could not decompose vertices. Fallback to convex hull.'), r.isArray(i[0]) || (i = [i]), w = 0; w < i.length; w += 1) if (v = i[w], (g = s.isConvex(v)) || !l)v = g ? s.clockwiseSort(v) : s.hull(v), p.push({ position: { x: t, y: e }, vertices: v }); else { const T = v.map((t) => [t.x, t.y]); l.makeCCW(T), !1 !== c && l.removeCollinearPoints(T, c); const S = l.quickDecomp(T); for (y = 0; y < S.length; y++) { const _ = S[y].map((t) => ({ x: t[0], y: t[1] })); d > 0 && s.area(_) < d || p.push({ position: s.centre(_), vertices: _ }); } } for (y = 0; y < p.length; y++)p[y] = o.create(r.extend(p[y], n)); if (u) for (y = 0; y < p.length; y++) { const A = p[y]; for (m = y + 1; m < p.length; m++) { const C = p[m]; if (a.overlaps(A.bounds, C.bounds)) { const M = A.vertices; const P = C.vertices; for (x = 0; x < A.vertices.length; x++) for (b = 0; b < C.vertices.length; b++) { const E = h.magnitudeSquared(h.sub(M[(x + 1) % M.length], P[b])); const k = h.magnitudeSquared(h.sub(M[x], P[(b + 1) % P.length])); E < 5 && k < 5 && (M[x].isInternal = !0, P[b].isInternal = !0); } } } } return p.length > 1 ? (f = o.create(r.extend({ parts: p.slice(0) }, n)), o.setPosition(f, { x: t, y: e }), f) : p[0]; }; }, function (t, e) {
  t.exports = function (t, e, i, n, s, r, o, a, h, l, u, c, d) {
    return {
      target: t,
      key: e,
      getEndValue: i,
      getStartValue: n,
      ease: s,
      duration: 0,
      totalDuration: 0,
      delay: 0,
      yoyo: a,
      hold: 0,
      repeat: 0,
      repeatDelay: 0,
      flipX: c,
      flipY: d,
      progress: 0,
      elapsed: 0,
      repeatCounter: 0,
      start: 0,
      current: 0,
      end: 0,
      t1: 0,
      t2: 0,
      gen: {
        delay: r, duration: o, hold: h, repeat: l, repeatDelay: u,
      },
      state: 0,
    };
  };
}, function (t, e, i) {
  const n = i(0); const s = i(13); const r = i(5); const o = i(83); const a = new n({
    initialize(t, e, i) {
      this.parent = t, this.parentIsTimeline = t.hasOwnProperty('isTimeline'), this.data = e, this.totalData = e.length, this.targets = i, this.totalTargets = i.length, this.useFrames = !1, this.timeScale = 1, this.loop = 0, this.loopDelay = 0, this.loopCounter = 0, this.completeDelay = 0, this.countdown = 0, this.offset = 0, this.calculatedOffset = 0, this.state = o.PENDING_ADD, this._pausedState = o.PENDING_ADD, this.paused = !1, this.elapsed = 0, this.totalElapsed = 0, this.duration = 0, this.progress = 0, this.totalDuration = 0, this.totalProgress = 0, this.callbacks = {
        onComplete: null, onLoop: null, onRepeat: null, onStart: null, onUpdate: null, onYoyo: null,
      }, this.callbackScope;
    },
    getValue() { return this.data[0].current; },
    setTimeScale(t) { return this.timeScale = t, this; },
    getTimeScale() { return this.timeScale; },
    isPlaying() { return this.state === o.ACTIVE; },
    isPaused() { return this.state === o.PAUSED; },
    hasTarget(t) { return this.targets.indexOf(t) !== -1; },
    updateTo(t, e, i) { for (let n = 0; n < this.totalData; n++) { const s = this.data[n]; if (s.key === t) { s.end = e, i && (s.start = s.current); break; } } return this; },
    restart() { this.state === o.REMOVED ? (this.seek(0), this.parent.makeActive(this)) : (this.stop(), this.play()); },
    calcDuration() { for (var t = 0, e = this.data, i = 0; i < this.totalData; i++) { const n = e[i]; n.t1 = n.duration + n.hold, n.yoyo && (n.t1 += n.duration), n.t2 = n.t1 + n.repeatDelay, n.totalDuration = n.delay + n.t1, n.repeat === -1 ? n.totalDuration += 999999999999 * n.t2 : n.repeat > 0 && (n.totalDuration += n.t2 * n.repeat), n.totalDuration > t && (t = n.totalDuration); } this.duration = t, this.loopCounter = this.loop === -1 ? 999999999999 : this.loop, this.loopCounter > 0 ? this.totalDuration = this.duration + this.completeDelay + (this.duration + this.loopDelay) * this.loopCounter : this.totalDuration = this.duration + this.completeDelay; },
    init() { for (let t = this.data, e = this.totalTargets, i = 0; i < this.totalData; i++) { const n = t[i]; const s = n.target; const r = n.gen; n.delay = r.delay(i, e, s), n.duration = r.duration(i, e, s), n.hold = r.hold(i, e, s), n.repeat = r.repeat(i, e, s), n.repeatDelay = r.repeatDelay(i, e, s); } return this.calcDuration(), this.progress = 0, this.totalProgress = 0, this.elapsed = 0, this.totalElapsed = 0, this.paused && !this.parentIsTimeline ? (this.state = o.PENDING_ADD, this._pausedState = o.INIT, !1) : (this.state = o.INIT, !0); },
    nextState() { if (this.loopCounter > 0) { this.elapsed = 0, this.progress = 0, this.loopCounter--; const t = this.callbacks.onLoop; t && (t.params[1] = this.targets, t.func.apply(t.scope, t.params)), this.resetTweenData(!0), this.loopDelay > 0 ? (this.countdown = this.loopDelay, this.state = o.LOOP_DELAY) : this.state = o.ACTIVE; } else if (this.completeDelay > 0) this.countdown = this.completeDelay, this.state = o.COMPLETE_DELAY; else { const e = this.callbacks.onComplete; e && (e.params[1] = this.targets, e.func.apply(e.scope, e.params)), this.state = o.PENDING_REMOVE; } },
    pause() { if (this.state !== o.PAUSED) return this.paused = !0, this._pausedState = this.state, this.state = o.PAUSED, this; },
    play(t) { if (this.state !== o.ACTIVE) { this.state !== o.PENDING_REMOVE && this.state !== o.REMOVED || (this.init(), this.parent.makeActive(this), t = !0); const e = this.callbacks.onStart; this.parentIsTimeline ? (this.resetTweenData(t), this.calculatedOffset === 0 ? (e && (e.params[1] = this.targets, e.func.apply(e.scope, e.params)), this.state = o.ACTIVE) : (this.countdown = this.calculatedOffset, this.state = o.OFFSET_DELAY)) : this.paused ? (this.paused = !1, this.parent.makeActive(this)) : (this.resetTweenData(t), this.state = o.ACTIVE, e && (e.params[1] = this.targets, e.func.apply(e.scope, e.params)), this.parent.makeActive(this)); } },
    resetTweenData(t) { for (let e = this.data, i = 0; i < this.totalData; i++) { const n = e[i]; n.progress = 0, n.elapsed = 0, n.repeatCounter = n.repeat === -1 ? 999999999999 : n.repeat, t ? (n.start = n.getStartValue(n.target, n.key, n.start), n.end = n.getEndValue(n.target, n.key, n.end), n.current = n.start, n.state = o.PLAYING_FORWARD) : n.delay > 0 ? (n.elapsed = n.delay, n.state = o.DELAY) : n.state = o.PENDING_RENDER; } },
    resume() { return this.state === o.PAUSED ? (this.paused = !1, this.state = this._pausedState) : this.play(), this; },
    seek(t) { for (let e = this.data, i = 0; i < this.totalData; i++) { let n = this.totalDuration * t; const s = e[i]; let r = 0; let o = 0; n <= s.delay ? (r = 0, o = 0) : n >= s.totalDuration ? (r = 1, o = s.duration) : n > s.delay && n <= s.t1 ? (r = (n = Math.max(0, n - s.delay)) / s.t1, o = s.duration * r) : n > s.t1 && n < s.totalDuration && (n -= s.delay, (n = (n -= s.t1) / s.t2 % 1 * s.t2) > s.repeatDelay && (r = n / s.t1, o = s.duration * r)), s.progress = r, s.elapsed = o; const a = s.ease(s.progress); s.current = s.start + (s.end - s.start) * a, s.target[s.key] = s.current; } },
    setCallback(t, e, i, n) { return this.callbacks[t] = { func: e, scope: n, params: i }, this; },
    complete(t) { if (void 0 === t && (t = 0), t) this.countdown = t, this.state = o.COMPLETE_DELAY; else { const e = this.callbacks.onComplete; e && (e.params[1] = this.targets, e.func.apply(e.scope, e.params)), this.state = o.PENDING_REMOVE; } },
    stop(t) { this.state === o.ACTIVE && void 0 !== t && this.seek(t), this.state !== o.REMOVED && (this.state !== o.PAUSED && this.state !== o.PENDING_ADD || (this.parent._destroy.push(this), this.parent._toProcess++), this.state = o.PENDING_REMOVE); },
    update(t, e) { if (this.state === o.PAUSED) return !1; switch (this.useFrames && (e = 1 * this.parent.timeScale), e *= this.timeScale, this.elapsed += e, this.progress = Math.min(this.elapsed / this.duration, 1), this.totalElapsed += e, this.totalProgress = Math.min(this.totalElapsed / this.totalDuration, 1), this.state) { case o.ACTIVE: for (var i = !1, n = 0; n < this.totalData; n++) this.updateTweenData(this, this.data[n], e) && (i = !0); i || this.nextState(); break; case o.LOOP_DELAY: this.countdown -= e, this.countdown <= 0 && (this.state = o.ACTIVE); break; case o.OFFSET_DELAY: if (this.countdown -= e, this.countdown <= 0) { const s = this.callbacks.onStart; s && (s.params[1] = this.targets, s.func.apply(s.scope, s.params)), this.state = o.ACTIVE; } break; case o.COMPLETE_DELAY: if (this.countdown -= e, this.countdown <= 0) { const r = this.callbacks.onComplete; r && r.func.apply(r.scope, r.params), this.state = o.PENDING_REMOVE; } } return this.state === o.PENDING_REMOVE; },
    setStateFromEnd(t, e, i) { if (e.yoyo) { e.elapsed = i, e.progress = i / e.duration, e.flipX && e.target.toggleFlipX(), e.flipY && e.target.toggleFlipY(); const n = t.callbacks.onYoyo; return n && (n.params[1] = e.target, n.func.apply(n.scope, n.params)), e.start = e.getStartValue(e.target, e.key, e.start), o.PLAYING_BACKWARD; } if (e.repeatCounter > 0) { e.repeatCounter--, e.elapsed = i, e.progress = i / e.duration, e.flipX && e.target.toggleFlipX(), e.flipY && e.target.toggleFlipY(); const s = t.callbacks.onRepeat; return s && (s.params[1] = e.target, s.func.apply(s.scope, s.params)), e.start = e.getStartValue(e.target, e.key, e.start), e.end = e.getEndValue(e.target, e.key, e.start), e.repeatDelay > 0 ? (e.elapsed = e.repeatDelay - i, e.current = e.start, e.target[e.key] = e.current, o.REPEAT_DELAY) : o.PLAYING_FORWARD; } return o.COMPLETE; },
    setStateFromStart(t, e, i) { if (e.repeatCounter > 0) { e.repeatCounter--, e.elapsed = i, e.progress = i / e.duration, e.flipX && e.target.toggleFlipX(), e.flipY && e.target.toggleFlipY(); const n = t.callbacks.onRepeat; return n && (n.params[1] = e.target, n.func.apply(n.scope, n.params)), e.end = e.getEndValue(e.target, e.key, e.start), e.repeatDelay > 0 ? (e.elapsed = e.repeatDelay - i, e.current = e.start, e.target[e.key] = e.current, o.REPEAT_DELAY) : o.PLAYING_FORWARD; } return o.COMPLETE; },
    updateTweenData(t, e, i) { switch (e.state) { case o.PLAYING_FORWARD: case o.PLAYING_BACKWARD: if (!e.target) { e.state = o.COMPLETE; break; } var n = e.elapsed; var s = e.duration; var r = 0; (n += i) > s && (r = n - s, n = s); var a; var h = e.state === o.PLAYING_FORWARD; var l = n / s; a = h ? e.ease(l) : e.ease(1 - l), e.current = e.start + (e.end - e.start) * a, e.target[e.key] = e.current, e.elapsed = n, e.progress = l; var u = t.callbacks.onUpdate; u && (u.params[1] = e.target, u.func.apply(u.scope, u.params)), l === 1 && (h ? e.hold > 0 ? (e.elapsed = e.hold - r, e.state = o.HOLD_DELAY) : e.state = this.setStateFromEnd(t, e, r) : e.state = this.setStateFromStart(t, e, r)); break; case o.DELAY: e.elapsed -= i, e.elapsed <= 0 && (e.elapsed = Math.abs(e.elapsed), e.state = o.PENDING_RENDER); break; case o.REPEAT_DELAY: e.elapsed -= i, e.elapsed <= 0 && (e.elapsed = Math.abs(e.elapsed), e.state = o.PLAYING_FORWARD); break; case o.HOLD_DELAY: e.elapsed -= i, e.elapsed <= 0 && (e.state = this.setStateFromEnd(t, e, Math.abs(e.elapsed))); break; case o.PENDING_RENDER: e.target ? (e.start = e.getStartValue(e.target, e.key, e.target[e.key]), e.end = e.getEndValue(e.target, e.key, e.start), e.current = e.start, e.target[e.key] = e.start, e.state = o.PLAYING_FORWARD) : e.state = o.COMPLETE; } return e.state !== o.COMPLETE; },
  }); a.TYPES = ['onComplete', 'onLoop', 'onRepeat', 'onStart', 'onUpdate', 'onYoyo'], r.register('tween', function (t) { return this.scene.sys.tweens.add(t); }), s.register('tween', function (t) { return this.scene.sys.tweens.create(t); }), t.exports = a;
}, function (t, e) {
  t.exports = {
    targets: null, delay: 0, duration: 1e3, ease: 'Power0', easeParams: null, hold: 0, repeat: 0, repeatDelay: 0, yoyo: !1, flipX: !1, flipY: !1,
  };
}, function (t, e) { function i(t) { return !!t.getStart && typeof t.getStart === 'function'; } function n(t) { return !!t.getEnd && typeof t.getEnd === 'function'; } var s = function (t, e) { let r; let o; let a = function (t, e, i) { return i; }; let h = function (t, e, i) { return i; }; const l = typeof e; if (l === 'number')a = function () { return e; }; else if (l === 'string') { const u = e[0]; const c = parseFloat(e.substr(2)); switch (u) { case '+': a = function (t, e, i) { return i + c; }; break; case '-': a = function (t, e, i) { return i - c; }; break; case '*': a = function (t, e, i) { return i * c; }; break; case '/': a = function (t, e, i) { return i / c; }; break; default: a = function () { return parseFloat(e); }; } } else l === 'function' ? a = e : l === 'object' && (i(o = e) || n(o)) ? (n(e) && (a = e.getEnd), i(e) && (h = e.getStart)) : e.hasOwnProperty('value') && (r = s(t, e.value)); return r || (r = { getEnd: a, getStart: h }), r; }; t.exports = s; }, function (t, e, i) { const n = i(4); t.exports = function (t) { let e = n(t, 'targets', null); return e === null ? e : (typeof e === 'function' && (e = e.call()), Array.isArray(e) || (e = [e]), e); }; }, function (t, e, i) {
  const n = i(29); const s = i(77); const r = i(217); const o = i(209); t.exports = function (t, e, i, a, h, l, u, c) {
    void 0 === i && (i = 32), void 0 === a && (a = 32), void 0 === h && (h = 10), void 0 === l && (l = 10), void 0 === c && (c = !1); let d = null; if (Array.isArray(u))d = r(void 0 !== e ? e : 'map', n.ARRAY_2D, u, i, a, c); else if (void 0 !== e) { const f = t.cache.tilemap.get(e); f ? d = r(e, f.format, f.data, i, a, c) : console.warn(`No map data found for key ${e}`); } return d === null && (d = new s({
      tileWidth: i, tileHeight: a, width: h, height: l,
    })), new o(t, d);
  };
}, function (t, e, i) {
  const n = i(29); const s = i(78); const r = i(77); const o = i(55); t.exports = function (t, e, i, a, h) {
    for (var l = new s({ tileWidth: i, tileHeight: a }), u = new r({
        name: t, tileWidth: i, tileHeight: a, format: n.ARRAY_2D, layers: [l],
      }), c = [], d = e.length, f = 0, p = 0; p < e.length; p++) { c[p] = []; for (var g = e[p], v = 0; v < g.length; v++) { const y = parseInt(g[v], 10); isNaN(y) || y === -1 ? c[p][v] = h ? null : new o(l, -1, v, p, i, a) : c[p][v] = new o(l, y, v, p, i, a); }f === 0 && (f = g.length); } return u.width = l.width = f, u.height = l.height = d, u.widthInPixels = l.widthInPixels = f * i, u.heightInPixels = l.heightInPixels = d * a, l.data = c, u;
  };
}, function (t, e) { t.exports = function (t, e, i) { const n = i.collideIndexes.indexOf(t); e && n === -1 ? i.collideIndexes.push(t) : e || n === -1 || i.collideIndexes.splice(n, 1); }; }, function (t, e, i) { const n = i(55); const s = i(79); const r = i(136); const o = i(56); t.exports = function (t, e, i, a, h) { if (!s(e, i, h)) return null; void 0 === a && (a = !0); const l = h.data[i][e]; const u = l && l.collides; if (t instanceof n)h.data[i][e] === null && (h.data[i][e] = new n(h, t.index, e, i, t.width, t.height)), h.data[i][e].copy(t); else { const c = t; h.data[i][e] === null ? h.data[i][e] = new n(h, c, e, i, h.tileWidth, h.tileHeight) : h.data[i][e].index = c; } const d = h.data[i][e]; const f = h.collideIndexes.indexOf(d.index) !== -1; return o(d, f), a && u !== d.collides && r(e, i, h), d; }; }, function (t, e, i) { const n = i(102); t.exports = function (t, e, i) { const s = n(t, e, !0, i); const r = n(t, e - 1, !0, i); const o = n(t, e + 1, !0, i); const a = n(t - 1, e, !0, i); const h = n(t + 1, e, !0, i); const l = s && s.collides; return l && (s.faceTop = !0, s.faceBottom = !0, s.faceLeft = !0, s.faceRight = !0), r && r.collides && (l && (s.faceTop = !1), r.faceBottom = !l), o && o.collides && (l && (s.faceBottom = !1), o.faceTop = !l), a && a.collides && (l && (s.faceLeft = !1), a.faceRight = !l), h && h.collides && (l && (s.faceRight = !1), h.faceLeft = !l), s && !s.collides && s.resetFaces(), s; }; }, function (t, e, i) {
  const n = {}; t.exports = n; const s = i(195); const r = i(33); const o = i(80); const a = i(67); n.create = function (t) {
    return r.extend({
      id: r.nextId(), type: 'composite', parent: null, isModified: !1, bodies: [], constraints: [], composites: [], label: 'Composite', plugin: {},
    }, t);
  }, n.setModified = function (t, e, i, s) { if (t.isModified = e, i && t.parent && n.setModified(t.parent, e, i, s), s) for (let r = 0; r < t.composites.length; r++) { const o = t.composites[r]; n.setModified(o, e, i, s); } }, n.add = function (t, e) { const i = [].concat(e); s.trigger(t, 'beforeAdd', { object: e }); for (let o = 0; o < i.length; o++) { const a = i[o]; switch (a.type) { case 'body': if (a.parent !== a) { r.warn('Composite.add: skipped adding a compound body part (you must add its parent instead)'); break; }n.addBody(t, a); break; case 'constraint': n.addConstraint(t, a); break; case 'composite': n.addComposite(t, a); break; case 'mouseConstraint': n.addConstraint(t, a.constraint); } } return s.trigger(t, 'afterAdd', { object: e }), t; }, n.remove = function (t, e, i) { const r = [].concat(e); s.trigger(t, 'beforeRemove', { object: e }); for (let o = 0; o < r.length; o++) { const a = r[o]; switch (a.type) { case 'body': n.removeBody(t, a, i); break; case 'constraint': n.removeConstraint(t, a, i); break; case 'composite': n.removeComposite(t, a, i); break; case 'mouseConstraint': n.removeConstraint(t, a.constraint); } } return s.trigger(t, 'afterRemove', { object: e }), t; }, n.addComposite = function (t, e) { return t.composites.push(e), e.parent = t, n.setModified(t, !0, !0, !1), t; }, n.removeComposite = function (t, e, i) { const s = t.composites.indexOf(e); if (s !== -1 && (n.removeCompositeAt(t, s), n.setModified(t, !0, !0, !1)), i) for (let r = 0; r < t.composites.length; r++)n.removeComposite(t.composites[r], e, !0); return t; }, n.removeCompositeAt = function (t, e) { return t.composites.splice(e, 1), n.setModified(t, !0, !0, !1), t; }, n.addBody = function (t, e) { return t.bodies.push(e), n.setModified(t, !0, !0, !1), t; }, n.removeBody = function (t, e, i) { const s = t.bodies.indexOf(e); if (s !== -1 && (n.removeBodyAt(t, s), n.setModified(t, !0, !0, !1)), i) for (let r = 0; r < t.composites.length; r++)n.removeBody(t.composites[r], e, !0); return t; }, n.removeBodyAt = function (t, e) { return t.bodies.splice(e, 1), n.setModified(t, !0, !0, !1), t; }, n.addConstraint = function (t, e) { return t.constraints.push(e), n.setModified(t, !0, !0, !1), t; }, n.removeConstraint = function (t, e, i) { const s = t.constraints.indexOf(e); if (s !== -1 && n.removeConstraintAt(t, s), i) for (let r = 0; r < t.composites.length; r++)n.removeConstraint(t.composites[r], e, !0); return t; }, n.removeConstraintAt = function (t, e) { return t.constraints.splice(e, 1), n.setModified(t, !0, !0, !1), t; }, n.clear = function (t, e, i) { if (i) for (let s = 0; s < t.composites.length; s++)n.clear(t.composites[s], e, !0); return e ? t.bodies = t.bodies.filter((t) => t.isStatic) : t.bodies.length = 0, t.constraints.length = 0, t.composites.length = 0, n.setModified(t, !0, !0, !1), t; }, n.allBodies = function (t) { for (var e = [].concat(t.bodies), i = 0; i < t.composites.length; i++)e = e.concat(n.allBodies(t.composites[i])); return e; }, n.allConstraints = function (t) { for (var e = [].concat(t.constraints), i = 0; i < t.composites.length; i++)e = e.concat(n.allConstraints(t.composites[i])); return e; }, n.allComposites = function (t) { for (var e = [].concat(t.composites), i = 0; i < t.composites.length; i++)e = e.concat(n.allComposites(t.composites[i])); return e; }, n.get = function (t, e, i) { let s; let r; switch (i) { case 'body': s = n.allBodies(t); break; case 'constraint': s = n.allConstraints(t); break; case 'composite': s = n.allComposites(t).concat(t); } return s ? (r = s.filter((t) => t.id.toString() === e.toString())).length === 0 ? null : r[0] : null; }, n.move = function (t, e, i) { return n.remove(t, e), n.add(i, e), t; }, n.rebase = function (t) { for (let e = n.allBodies(t).concat(n.allConstraints(t)).concat(n.allComposites(t)), i = 0; i < e.length; i++)e[i].id = r.nextId(); return n.setModified(t, !0, !0, !1), t; }, n.translate = function (t, e, i) { for (let s = i ? n.allBodies(t) : t.bodies, r = 0; r < s.length; r++)a.translate(s[r], e); return n.setModified(t, !0, !0, !1), t; }, n.rotate = function (t, e, i, s) { for (let r = Math.cos(e), o = Math.sin(e), h = s ? n.allBodies(t) : t.bodies, l = 0; l < h.length; l++) { const u = h[l]; const c = u.position.x - i.x; const d = u.position.y - i.y; a.setPosition(u, { x: i.x + (c * r - d * o), y: i.y + (c * o + d * r) }), a.rotate(u, e); } return n.setModified(t, !0, !0, !1), t; }, n.scale = function (t, e, i, s, r) { for (let o = r ? n.allBodies(t) : t.bodies, h = 0; h < o.length; h++) { const l = o[h]; const u = l.position.x - s.x; const c = l.position.y - s.y; a.setPosition(l, { x: s.x + u * e, y: s.y + c * i }), a.scale(l, e, i); } return n.setModified(t, !0, !0, !1), t; }, n.bounds = function (t) { for (var e = n.allBodies(t), i = [], s = 0; s < e.length; s += 1) { const r = e[s]; i.push(r.bounds.min, r.bounds.max); } return o.create(i); };
}, function (t, e, i) {
  var n = new (i(0))({
    initialize(t, e, i) { this.x = 0, this.y = 0, this.z = 0, typeof t === 'object' ? (this.x = t.x || 0, this.y = t.y || 0, this.z = t.z || 0) : (this.x = t || 0, this.y = e || 0, this.z = i || 0); }, up() { return this.x = 0, this.y = 1, this.z = 0, this; }, clone() { return new n(this.x, this.y, this.z); }, crossVectors(t, e) { const i = t.x; const n = t.y; const s = t.z; const r = e.x; const o = e.y; const a = e.z; return this.x = n * a - s * o, this.y = s * r - i * a, this.z = i * o - n * r, this; }, equals(t) { return this.x === t.x && this.y === t.y && this.z === t.z; }, copy(t) { return this.x = t.x, this.y = t.y, this.z = t.z || 0, this; }, set(t, e, i) { return typeof t === 'object' ? (this.x = t.x || 0, this.y = t.y || 0, this.z = t.z || 0) : (this.x = t || 0, this.y = e || 0, this.z = i || 0), this; }, add(t) { return this.x += t.x, this.y += t.y, this.z += t.z || 0, this; }, subtract(t) { return this.x -= t.x, this.y -= t.y, this.z -= t.z || 0, this; }, multiply(t) { return this.x *= t.x, this.y *= t.y, this.z *= t.z || 1, this; }, scale(t) { return isFinite(t) ? (this.x *= t, this.y *= t, this.z *= t) : (this.x = 0, this.y = 0, this.z = 0), this; }, divide(t) { return this.x /= t.x, this.y /= t.y, this.z /= t.z || 1, this; }, negate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this; }, distance(t) { const e = t.x - this.x; const i = t.y - this.y; const n = t.z - this.z || 0; return Math.sqrt(e * e + i * i + n * n); }, distanceSq(t) { const e = t.x - this.x; const i = t.y - this.y; const n = t.z - this.z || 0; return e * e + i * i + n * n; }, length() { const t = this.x; const e = this.y; const i = this.z; return Math.sqrt(t * t + e * e + i * i); }, lengthSq() { const t = this.x; const e = this.y; const i = this.z; return t * t + e * e + i * i; }, normalize() { const t = this.x; const e = this.y; const i = this.z; let n = t * t + e * e + i * i; return n > 0 && (n = 1 / Math.sqrt(n), this.x = t * n, this.y = e * n, this.z = i * n), this; }, dot(t) { return this.x * t.x + this.y * t.y + this.z * t.z; }, cross(t) { const e = this.x; const i = this.y; const n = this.z; const s = t.x; const r = t.y; const o = t.z; return this.x = i * o - n * r, this.y = n * s - e * o, this.z = e * r - i * s, this; }, lerp(t, e) { void 0 === e && (e = 0); const i = this.x; const n = this.y; const s = this.z; return this.x = i + e * (t.x - i), this.y = n + e * (t.y - n), this.z = s + e * (t.z - s), this; }, transformMat3(t) { const e = this.x; const i = this.y; const n = this.z; const s = t.val; return this.x = e * s[0] + i * s[3] + n * s[6], this.y = e * s[1] + i * s[4] + n * s[7], this.z = e * s[2] + i * s[5] + n * s[8], this; }, transformMat4(t) { const e = this.x; const i = this.y; const n = this.z; const s = t.val; return this.x = s[0] * e + s[4] * i + s[8] * n + s[12], this.y = s[1] * e + s[5] * i + s[9] * n + s[13], this.z = s[2] * e + s[6] * i + s[10] * n + s[14], this; }, transformCoordinates(t) { const e = this.x; const i = this.y; const n = this.z; const s = t.val; const r = e * s[0] + i * s[4] + n * s[8] + s[12]; const o = e * s[1] + i * s[5] + n * s[9] + s[13]; const a = e * s[2] + i * s[6] + n * s[10] + s[14]; const h = e * s[3] + i * s[7] + n * s[11] + s[15]; return this.x = r / h, this.y = o / h, this.z = a / h, this; }, transformQuat(t) { const e = this.x; const i = this.y; const n = this.z; const s = t.x; const r = t.y; const o = t.z; const a = t.w; const h = a * e + r * n - o * i; const l = a * i + o * e - s * n; const u = a * n + s * i - r * e; const c = -s * e - r * i - o * n; return this.x = h * a + c * -s + l * -o - u * -r, this.y = l * a + c * -r + u * -s - h * -o, this.z = u * a + c * -o + h * -r - l * -s, this; }, project(t) { const e = this.x; const i = this.y; const n = this.z; const s = t.val; const r = s[0]; const o = s[1]; const a = s[2]; const h = s[3]; const l = s[4]; const u = s[5]; const c = s[6]; const d = s[7]; const f = s[8]; const p = s[9]; const g = s[10]; const v = s[11]; const y = s[12]; const m = s[13]; const x = s[14]; const w = 1 / (e * h + i * d + n * v + s[15]); return this.x = (e * r + i * l + n * f + y) * w, this.y = (e * o + i * u + n * p + m) * w, this.z = (e * a + i * c + n * g + x) * w, this; }, unproject(t, e) { const i = t.x; const n = t.y; const s = t.z; const r = t.w; const o = this.x - i; const a = r - this.y - 1 - n; const h = this.z; return this.x = 2 * o / s - 1, this.y = 2 * a / r - 1, this.z = 2 * h - 1, this.project(e); }, reset() { return this.x = 0, this.y = 0, this.z = 0, this; },
  }); t.exports = n;
}, function (t, e, i) {
  const n = i(0); const s = i(18); const r = i(21); const o = i(7); const a = i(2); const h = i(8); const l = i(343); const u = new n({
    Extends: r,
    initialize(t, e, i, n) {
      let s = 'xml'; if (h(e)) { const o = e; e = a(o, 'key'), i = a(o, 'url'), n = a(o, 'xhrSettings'), s = a(o, 'extension', s); } const l = {
        type: 'xml', cache: t.cacheManager.xml, extension: s, responseType: 'text', key: e, url: i, xhrSettings: n,
      }; r.call(this, t, l);
    },
    onProcess() { this.state = s.FILE_PROCESSING, this.data = l(this.xhrLoader.responseText), this.data ? this.onProcessComplete() : (console.warn(`Invalid XMLFile: ${this.key}`), this.onProcessError()); },
  }); o.register('xml', function (t, e, i) { if (Array.isArray(t)) for (let n = 0; n < t.length; n++) this.addFile(new u(this, t[n])); else this.addFile(new u(this, t, e, i)); return this; }), t.exports = u;
}, function (t, e, i) { const n = i(20); const s = i(105); t.exports = function (t, e) { const i = void 0 === t ? s() : n({}, t); if (e) for (const r in e) void 0 !== e[r] && (i[r] = e[r]); return i; }; }, function (t, e) { t.exports = function (t, e) { return !!t.url && (t.url.match(/^(?:blob:|data:|http:\/\/|https:\/\/|\/\/)/) ? t.url : e + t.url); }; }, function (t, e) { t.exports = function (t, e, i, n) { return void 0 === i && (i = 0), e === 0 ? t : (t -= i, t = e * Math.floor(t / e), n ? (i + t) / e : i + t); }; }, function (t, e) {
  t.exports = {
    BACKSPACE: 8, TAB: 9, ENTER: 13, SHIFT: 16, CTRL: 17, ALT: 18, PAUSE: 19, CAPS_LOCK: 20, ESC: 27, SPACE: 32, PAGE_UP: 33, PAGE_DOWN: 34, END: 35, HOME: 36, LEFT: 37, UP: 38, RIGHT: 39, DOWN: 40, PRINT_SCREEN: 42, INSERT: 45, DELETE: 46, ZERO: 48, ONE: 49, TWO: 50, THREE: 51, FOUR: 52, FIVE: 53, SIX: 54, SEVEN: 55, EIGHT: 56, NINE: 57, NUMPAD_ZERO: 96, NUMPAD_ONE: 97, NUMPAD_TWO: 98, NUMPAD_THREE: 99, NUMPAD_FOUR: 100, NUMPAD_FIVE: 101, NUMPAD_SIX: 102, NUMPAD_SEVEN: 103, NUMPAD_EIGHT: 104, NUMPAD_NINE: 105, A: 65, B: 66, C: 67, D: 68, E: 69, F: 70, G: 71, H: 72, I: 73, J: 74, K: 75, L: 76, M: 77, N: 78, O: 79, P: 80, Q: 81, R: 82, S: 83, T: 84, U: 85, V: 86, W: 87, X: 88, Y: 89, Z: 90, F1: 112, F2: 113, F3: 114, F4: 115, F5: 116, F6: 117, F7: 118, F8: 119, F9: 120, F10: 121, F11: 122, F12: 123, SEMICOLON: 186, PLUS: 187, COMMA: 188, MINUS: 189, PERIOD: 190, FORWARD_SLASH: 191, BACK_SLASH: 220, QUOTES: 222, BACKTICK: 192, OPEN_BRACKET: 219, CLOSED_BRACKET: 221,
  };
}, function (t, e) { t.exports = function (t, e, i, n) { const s = Math.cos(n); const r = Math.sin(n); let o = t.x1 - e; let a = t.y1 - i; return t.x1 = o * s - a * r + e, t.y1 = o * r + a * s + i, o = t.x2 - e, a = t.y2 - i, t.x2 = o * s - a * r + e, t.y2 = o * r + a * s + i, o = t.x3 - e, a = t.y3 - i, t.x3 = o * s - a * r + e, t.y3 = o * r + a * s + i, t; }; }, function (t, e) { t.exports = function (t) { return t.height === 0 ? NaN : t.width / t.height; }; }, function (t, e) { t.exports = function (t, e, i, n) { const s = Math.cos(n); const r = Math.sin(n); let o = t.x1 - e; let a = t.y1 - i; return t.x1 = o * s - a * r + e, t.y1 = o * r + a * s + i, o = t.x2 - e, a = t.y2 - i, t.x2 = o * s - a * r + e, t.y2 = o * r + a * s + i, t; }; }, function (t, e) { t.exports = function (t, e, i, n) { void 0 === i && (i = !1), void 0 === n && (n = []); for (var s, r, o, a, h, l, u = t.x3 - t.x1, c = t.y3 - t.y1, d = t.x2 - t.x1, f = t.y2 - t.y1, p = u * u + c * c, g = u * d + c * f, v = d * d + f * f, y = p * v - g * g, m = y === 0 ? 0 : 1 / y, x = t.x1, w = t.y1, b = 0; b < e.length && (r = (p * (l = d * (o = e[b].x - x) + f * (a = e[b].y - w)) - g * (h = u * o + c * a)) * m, !((s = (v * h - g * l) * m) >= 0 && r >= 0 && s + r < 1 && (n.push({ x: e[b].x, y: e[b].y }), i))); b++);return n; }; }, function (t, e) { t.exports = function (t, e) { return !(t.width <= 0 || t.height <= 0 || e.width <= 0 || e.height <= 0 || t.right < e.x || t.bottom < e.y || t.x > e.right || t.y > e.bottom); }; }, function (t, e, i) {
  const n = i(0); const s = i(108); const r = new n({
    Extends: s, initialize(t, e, i, n, r) { s.call(this, t, e, i, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0], [16777215, 16777215, 16777215, 16777215, 16777215, 16777215], [1, 1, 1, 1, 1, 1], n, r), this.resetPosition(); }, setFrame(t) { return this.frame = this.texture.get(t), this.frame.cutWidth && this.frame.cutHeight ? this.renderFlags |= 8 : this.renderFlags &= -9, t = this.frame, this.uv[0] = t.u0, this.uv[1] = t.v0, this.uv[2] = t.u0, this.uv[3] = t.v1, this.uv[4] = t.u1, this.uv[5] = t.v1, this.uv[6] = t.u0, this.uv[7] = t.v0, this.uv[8] = t.u1, this.uv[9] = t.v1, this.uv[10] = t.u1, this.uv[11] = t.v0, this; }, topLeftX: { get() { return this.x + this.vertices[0]; }, set(t) { this.vertices[0] = t - this.x, this.vertices[6] = t - this.x; } }, topLeftY: { get() { return this.y + this.vertices[1]; }, set(t) { this.vertices[1] = t - this.y, this.vertices[7] = t - this.y; } }, topRightX: { get() { return this.x + this.vertices[10]; }, set(t) { this.vertices[10] = t - this.x; } }, topRightY: { get() { return this.y + this.vertices[11]; }, set(t) { this.vertices[11] = t - this.y; } }, bottomLeftX: { get() { return this.x + this.vertices[2]; }, set(t) { this.vertices[2] = t - this.x; } }, bottomLeftY: { get() { return this.y + this.vertices[3]; }, set(t) { this.vertices[3] = t - this.y; } }, bottomRightX: { get() { return this.x + this.vertices[4]; }, set(t) { this.vertices[4] = t - this.x, this.vertices[8] = t - this.x; } }, bottomRightY: { get() { return this.y + this.vertices[5]; }, set(t) { this.vertices[5] = t - this.y, this.vertices[9] = t - this.y; } }, topLeftAlpha: { get() { return this.alphas[0]; }, set(t) { this.alphas[0] = t, this.alphas[3] = t; } }, topRightAlpha: { get() { return this.alphas[5]; }, set(t) { this.alphas[5] = t; } }, bottomLeftAlpha: { get() { return this.alphas[1]; }, set(t) { this.alphas[1] = t; } }, bottomRightAlpha: { get() { return this.alphas[2]; }, set(t) { this.alphas[2] = t, this.alphas[4] = t; } }, topLeftColor: { get() { return this.colors[0]; }, set(t) { this.colors[0] = t, this.colors[3] = t; } }, topRightColor: { get() { return this.colors[5]; }, set(t) { this.colors[5] = t; } }, bottomLeftColor: { get() { return this.colors[1]; }, set(t) { this.colors[1] = t; } }, bottomRightColor: { get() { return this.colors[2]; }, set(t) { this.colors[2] = t, this.colors[4] = t; } }, setTopLeft(t, e) { return this.topLeftX = t, this.topLeftY = e, this; }, setTopRight(t, e) { return this.topRightX = t, this.topRightY = e, this; }, setBottomLeft(t, e) { return this.bottomLeftX = t, this.bottomLeftY = e, this; }, setBottomRight(t, e) { return this.bottomRightX = t, this.bottomRightY = e, this; }, resetPosition() { const t = this.x; const e = this.y; const i = Math.floor(this.width / 2); const n = Math.floor(this.height / 2); return this.setTopLeft(t - i, e - n), this.setTopRight(t + i, e - n), this.setBottomLeft(t - i, e + n), this.setBottomRight(t + i, e + n), this; }, resetAlpha() { const t = this.alphas; return t[0] = 1, t[1] = 1, t[2] = 1, t[3] = 1, t[4] = 1, t[5] = 1, this; }, resetColors() { const t = this.colors; return t[0] = 16777215, t[1] = 16777215, t[2] = 16777215, t[3] = 16777215, t[4] = 16777215, t[5] = 16777215, this; }, reset() { return this.resetPosition(), this.resetAlpha(), this.resetColors(); },
  }); t.exports = r;
}, function (t, e) { t.exports = function (t, e, i) { for (var n = !1, s = -1, r = t.points.length - 1; ++s < t.points.length; r = s) { const o = t.points[s].x; const a = t.points[s].y; const h = t.points[r].x; const l = t.points[r].y; (a <= i && i < l || l <= i && i < a) && e < (h - o) * (i - a) / (l - a) + o && (n = !n); } return n; }; }, function (t, e, i) {
  const n = i(0); const s = i(150); const r = i(284); const o = new n({
    initialize(t) { this.area = 0, this.points = [], t && this.setTo(t); }, contains(t, e) { return s(this, t, e); }, setTo(t) { if (this.area = 0, this.points = [], typeof t === 'string' && (t = t.split(' ')), !Array.isArray(t)) return this; for (var e, i = Number.MAX_VALUE, n = 0; n < t.length; n++)e = { x: 0, y: 0 }, typeof t[n] === 'number' || typeof t[n] === 'string' ? (e.x = parseFloat(t[n]), e.y = parseFloat(t[n + 1]), n++) : Array.isArray(t[n]) ? (e.x = t[n][0], e.y = t[n][1]) : (e.x = t[n].x, e.y = t[n].y), this.points.push(e), e.y < i && (i = e.y); return this.calculateArea(i), this; }, calculateArea() { if (this.points.length < 3) return this.area = 0, this.area; for (var t, e, i = 0, n = 0; n < this.points.length - 1; n++)t = this.points[n], i += ((e = this.points[n + 1]).x - t.x) * (t.y + e.y); return t = this.points[0], e = this.points[this.points.length - 1], i += (t.x - e.x) * (e.y + t.y), this.area = 0.5 * -i, this.area; }, getPoints(t, e, i) { return r(this, t, e, i); },
  }); t.exports = o;
}, function (t, e, i) {
  const n = i(24); const s = i(0); const r = i(14); const o = i(26); const a = i(19); const h = i(294); const l = i(120); const u = i(805); const c = i(3); const d = new s({
    Extends: a, Mixins: [r.Alpha, r.BlendMode, r.ComputedSize, r.Crop, r.Depth, r.Flip, r.GetBounds, r.Mask, r.Origin, r.Pipeline, r.ScaleMode, r.ScrollFactor, r.Tint, r.Transform, r.Visible, u], initialize(t, e, i, s, r, l, u) { const d = t.sys.game.renderer; a.call(this, t, 'TileSprite'); const f = t.sys.textures.get(l); const p = f.get(u); s && r ? (s = Math.floor(s), r = Math.floor(r)) : (s = p.width, r = p.height), this._tilePosition = new c(), this._tileScale = new c(1, 1), this.dirty = !1, this.renderer = d, this.canvas = n.create(this, s, r), this.context = this.canvas.getContext('2d'), this.displayTexture = f, this.displayFrame = p, this._crop = this.resetCropObject(), this.texture = t.sys.textures.addCanvas(null, this.canvas, !0), this.frame = this.texture.get(), this.potWidth = h(p.width), this.potHeight = h(p.height), this.fillCanvas = n.create2D(this, this.potWidth, this.potHeight), this.fillContext = this.fillCanvas.getContext('2d'), this.fillPattern = null, this.setPosition(e, i), this.setSize(s, r), this.setFrame(u), this.setOriginFromFrame(), this.initPipeline(), t.sys.game.config.renderType === o.WEBGL && t.sys.game.renderer.onContextRestored(function (t) { const e = t.gl; this.dirty = !0, this.fillPattern = null, this.fillPattern = t.createTexture2D(0, e.LINEAR, e.LINEAR, e.REPEAT, e.REPEAT, e.RGBA, this.fillCanvas, this.potWidth, this.potHeight); }, this); }, setTexture(t, e) { return this.displayTexture = this.scene.sys.textures.get(t), this.setFrame(e); }, setFrame(t) { return this.displayFrame = this.displayTexture.get(t), this.displayFrame.cutWidth && this.displayFrame.cutHeight ? this.renderFlags |= 8 : this.renderFlags &= -9, this.dirty = !0, this.updateTileTexture(), this; }, setTilePosition(t, e) { return void 0 !== t && (this.tilePositionX = t), void 0 !== e && (this.tilePositionY = e), this; }, setTileScale(t, e) { return void 0 !== t && (this.tileScaleX = t), void 0 !== e && (this.tileScaleY = e), this; }, updateTileTexture() { if (this.dirty) { const t = this.displayFrame; const e = this.fillContext; const i = this.fillCanvas; let n = this.potWidth; let s = this.potHeight; this.renderer.gl || (n = t.cutWidth, s = t.cutHeight), e.clearRect(0, 0, n, s), i.width = n, i.height = s, e.drawImage(t.source.image, t.cutX, t.cutY, t.cutWidth, t.cutHeight, 0, 0, n, s), this.renderer.gl ? this.fillPattern = this.renderer.canvasToTexture(i, this.fillPattern) : this.fillPattern = e.createPattern(i, 'repeat'), this.updateCanvas(), this.dirty = !1; } }, updateCanvas() { const t = this.canvas; if (t.width === this.width && t.height === this.height || (t.width = this.width, t.height = this.height, this.frame.setSize(this.width, this.height)), !this.dirty || this.renderer && this.renderer.gl) this.dirty = !1; else { const e = this.context; this.scene.sys.game.config.antialias || l.disable(e); const i = this._tileScale.x; const n = this._tileScale.y; const s = this._tilePosition.x; const r = this._tilePosition.y; e.clearRect(0, 0, this.width, this.height), e.save(), e.scale(i, n), e.translate(-s, -r), e.fillStyle = this.fillPattern, e.fillRect(s, r, this.width / i, this.height / n), e.restore(), this.dirty = !1; } }, preDestroy() { this.renderer && this.renderer.gl && this.renderer.deleteTexture(this.fillPattern), n.remove(this.canvas), n.remove(this.fillCanvas), this.fillPattern = null, this.fillContext = null, this.fillCanvas = null, this.displayTexture = null, this.displayFrame = null, this.texture.destroy(), this.renderer = null; }, tilePositionX: { get() { return this._tilePosition.x; }, set(t) { this._tilePosition.x = t, this.dirty = !0; } }, tilePositionY: { get() { return this._tilePosition.y; }, set(t) { this._tilePosition.y = t, this.dirty = !0; } }, tileScaleX: { get() { return this._tileScale.x; }, set(t) { this._tileScale.x = t, this.dirty = !0; } }, tileScaleY: { get() { return this._tileScale.y; }, set(t) { this._tileScale.y = t, this.dirty = !0; } },
  }); t.exports = d;
}, function (t, e, i) {
  const n = i(169); const s = i(24); const r = i(0); const o = i(14); const a = i(26); const h = i(19); const l = i(811); const u = i(4); const c = i(342); const d = i(810); const f = i(807); const p = new r({
    Extends: h,
    Mixins: [o.Alpha, o.BlendMode, o.ComputedSize, o.Crop, o.Depth, o.Flip, o.GetBounds, o.Mask, o.Origin, o.Pipeline, o.ScaleMode, o.ScrollFactor, o.Tint, o.Transform, o.Visible, d],
    initialize(t, e, i, n, r) {
      void 0 === e && (e = 0), void 0 === i && (i = 0), h.call(this, t, 'Text'), this.renderer = t.sys.game.renderer, this.setPosition(e, i), this.setOrigin(0, 0), this.initPipeline(), this.canvas = s.create(this), this.context = this.canvas.getContext('2d'), this.style = new f(this, r), this.autoRound = !0, this.splitRegExp = /(?:\r\n|\r|\n)/, this._text = '', this.padding = {
        left: 0, right: 0, top: 0, bottom: 0,
      }, this.width = 1, this.height = 1, this.lineSpacing = 0, this.dirty = !1, this.style.resolution === 0 && (this.style.resolution = t.sys.game.config.resolution), this._crop = this.resetCropObject(), this.texture = t.sys.textures.addCanvas(null, this.canvas, !0), this.frame = this.texture.get(), this.frame.source.resolution = this.style.resolution, this.renderer && this.renderer.gl && (this.renderer.deleteTexture(this.frame.source.glTexture), this.frame.source.glTexture = null), this.initRTL(), r && r.padding && this.setPadding(r.padding), r && r.lineSpacing && (this.lineSpacing = r.lineSpacing), this.setText(n), t.sys.game.config.renderType === a.WEBGL && t.sys.game.renderer.onContextRestored(function () { this.dirty = !0; }, this);
    },
    initRTL() { this.style.rtl && (this.canvas.dir = 'rtl', this.context.direction = 'rtl', this.canvas.style.display = 'none', n(this.canvas, this.scene.sys.canvas), this.originX = 1); },
    runWordWrap(t) { const e = this.style; if (e.wordWrapCallback) { let i = e.wordWrapCallback.call(e.wordWrapCallbackScope, t, this); return Array.isArray(i) && (i = i.join('\n')), i; } return e.wordWrapWidth ? e.wordWrapUseAdvanced ? this.advancedWordWrap(t, this.context, this.style.wordWrapWidth) : this.basicWordWrap(t, this.context, this.style.wordWrapWidth) : t; },
    advancedWordWrap(t, e, i) { for (var n = '', s = t.replace(/ +/gi, ' ').split(this.splitRegExp), r = s.length, o = 0; o < r; o++) { let a = s[o]; let h = ''; if (a = a.replace(/^ *|\s*$/gi, ''), e.measureText(a).width < i)n += `${a}\n`; else { for (let l = i, u = a.split(' '), c = 0; c < u.length; c++) { const d = u[c]; const f = `${d} `; let p = e.measureText(f).width; if (p > l) { if (c === 0) { for (var g = f; g.length && (g = g.slice(0, -1), !((p = e.measureText(g).width) <= l)););if (!g.length) throw new Error("This text's wordWrapWidth setting is less than a single character!"); const v = d.substr(g.length); u[c] = v, h += g; } const y = u[c].length ? c : c + 1; const m = u.slice(y).join(' ').replace(/[ \n]*$/gi, ''); s[o + 1] = `${m} ${s[o + 1] || ''}`, r = s.length; break; }h += f, l -= p; }n += `${h.replace(/[ \n]*$/gi, '')}\n`; } } return n = n.replace(/[\s|\n]*$/gi, ''); },
    basicWordWrap(t, e, i) { for (var n = '', s = t.split(this.splitRegExp), r = 0; r < s.length; r++) { for (let o = i, a = s[r].split(' '), h = 0; h < a.length; h++) { const l = e.measureText(a[h]).width; const u = l + e.measureText(' ').width; u > o ? (h > 0 && (n += '\n'), n += `${a[h]} `, o = i - l) : (o -= u, n += a[h], h < a.length - 1 && (n += ' ')); }r < s.length - 1 && (n += '\n'); } return n; },
    getWrappedText(t) { return void 0 === t && (t = this._text), this.style.syncFont(this.canvas, this.context), this.runWordWrap(t).split(this.splitRegExp); },
    setText(t) { return t || t === 0 || (t = ''), Array.isArray(t) && (t = t.join('\n')), t !== this._text && (this._text = t.toString(), this.updateText()), this; },
    setStyle(t) { return this.style.setStyle(t); },
    setFont(t) { return this.style.setFont(t); },
    setFontFamily(t) { return this.style.setFontFamily(t); },
    setFontSize(t) { return this.style.setFontSize(t); },
    setFontStyle(t) { return this.style.setFontStyle(t); },
    setFixedSize(t, e) { return this.style.setFixedSize(t, e); },
    setBackgroundColor(t) { return this.style.setBackgroundColor(t); },
    setFill(t) { return this.style.setFill(t); },
    setColor(t) { return this.style.setColor(t); },
    setStroke(t, e) { return this.style.setStroke(t, e); },
    setShadow(t, e, i, n, s, r) { return this.style.setShadow(t, e, i, n, s, r); },
    setShadowOffset(t, e) { return this.style.setShadowOffset(t, e); },
    setShadowColor(t) { return this.style.setShadowColor(t); },
    setShadowBlur(t) { return this.style.setShadowBlur(t); },
    setShadowStroke(t) { return this.style.setShadowStroke(t); },
    setShadowFill(t) { return this.style.setShadowFill(t); },
    setWordWrapWidth(t, e) { return this.style.setWordWrapWidth(t, e); },
    setWordWrapCallback(t, e) { return this.style.setWordWrapCallback(t, e); },
    setAlign(t) { return this.style.setAlign(t); },
    setResolution(t) { return this.style.setResolution(t); },
    setLineSpacing(t) { return this.lineSpacing = t, this.updateText(); },
    setPadding(t, e, i, n) { if (typeof t === 'object') { const s = t; const r = u(s, 'x', null); r !== null ? (t = r, i = r) : (t = u(s, 'left', 0), i = u(s, 'right', t)); const o = u(s, 'y', null); o !== null ? (e = o, n = o) : (e = u(s, 'top', 0), n = u(s, 'bottom', e)); } else void 0 === t && (t = 0), void 0 === e && (e = t), void 0 === i && (i = t), void 0 === n && (n = e); return this.padding.left = t, this.padding.top = e, this.padding.right = i, this.padding.bottom = n, this.updateText(); },
    setMaxLines(t) { return this.style.setMaxLines(t); },
    updateText() { const t = this.canvas; const e = this.context; const i = this.style; const n = i.resolution; const s = i.metrics; i.syncFont(t, e); let r = this._text; (i.wordWrapWidth || i.wordWrapCallback) && (r = this.runWordWrap(this._text)); let o; let a; const h = r.split(this.splitRegExp); const u = l(this, s, h); const c = this.padding; let d = u.width + c.left + c.right; let f = u.height + c.top + c.bottom; i.fixedWidth === 0 && (this.width = d), i.fixedHeight === 0 && (this.height = f), this.updateDisplayOrigin(), d *= n, f *= n, d = Math.max(d, 1), f = Math.max(f, 1), t.width !== d || t.height !== f ? (t.width = d, t.height = f, this.frame.setSize(d, f), i.syncFont(t, e)) : e.clearRect(0, 0, d, f), e.save(), e.scale(n, n), i.backgroundColor && (e.fillStyle = i.backgroundColor, e.fillRect(0, 0, d, f)), i.syncStyle(t, e), e.textBaseline = 'alphabetic', e.translate(c.left, c.top); for (let p = 0; p < u.lines; p++)o = i.strokeThickness / 2, a = i.strokeThickness / 2 + p * u.lineHeight + s.ascent, p > 0 && (a += u.lineSpacing * p), i.rtl ? o = d - o : i.align === 'right' ? o += u.width - u.lineWidths[p] : i.align === 'center' && (o += (u.width - u.lineWidths[p]) / 2), this.autoRound && (o = Math.round(o), a = Math.round(a)), i.strokeThickness && (this.style.syncShadow(e, i.shadowStroke), e.strokeText(h[p], o, a)), i.color && (this.style.syncShadow(e, i.shadowFill), e.fillText(h[p], o, a)); return e.restore(), this.renderer.gl && (this.frame.source.glTexture = this.renderer.canvasToTexture(t, this.frame.source.glTexture, !0), this.frame.glTexture = this.frame.source.glTexture), this.dirty = !0, this; },
    getTextMetrics() { return this.style.getTextMetrics(); },
    text: { get() { return this._text; }, set(t) { this.setText(t); } },
    toJSON() {
      const t = o.ToJSON(this); const e = {
        autoRound: this.autoRound,
        text: this._text,
        style: this.style.toJSON(),
        padding: {
          left: this.padding.left, right: this.padding.right, top: this.padding.top, bottom: this.padding.bottom,
        },
      }; return t.data = e, t;
    },
    preDestroy() { this.style.rtl && c(this.canvas), s.remove(this.canvas), this.texture.destroy(); },
  }); t.exports = p;
}, function (t, e, i) {
  const n = i(121); const s = i(24); const r = i(0); const o = i(14); const a = i(26); const h = i(113); const l = i(19); const u = i(817); const c = i(295); const d = new r({
    Extends: l, Mixins: [o.Alpha, o.BlendMode, o.ComputedSize, o.Crop, o.Depth, o.Flip, o.GetBounds, o.Mask, o.Origin, o.Pipeline, o.ScaleMode, o.ScrollFactor, o.Tint, o.Transform, o.Visible, u], initialize(t, e, i, r, o) { void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === r && (r = 32), void 0 === o && (o = 32), l.call(this, t, 'RenderTexture'), this.renderer = t.sys.game.renderer, this.textureManager = t.sys.textures, this.globalTint = 16777215, this.globalAlpha = 1, this.canvas = s.create2D(this, r, o), this.context = this.canvas.getContext('2d'), this.framebuffer = null, this._crop = this.resetCropObject(), this.texture = t.sys.textures.addCanvas(c(), this.canvas), this.frame = this.texture.get(), this._saved = !1, this.camera = new n(0, 0, r, o), this.dirty = !1, this.gl = null; const h = this.renderer; if (h.type === a.WEBGL) { const u = h.gl; this.gl = u, this.drawGameObject = this.batchGameObjectWebGL, this.framebuffer = h.createFramebuffer(r, o, this.frame.source.glTexture, !1); } else h.type === a.CANVAS && (this.drawGameObject = this.batchGameObjectCanvas); this.camera.setScene(t), this.setPosition(e, i), this.setSize(r, o), this.setOrigin(0, 0), this.initPipeline(); }, setSize(t, e) { return this.resize(t, e); }, resize(t, e) { if (void 0 === e && (e = t), t !== this.width || e !== this.height) { if (this.canvas.width = t, this.canvas.height = e, this.gl) { const i = this.gl; this.renderer.deleteTexture(this.frame.source.glTexture), this.renderer.deleteFramebuffer(this.framebuffer), this.frame.source.glTexture = this.renderer.createTexture2D(0, i.NEAREST, i.NEAREST, i.CLAMP_TO_EDGE, i.CLAMP_TO_EDGE, i.RGBA, null, t, e, !1), this.framebuffer = this.renderer.createFramebuffer(t, e, this.frame.source.glTexture, !1), this.frame.glTexture = this.frame.source.glTexture; } this.frame.source.width = t, this.frame.source.height = e, this.camera.setSize(t, e), this.frame.setSize(t, e), this.width = t, this.height = e; } return this; }, setGlobalTint(t) { return this.globalTint = t, this; }, setGlobalAlpha(t) { return this.globalAlpha = t, this; }, saveTexture(t) { return this.textureManager.renameTexture(this.texture.key, t), this._saved = !0, this.texture; }, fill(t, e) { void 0 === e && (e = 1); const i = 255 & (t >> 16 | 0); const n = 255 & (t >> 8 | 0); const s = 255 & (0 | t); if (this.gl) { this.renderer.setFramebuffer(this.framebuffer); const r = this.gl; r.clearColor(i / 255, n / 255, s / 255, e), r.clear(r.COLOR_BUFFER_BIT), this.renderer.setFramebuffer(null); } else this.context.fillStyle = `rgb(${i},${n},${s})`, this.context.fillRect(0, 0, this.canvas.width, this.canvas.height); return this; }, clear() { if (this.dirty) { if (this.gl) { this.renderer.setFramebuffer(this.framebuffer); const t = this.gl; t.clearColor(0, 0, 0, 0), t.clear(t.COLOR_BUFFER_BIT), this.renderer.setFramebuffer(null); } else { const e = this.context; e.save(), e.setTransform(1, 0, 0, 1, 0, 0), e.clearRect(0, 0, this.canvas.width, this.canvas.height), e.restore(); } this.dirty = !1; } return this; }, draw(t, e, i, n, s) { void 0 === n && (n = this.globalAlpha), s = void 0 === s ? (this.globalTint >> 16) + (65280 & this.globalTint) + ((255 & this.globalTint) << 16) : (s >> 16) + (65280 & s) + ((255 & s) << 16), Array.isArray(t) || (t = [t]); const r = this.gl; if (this.camera.preRender(1, 1, 1), r) { this.renderer.setFramebuffer(this.framebuffer); const o = this.pipeline; o.projOrtho(0, this.width, 0, this.height, -1e3, 1e3), this.batchList(t, e, i, n, s), o.flush(), this.renderer.setFramebuffer(null), o.projOrtho(0, o.width, o.height, 0, -1e3, 1e3); } else this.renderer.setContext(this.context), this.batchList(t, e, i, n, s), this.renderer.setContext(); return this.dirty = !0, this; }, drawFrame(t, e, i, n, s, r) { void 0 === i && (i = 0), void 0 === n && (n = 0), void 0 === s && (s = this.globalAlpha), r = void 0 === r ? (this.globalTint >> 16) + (65280 & this.globalTint) + ((255 & this.globalTint) << 16) : (r >> 16) + (65280 & r) + ((255 & r) << 16); const o = this.gl; const a = this.textureManager.getFrame(t, e); if (a) { if (this.camera.preRender(1, 1, 1), o) { this.renderer.setFramebuffer(this.framebuffer); const h = this.pipeline; h.projOrtho(0, this.width, 0, this.height, -1e3, 1e3), h.batchTextureFrame(a, i, n, r, s, this.camera.matrix, null), h.flush(), this.renderer.setFramebuffer(null), h.projOrtho(0, h.width, h.height, 0, -1e3, 1e3); } else this.batchTextureFrame(a, i, n, s, r); this.dirty = !0; } return this; }, batchList(t, e, i, n, s) { for (let r = 0; r < t.length; r++) { const o = t[r]; o && o !== this && (o.renderWebGL || o.renderCanvas ? this.drawGameObject(o, e, i) : o.isParent || o.list ? this.batchGroup(o.getChildren(), e, i) : typeof o === 'string' ? this.batchTextureFrameKey(o, null, e, i, n, s) : o instanceof h ? this.batchTextureFrame(o, e, i, n, s) : Array.isArray(o) && this.batchList(o, e, i, n, s)); } }, batchGroup(t, e, i) { void 0 === e && (e = 0), void 0 === i && (i = 0); for (let n = 0; n < t.length; n++) { const s = t[n]; if (s.willRender()) { const r = s.x + e; const o = s.y + i; this.drawGameObject(s, r, o); } } }, batchGameObjectWebGL(t, e, i) { void 0 === e && (e = t.x), void 0 === i && (i = t.y); const n = t.x; const s = t.y; this.renderer.setBlendMode(t.blendMode), t.setPosition(e, i), t.renderWebGL(this.renderer, t, 0, this.camera, null), t.setPosition(n, s); }, batchGameObjectCanvas(t, e, i) { void 0 === e && (e = t.x), void 0 === i && (i = t.y); const n = t.x; const s = t.y; t.setPosition(e, i), t.renderCanvas(this.renderer, t, 0, this.camera, null), t.setPosition(n, s); }, batchTextureFrameKey(t, e, i, n, s, r) { const o = this.textureManager.getFrame(t, e); o && this.batchTextureFrame(o, i, n, s, r); }, batchTextureFrame(t, e, i, n, s) { if (void 0 === e && (e = 0), void 0 === i && (i = 0), this.gl) this.pipeline.batchTextureFrame(t, e, i, s, n, this.camera.matrix, null); else { const r = this.context; const o = t.canvasData; const a = t.source.image; const h = this.camera.matrix; r.globalAlpha = this.globalAlpha, r.setTransform(h[0], h[1], h[2], h[3], h[4], h[5]), r.drawImage(a, o.x, o.y, o.width, o.height, e, i, o.width, o.height); } }, preDestroy() { this._saved || (s.remove(this.canvas), this.gl && this.renderer.deleteFramebuffer(this.framebuffer), this.texture.destroy()); },
  }); t.exports = d;
}, function (t, e, i) {
  const n = i(0); const s = i(14); const r = i(19); const o = i(304); const a = i(112); const h = i(302); const l = i(821); const u = new n({
    Extends: r, Mixins: [s.Depth, s.Pipeline, s.Transform, s.Visible, l], initialize(t, e, i, n) { if (r.call(this, t, 'ParticleEmitterManager'), this.blendMode = -1, this.timeScale = 1, this.texture = null, this.frame = null, this.frameNames = [], i === null || typeof i !== 'object' && !Array.isArray(i) || (n = i, i = null), this.setTexture(e, i), this.initPipeline(), this.emitters = new a(this), this.wells = new a(this), n) { Array.isArray(n) || (n = [n]); for (let s = 0; s < n.length; s++) this.createEmitter(n[s]); } }, setTexture(t, e) { return this.texture = this.scene.sys.textures.get(t), this.setFrame(e); }, setFrame(t) { this.frame = this.texture.get(t); const e = []; return this.texture.getFramesFromTextureSource(this.frame.sourceIndex).forEach((t) => { e.push(t.name); }), this.frameNames = e, this.defaultFrame = this.frame, this; }, setEmitterFrames(t, e) { Array.isArray(t) || (t = [t]); const i = e.frames; i.length = 0; for (let n = 0; n < t.length; n++) { const s = t[n]; this.frameNames.indexOf(s) !== -1 && i.push(this.texture.get(s)); } return i.length > 0 ? e.defaultFrame = i[0] : e.defaultFrame = this.defaultFrame, this; }, addEmitter(t) { return this.emitters.add(t); }, createEmitter(t) { return this.addEmitter(new h(this, t)); }, addGravityWell(t) { return this.wells.add(t); }, createGravityWell(t) { return this.addGravityWell(new o(t)); }, emitParticle(t, e, i) { for (let n = this.emitters.list, s = 0; s < n.length; s++) { const r = n[s]; r.active && r.emitParticle(t, e, i); } return this; }, emitParticleAt(t, e, i) { return this.emitParticle(i, t, e); }, pause() { return this.active = !1, this; }, resume() { return this.active = !0, this; }, getProcessors() { return this.wells.getAll('active', !0); }, preUpdate(t, e) { e *= this.timeScale; for (let i = this.emitters.list, n = 0; n < i.length; n++) { const s = i[n]; s.active && s.preUpdate(t, e); } }, setAlpha() {}, setScrollFactor() {}, setBlendMode() {},
  }); t.exports = u;
}, function (t, e, i) { const n = i(6); t.exports = function (t, e, i) { void 0 === i && (i = new n()); const s = t.width / 2; const r = t.height / 2; return i.x = t.x + s * Math.cos(e), i.y = t.y + r * Math.sin(e), i; }; }, function (t, e) {
  t.exports = {
    ARC: 0, BEGIN_PATH: 1, CLOSE_PATH: 2, FILL_RECT: 3, LINE_TO: 4, MOVE_TO: 5, LINE_STYLE: 6, FILL_STYLE: 7, FILL_PATH: 8, STROKE_PATH: 9, FILL_TRIANGLE: 10, STROKE_TRIANGLE: 11, LINE_FX_TO: 12, MOVE_FX_TO: 13, SAVE: 14, RESTORE: 15, TRANSLATE: 16, SCALE: 17, ROTATE: 18, SET_TEXTURE: 19, CLEAR_TEXTURE: 20, GRADIENT_FILL_STYLE: 21, GRADIENT_LINE_STYLE: 22,
  };
}, function (t, e, i) {
  const n = i(121); const s = i(0); const r = i(157); const o = i(401); const a = i(400); const h = i(399); const l = i(395); const u = i(186); const c = i(390); const d = i(389); const f = i(392); const p = i(90); const g = i(19); const v = i(2); const y = i(4); const m = i(16); const x = i(831); var w = new s({
    Extends: g, Mixins: [o, a, h, l, u, c, d, f, x], initialize(t, e) { const i = y(e, 'x', 0); const n = y(e, 'y', 0); g.call(this, t, 'Graphics'), this.setPosition(i, n), this.initPipeline(), this.displayOriginX = 0, this.displayOriginY = 0, this.commandBuffer = [], this.defaultFillColor = -1, this.defaultFillAlpha = 1, this.defaultStrokeWidth = 1, this.defaultStrokeColor = -1, this.defaultStrokeAlpha = 1, this._lineWidth = 1, this.setDefaultStyles(e); }, setDefaultStyles(t) { return y(t, 'lineStyle', null) && (this.defaultStrokeWidth = y(t, 'lineStyle.width', 1), this.defaultStrokeColor = y(t, 'lineStyle.color', 16777215), this.defaultStrokeAlpha = y(t, 'lineStyle.alpha', 1), this.lineStyle(this.defaultStrokeWidth, this.defaultStrokeColor, this.defaultStrokeAlpha)), y(t, 'fillStyle', null) && (this.defaultFillColor = y(t, 'fillStyle.color', 16777215), this.defaultFillAlpha = y(t, 'fillStyle.alpha', 1), this.fillStyle(this.defaultFillColor, this.defaultFillAlpha)), this; }, lineStyle(t, e, i) { return void 0 === i && (i = 1), this.commandBuffer.push(r.LINE_STYLE, t, e, i), this._lineWidth = t, this; }, fillStyle(t, e) { return void 0 === e && (e = 1), this.commandBuffer.push(r.FILL_STYLE, t, e), this; }, fillGradientStyle(t, e, i, n, s) { return void 0 === s && (s = 1), this.commandBuffer.push(r.GRADIENT_FILL_STYLE, s, t, e, i, n), this; }, lineGradientStyle(t, e, i, n, s, o) { return void 0 === o && (o = 1), this.commandBuffer.push(r.GRADIENT_LINE_STYLE, t, o, e, i, n, s), this; }, setTexture(t, e, i) { if (void 0 === i && (i = 0), void 0 === t) this.commandBuffer.push(r.CLEAR_TEXTURE); else { const n = this.scene.sys.textures.getFrame(t, e); n && (i === 2 && (i = 3), this.commandBuffer.push(r.SET_TEXTURE, n, i)); } return this; }, beginPath() { return this.commandBuffer.push(r.BEGIN_PATH), this; }, closePath() { return this.commandBuffer.push(r.CLOSE_PATH), this; }, fillPath() { return this.commandBuffer.push(r.FILL_PATH), this; }, strokePath() { return this.commandBuffer.push(r.STROKE_PATH), this; }, fillCircleShape(t) { return this.fillCircle(t.x, t.y, t.radius); }, strokeCircleShape(t) { return this.strokeCircle(t.x, t.y, t.radius); }, fillCircle(t, e, i) { return this.beginPath(), this.arc(t, e, i, 0, m.PI2), this.fillPath(), this; }, strokeCircle(t, e, i) { return this.beginPath(), this.arc(t, e, i, 0, m.PI2), this.strokePath(), this; }, fillRectShape(t) { return this.fillRect(t.x, t.y, t.width, t.height); }, strokeRectShape(t) { return this.strokeRect(t.x, t.y, t.width, t.height); }, fillRect(t, e, i, n) { return this.commandBuffer.push(r.FILL_RECT, t, e, i, n), this; }, strokeRect(t, e, i, n) { const s = this._lineWidth / 2; const r = t - s; const o = t + s; return this.beginPath(), this.moveTo(t, e), this.lineTo(t, e + n), this.strokePath(), this.beginPath(), this.moveTo(t + i, e), this.lineTo(t + i, e + n), this.strokePath(), this.beginPath(), this.moveTo(r, e), this.lineTo(o + i, e), this.strokePath(), this.beginPath(), this.moveTo(r, e + n), this.lineTo(o + i, e + n), this.strokePath(), this; }, fillRoundedRect(t, e, i, n, s) { void 0 === s && (s = 20); let r = s; let o = s; let a = s; let h = s; return typeof s !== 'number' && (r = v(s, 'tl', 20), o = v(s, 'tr', 20), a = v(s, 'bl', 20), h = v(s, 'br', 20)), this.beginPath(), this.moveTo(t + r, e), this.lineTo(t + i - o, e), this.arc(t + i - o, e + o, o, -m.TAU, 0), this.lineTo(t + i, e + n - h), this.arc(t + i - h, e + n - h, h, 0, m.TAU), this.lineTo(t + a, e + n), this.arc(t + a, e + n - a, a, m.TAU, Math.PI), this.lineTo(t, e + r), this.arc(t + r, e + r, r, -Math.PI, -m.TAU), this.fillPath(), this; }, strokeRoundedRect(t, e, i, n, s) { void 0 === s && (s = 20); let r = s; let o = s; let a = s; let h = s; return typeof s !== 'number' && (r = v(s, 'tl', 20), o = v(s, 'tr', 20), a = v(s, 'bl', 20), h = v(s, 'br', 20)), this.beginPath(), this.moveTo(t + r, e), this.lineTo(t + i - o, e), this.arc(t + i - o, e + o, o, -m.TAU, 0), this.lineTo(t + i, e + n - h), this.arc(t + i - h, e + n - h, h, 0, m.TAU), this.lineTo(t + a, e + n), this.arc(t + a, e + n - a, a, m.TAU, Math.PI), this.lineTo(t, e + r), this.arc(t + r, e + r, r, -Math.PI, -m.TAU), this.strokePath(), this; }, fillPointShape(t, e) { return this.fillPoint(t.x, t.y, e); }, fillPoint(t, e, i) { return !i || i < 1 ? i = 1 : (t -= i / 2, e -= i / 2), this.commandBuffer.push(r.FILL_RECT, t, e, i, i), this; }, fillTriangleShape(t) { return this.fillTriangle(t.x1, t.y1, t.x2, t.y2, t.x3, t.y3); }, strokeTriangleShape(t) { return this.strokeTriangle(t.x1, t.y1, t.x2, t.y2, t.x3, t.y3); }, fillTriangle(t, e, i, n, s, o) { return this.commandBuffer.push(r.FILL_TRIANGLE, t, e, i, n, s, o), this; }, strokeTriangle(t, e, i, n, s, o) { return this.commandBuffer.push(r.STROKE_TRIANGLE, t, e, i, n, s, o), this; }, strokeLineShape(t) { return this.lineBetween(t.x1, t.y1, t.x2, t.y2); }, lineBetween(t, e, i, n) { return this.beginPath(), this.moveTo(t, e), this.lineTo(i, n), this.strokePath(), this; }, lineTo(t, e) { return this.commandBuffer.push(r.LINE_TO, t, e), this; }, moveTo(t, e) { return this.commandBuffer.push(r.MOVE_TO, t, e), this; }, lineFxTo(t, e, i, n) { return this.commandBuffer.push(r.LINE_FX_TO, t, e, i, n, 1), this; }, moveFxTo(t, e, i, n) { return this.commandBuffer.push(r.MOVE_FX_TO, t, e, i, n, 1), this; }, strokePoints(t, e, i) { void 0 === e && (e = !1), void 0 === i && (i = t.length), this.beginPath(), this.moveTo(t[0].x, t[0].y); for (let n = 1; n < i; n++) this.lineTo(t[n].x, t[n].y); return e && this.lineTo(t[0].x, t[0].y), this.strokePath(), this; }, fillPoints(t, e, i) { void 0 === e && (e = !1), void 0 === i && (i = t.length), this.beginPath(), this.moveTo(t[0].x, t[0].y); for (let n = 1; n < i; n++) this.lineTo(t[n].x, t[n].y); return e && this.lineTo(t[0].x, t[0].y), this.fillPath(), this; }, strokeEllipseShape(t, e) { void 0 === e && (e = 32); const i = t.getPoints(e); return this.strokePoints(i, !0); }, strokeEllipse(t, e, i, n, s) { void 0 === s && (s = 32); const r = new p(t, e, i, n).getPoints(s); return this.strokePoints(r, !0); }, fillEllipseShape(t, e) { void 0 === e && (e = 32); const i = t.getPoints(e); return this.fillPoints(i, !0); }, fillEllipse(t, e, i, n, s) { void 0 === s && (s = 32); const r = new p(t, e, i, n).getPoints(s); return this.fillPoints(r, !0); }, arc(t, e, i, n, s, o, a) { return void 0 === o && (o = !1), void 0 === a && (a = 0), this.commandBuffer.push(r.ARC, t, e, i, n, s, o, a), this; }, slice(t, e, i, n, s, o, a) { return void 0 === o && (o = !1), void 0 === a && (a = 0), this.commandBuffer.push(r.BEGIN_PATH), this.commandBuffer.push(r.MOVE_TO, t, e), this.commandBuffer.push(r.ARC, t, e, i, n, s, o, a), this.commandBuffer.push(r.CLOSE_PATH), this; }, save() { return this.commandBuffer.push(r.SAVE), this; }, restore() { return this.commandBuffer.push(r.RESTORE), this; }, translate(t, e) { return this.commandBuffer.push(r.TRANSLATE, t, e), this; }, scale(t, e) { return this.commandBuffer.push(r.SCALE, t, e), this; }, rotate(t) { return this.commandBuffer.push(r.ROTATE, t), this; }, clear() { return this.commandBuffer.length = 0, this.defaultFillColor > -1 && this.fillStyle(this.defaultFillColor, this.defaultFillAlpha), this.defaultStrokeColor > -1 && this.lineStyle(this.defaultStrokeWidth, this.defaultStrokeColor, this.defaultStrokeAlpha), this; }, generateTexture(t, e, i) { let n; let s; const r = this.scene.sys; const o = r.game.renderer; if (void 0 === e && (e = r.game.config.width), void 0 === i && (i = r.game.config.height), w.TargetCamera.setScene(this.scene), w.TargetCamera.setViewport(0, 0, e, i), w.TargetCamera.scrollX = this.x, w.TargetCamera.scrollY = this.y, typeof t === 'string') if (r.textures.exists(t)) { const a = (n = r.textures.get(t)).getSourceImage(); a instanceof HTMLCanvasElement && (s = a.getContext('2d')); } else s = (n = r.textures.createCanvas(t, e, i)).getSourceImage().getContext('2d'); else t instanceof HTMLCanvasElement && (s = t.getContext('2d')); return s && (this.renderCanvas(o, this, 0, w.TargetCamera, null, s, !1), n && n.refresh()), this; }, preDestroy() { this.commandBuffer = []; },
  }); w.TargetCamera = new n(), t.exports = w;
}, function (t, e, i) {
  const n = i(109); const s = i(0); const r = i(834); const o = new s({
    Extends: n,
    Mixins: [r],
    initialize(t, e, i, s, r, o, a) {
      n.call(this, t, e, i, s, r, o, a), this.type = 'DynamicBitmapText', this.scrollX = 0, this.scrollY = 0, this.cropWidth = 0, this.cropHeight = 0, this.displayCallback, this.callbackData = {
        color: 0,
        tint: {
          topLeft: 0, topRight: 0, bottomLeft: 0, bottomRight: 0,
        },
        index: 0,
        charCode: 0,
        x: 0,
        y: 0,
        scale: 0,
        rotation: 0,
        data: 0,
      };
    },
    setSize(t, e) { return this.cropWidth = t, this.cropHeight = e, this; },
    setDisplayCallback(t) { return this.displayCallback = t, this; },
    setScrollX(t) { return this.scrollX = t, this; },
    setScrollY(t) { return this.scrollY = t, this; },
  }); t.exports = o;
}, function (t, e, i) {
  const n = i(164); const s = i(66); const r = i(0); const o = i(14); const a = i(19); const h = i(9); const l = i(837); const u = i(309); const c = i(3); const d = new r({
    Extends: a, Mixins: [o.Alpha, o.BlendMode, o.ComputedSize, o.Depth, o.Mask, o.ScrollFactor, o.Transform, o.Visible, l], initialize(t, e, i, n) { a.call(this, t, 'Container'), this.list = [], this.exclusive = !0, this.maxSize = -1, this.position = 0, this.localTransform = new o.TransformMatrix(), this.tempTransformMatrix = new o.TransformMatrix(), this._displayList = t.sys.displayList, this._sortKey = '', this._sysEvents = t.sys.events, this.setPosition(e, i), this.clearAlpha(), this.setBlendMode(s.SKIP_CHECK), n && this.add(n); }, originX: { get() { return 0.5; } }, originY: { get() { return 0.5; } }, displayOriginX: { get() { return 0.5 * this.width; } }, displayOriginY: { get() { return 0.5 * this.height; } }, setExclusive(t) { return void 0 === t && (t = !0), this.exclusive = t, this; }, getBounds(t) { if (void 0 === t && (t = new h()), t.setTo(this.x, this.y, 0, 0), this.list.length > 0) for (let e = this.list, i = new h(), n = 0; n < e.length; n++) { const s = e[n]; s.getBounds && (s.getBounds(i), u(i, t, t)); } return t; }, addHandler(t) { t.once('destroy', this.remove, this), this.exclusive && (this._displayList.remove(t), t.parentContainer && t.parentContainer.remove(t), t.parentContainer = this); }, removeHandler(t) { t.off('destroy', this.remove), this.exclusive && (t.parentContainer = null); }, pointToContainer(t, e) { if (void 0 === e && (e = new c()), this.parentContainer) return this.parentContainer.pointToContainer(t, e); const i = this.tempTransformMatrix; return i.applyITRS(this.x, this.y, this.rotation, this.scaleX, this.scaleY), i.invert(), i.transformPoint(t.x, t.y, e), e; }, getBoundsTransformMatrix() { return this.getWorldTransformMatrix(this.tempTransformMatrix, this.localTransform); }, add(t) { return n.Add(this.list, t, this.maxSize, this.addHandler, this), this; }, addAt(t, e) { return n.AddAt(this.list, t, e, this.maxSize, this.addHandler, this), this; }, getAt(t) { return this.list[t]; }, getIndex(t) { return this.list.indexOf(t); }, sort(t) { return t && (this._sortKey = t, n.StableSort.inplace(this.list, this.sortHandler)), this; }, sortHandler(t, e) { return t[this._sortKey] - e[this._sortKey]; }, getByName(t) { return n.GetFirst(this.list, 'name', t); }, getRandom(t, e) { return n.GetRandom(this.list, t, e); }, getFirst(t, e, i, s) { return n.GetFirstElement(this.list, t, e, i, s); }, getAll(t, e, i, s) { return n.GetAll(this.list, t, e, i, s); }, count(t, e, i, s) { return n.CountAllMatching(this.list, t, e, i, s); }, swap(t, e) { return n.Swap(this.list, t, e), this; }, moveTo(t, e) { return n.MoveTo(this.list, t, e), this; }, remove(t, e) { let i = n.Remove(this.list, t, this.removeHandler, this); if (e && i) { Array.isArray(i) || (i = [i]); for (let s = 0; s < i.length; s++)i[s].destroy(); } return this; }, removeAt(t, e) { const i = n.RemoveAt(this.list, t, this.removeHandler, this); return e && i && i.destroy(), this; }, removeBetween(t, e, i) { const s = n.RemoveBetween(this.list, t, e, this.removeHandler, this); if (i) for (let r = 0; r < s.length; r++)s[r].destroy(); return this; }, removeAll(t) { const e = n.RemoveBetween(this.list, 0, this.list.length, this.removeHandler, this); if (t) for (let i = 0; i < e.length; i++)e[i].destroy(); return this; }, bringToTop(t) { return n.BringToTop(this.list, t), this; }, sendToBack(t) { return n.SendToBack(this.list, t), this; }, moveUp(t) { return n.MoveUp(this.list, t), this; }, moveDown(t) { return n.MoveDown(this.list, t), this; }, reverse() { return this.list.reverse(), this; }, shuffle() { return n.Shuffle(this.list), this; }, replace(t, e, i) { return n.Replace(this.list, t, e) && (this.addHandler(e), this.removeHandler(t), i && t.destroy()), this; }, exists(t) { return this.list.indexOf(t) > -1; }, setAll(t, e, i, s) { return n.SetAll(this.list, t, e, i, s), this; }, each(t, e) { let i; const n = [null]; const s = this.list.slice(); const r = s.length; for (i = 2; i < arguments.length; i++)n.push(arguments[i]); for (i = 0; i < r; i++)n[0] = s[i], t.apply(e, n); return this; }, iterate(t, e) { let i; const n = [null]; for (i = 2; i < arguments.length; i++)n.push(arguments[i]); for (i = 0; i < this.list.length; i++)n[0] = this.list[i], t.apply(e, n); return this; }, length: { get() { return this.list.length; } }, first: { get() { return this.position = 0, this.list.length > 0 ? this.list[0] : null; } }, last: { get() { return this.list.length > 0 ? (this.position = this.list.length - 1, this.list[this.position]) : null; } }, next: { get() { return this.position < this.list.length ? (this.position++, this.list[this.position]) : null; } }, previous: { get() { return this.position > 0 ? (this.position--, this.list[this.position]) : null; } }, preDestroy() { this.removeAll(!!this.exclusive), this.localTransform.destroy(), this.tempTransformMatrix.destroy(), this.list = [], this._displayList = null; },
  }); t.exports = d;
}, function (t, e, i) {
  const n = i(841); const s = i(838); const r = i(0); const o = i(14); const a = i(113); const h = i(19); const l = i(112); const u = new r({
    Extends: h, Mixins: [o.Alpha, o.BlendMode, o.Depth, o.Mask, o.Pipeline, o.ScaleMode, o.ScrollFactor, o.Size, o.Texture, o.Transform, o.Visible, n], initialize(t, e, i, n, s) { h.call(this, t, 'Blitter'), this.setTexture(n, s), this.setPosition(e, i), this.initPipeline(), this.children = new l(), this.renderList = [], this.dirty = !1; }, create(t, e, i, n, r) { void 0 === n && (n = !0), void 0 === r && (r = this.children.length), void 0 === i ? i = this.frame : i instanceof a || (i = this.texture.get(i)); const o = new s(this, t, e, i, n); return this.children.addAt(o, r, !1), this.dirty = !0, o; }, createFromCallback(t, e, i, n) { for (var s = this.createMultiple(e, i, n), r = 0; r < s.length; r++) { const o = s[r]; t.call(this, o, r); } return s; }, createMultiple(t, e, i) { void 0 === e && (e = this.frame.name), void 0 === i && (i = !0), Array.isArray(e) || (e = [e]); const n = []; const s = this; return e.forEach((e) => { for (let r = 0; r < t; r++)n.push(s.create(0, 0, e, i)); }), n; }, childCanRender(t) { return t.visible && t.alpha > 0; }, getRenderList() { return this.dirty && (this.renderList = this.children.list.filter(this.childCanRender, this), this.dirty = !1), this.renderList; }, clear() { this.children.removeAll(), this.dirty = !0; }, preDestroy() { this.children.destroy(), this.renderList = []; },
  }); t.exports = u;
}, function (t, e) { t.exports = function (t, e, i) { void 0 === e && (e = 0), void 0 === i && (i = t.length); const n = e + Math.floor(Math.random() * i); return void 0 === t[n] ? null : t[n]; }; }, function (t, e) { t.exports = function (t) { if (!Array.isArray(t) || t.length < 2 || !Array.isArray(t[0])) return !1; for (let e = t[0].length, i = 1; i < t.length; i++) if (t[i].length !== e) return !1; return !0; }; }, function (t, e, i) {
  t.exports = {
    Matrix: i(874), Add: i(867), AddAt: i(866), BringToTop: i(865), CountAllMatching: i(864), Each: i(863), EachInRange: i(862), FindClosestInSorted: i(383), GetAll: i(861), GetFirst: i(860), GetRandom: i(162), MoveDown: i(859), MoveTo: i(858), MoveUp: i(857), NumberArray: i(856), NumberArrayStep: i(855), QuickSelect: i(313), Range: i(312), Remove: i(330), RemoveAt: i(854), RemoveBetween: i(853), RemoveRandomElement: i(852), Replace: i(851), RotateLeft: i(387), RotateRight: i(386), SafeRange: i(62), SendToBack: i(850), SetAll: i(849), Shuffle: i(122), SpliceOne: i(91), StableSort: i(110), Swap: i(848),
  };
}, function (t, e, i) {
  const n = i(0); const s = i(113); const r = i(317); const o = new n({
    initialize(t, e, i, n, s) { Array.isArray(i) || (i = [i]), this.manager = t, this.key = e, this.source = [], this.dataSource = [], this.frames = {}, this.customData = {}, this.firstFrame = '__BASE', this.frameTotal = 0; for (let o = 0; o < i.length; o++) this.source.push(new r(this, i[o], n, s)); }, add(t, e, i, n, r, o) { const a = new s(this, t, e, i, n, r, o); return this.frames[t] = a, this.frameTotal === 1 && (this.firstFrame = t), this.frameTotal++, a; }, has(t) { return this.frames[t]; }, get(t) { t || (t = this.firstFrame); let e = this.frames[t]; return e || (console.warn(`Texture.frame missing: ${t}`), e = this.frames[this.firstFrame]), e; }, getTextureSourceIndex(t) { for (let e = 0; e < this.source.length; e++) if (this.source[e] === t) return e; return -1; }, getFramesFromTextureSource(t, e) { void 0 === e && (e = !1); const i = []; for (const n in this.frames) if (n !== '__BASE' || e) { const s = this.frames[n]; s.sourceIndex === t && i.push(s); } return i; }, getFrameNames(t) { void 0 === t && (t = !1); const e = Object.keys(this.frames); if (!t) { const i = e.indexOf('__BASE'); i !== -1 && e.splice(i, 1); } return e; }, getSourceImage(t) { void 0 !== t && t !== null && this.frameTotal !== 1 || (t = '__BASE'); const e = this.frames[t]; return e ? e.source.image : (console.warn(`Texture.frame missing: ${t}`), this.frames.__BASE.source.image); }, getDataSourceImage(t) { void 0 !== t && t !== null && this.frameTotal !== 1 || (t = '__BASE'); let e; const i = this.frames[t]; return i ? e = i.sourceIndex : (console.warn(`Texture.frame missing: ${t}`), e = this.frames.__BASE.sourceIndex), this.dataSource[e].image; }, setDataSource(t) { Array.isArray(t) || (t = [t]); for (let e = 0; e < t.length; e++) { const i = this.source[e]; this.dataSource.push(new r(this, t[e], i.width, i.height)); } }, setFilter(t) { let e; for (e = 0; e < this.source.length; e++) this.source[e].setFilter(t); for (e = 0; e < this.dataSource.length; e++) this.dataSource[e].setFilter(t); }, destroy() { let t; for (t = 0; t < this.source.length; t++) this.source[t].destroy(); for (t = 0; t < this.dataSource.length; t++) this.dataSource[t].destroy(); for (const e in this.frames) { this.frames[e].destroy(); } this.source = [], this.dataSource = [], this.frames = {}, this.manager = null; },
  }); t.exports = o;
}, function (t, e, i) {
  const n = i(0); const s = i(116); const r = i(167); const o = i(890); const a = i(889); const h = i(1); const l = i(326); const u = new n({
    initialize(t, e) { this.scene = t, this.game, this.config = e, this.settings = l.create(e), this.canvas, this.context, this.anims, this.cache, this.plugins, this.registry, this.sound, this.textures, this.add, this.cameras, this.displayList, this.events, this.make, this.scenePlugin, this.updateList, this.sceneUpdate = h; }, init(t) { this.settings.status = s.INIT, this.sceneUpdate = h, this.game = t, this.canvas = t.canvas, this.context = t.context; const e = t.plugins; this.plugins = e, e.addToScene(this, r.Global, [r.CoreScene, a(this), o(this)]), this.events.emit('boot', this), this.settings.isBooted = !0; }, install(t) { Array.isArray(t) || (t = [t]), this.plugins.installLocal(this, t); }, step(t, e) { this.events.emit('preupdate', t, e), this.events.emit('update', t, e), this.sceneUpdate.call(this.scene, t, e), this.events.emit('postupdate', t, e); }, render(t) { const e = this.displayList; e.depthSort(), this.cameras.render(t, e), this.events.emit('render', t); }, queueDepthSort() { this.displayList.queueDepthSort(); }, depthSort() { this.displayList.depthSort(); }, pause(t) { return this.settings.active && (this.settings.status = s.PAUSED, this.settings.active = !1, this.events.emit('pause', this, t)), this; }, resume(t) { return this.settings.active || (this.settings.status = s.RUNNING, this.settings.active = !0, this.events.emit('resume', this, t)), this; }, sleep(t) { return this.settings.status = s.SLEEPING, this.settings.active = !1, this.settings.visible = !1, this.events.emit('sleep', this, t), this; }, wake(t) { const e = this.settings; return e.status = s.RUNNING, e.active = !0, e.visible = !0, this.events.emit('wake', this, t), e.isTransition && this.events.emit('transitionwake', e.transitionFrom, e.transitionDuration), this; }, isSleeping() { return this.settings.status === s.SLEEPING; }, isActive() { return this.settings.status === s.RUNNING; }, isPaused() { return this.settings.status === s.PAUSED; }, isTransitioning() { return this.settings.isTransition || this.scenePlugin._target !== null; }, isTransitionOut() { return this.scenePlugin._target !== null && this.scenePlugin._duration > 0; }, isTransitionIn() { return this.settings.isTransition; }, isVisible() { return this.settings.visible; }, setVisible(t) { return this.settings.visible = t, this; }, setActive(t, e) { return t ? this.resume(e) : this.pause(e); }, start(t) { t && (this.settings.data = t), this.settings.status = s.START, this.settings.active = !0, this.settings.visible = !0, this.events.emit('start', this), this.events.emit('ready', this, t); }, resize(t, e) { this.events.emit('resize', t, e); }, shutdown(t) { this.events.off('transitioninit'), this.events.off('transitionstart'), this.events.off('transitioncomplete'), this.events.off('transitionout'), this.settings.status = s.SHUTDOWN, this.settings.active = !1, this.settings.visible = !1, this.events.emit('shutdown', this, t); }, destroy() { this.settings.status = s.DESTROYED, this.settings.active = !1, this.settings.visible = !1, this.events.emit('destroy', this), this.events.removeAllListeners(); for (let t = ['scene', 'game', 'anims', 'cache', 'plugins', 'registry', 'sound', 'textures', 'add', 'camera', 'displayList', 'events', 'make', 'scenePlugin', 'updateList'], e = 0; e < t.length; e++) this[t[e]] = null; },
  }); t.exports = u;
}, function (t, e, i) { t.exports = { Global: ['game', 'anims', 'cache', 'plugins', 'registry', 'scale', 'sound', 'textures'], CoreScene: ['EventEmitter', 'CameraManager', 'GameObjectCreator', 'GameObjectFactory', 'ScenePlugin', 'DisplayList', 'UpdateList'], DefaultScene: ['Clock', 'DataManagerPlugin', 'InputPlugin', 'Loader', 'TweenManager', 'LightsPlugin'] }; }, function (t, e, i) {
  const n = i(92); const s = i(118); const r = i(24); const o = {
    canvas: !1, canvasBitBltShift: null, file: !1, fileSystem: !1, getUserMedia: !0, littleEndian: !1, localStorage: !1, pointerLock: !1, support32bit: !1, vibration: !1, webGL: !1, worker: !1,
  }; t.exports = (function () { o.canvas = !!window.CanvasRenderingContext2D || n.cocoonJS; try { o.localStorage = !!localStorage.getItem; } catch (t) { o.localStorage = !1; }o.file = !!(window.File && window.FileReader && window.FileList && window.Blob), o.fileSystem = !!window.requestFileSystem; let t; let e; let i; let a = !1; return o.webGL = (function () { if (window.WebGLRenderingContext) try { const t = r.createWebGL(this); n.cocoonJS && (t.screencanvas = !1); const e = t.getContext('webgl') || t.getContext('experimental-webgl'); const i = r.create2D(this); const s = i.getContext('2d').createImageData(1, 1); return a = s.data instanceof Uint8ClampedArray, r.remove(t), r.remove(i), !!e; } catch (t) { return !1; } return !1; }()), o.worker = !!window.Worker, o.pointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document, navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia, window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL, o.getUserMedia = o.getUserMedia && !!navigator.getUserMedia && !!window.URL, s.firefox && s.firefoxVersion < 21 && (o.getUserMedia = !1), !n.iOS && (s.ie || s.firefox || s.chrome) && (o.canvasBitBltShift = !0), (s.safari || s.mobileSafari) && (o.canvasBitBltShift = !1), navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate, navigator.vibrate && (o.vibration = !0), typeof ArrayBuffer !== 'undefined' && typeof Uint8Array !== 'undefined' && typeof Uint32Array !== 'undefined' && (o.littleEndian = (t = new ArrayBuffer(4), e = new Uint8Array(t), i = new Uint32Array(t), e[0] = 161, e[1] = 178, e[2] = 195, e[3] = 212, i[0] === 3569595041 || i[0] !== 2712847316 && null)), o.support32bit = typeof ArrayBuffer !== 'undefined' && typeof Uint8ClampedArray !== 'undefined' && typeof Int32Array !== 'undefined' && o.littleEndian !== null && a, o; }());
}, function (t, e) { t.exports = function (t, e, i) { let n; if (void 0 === i && (i = !0), e) typeof e === 'string' ? n = document.getElementById(e) : typeof e === 'object' && e.nodeType === 1 && (n = e); else if (t.parentElement) return t; return n || (n = document.body), i && n.style && (n.style.overflow = 'hidden'), n.appendChild(t), t; }; }, function (t, e) { t.exports = function (t, e) { return Math.floor(Math.random() * (e - t + 1) + t); }; }, function (t, e) { t.exports = function (t, e, i, n, s) { const r = 0.5 * (n - e); const o = 0.5 * (s - i); const a = t * t; return (2 * i - 2 * n + r + o) * (t * a) + (-3 * i + 3 * n - 2 * r - o) * a + r * t + i; }; }, function (t, e, i) { const n = i(16); t.exports = function (t) { return t * n.RAD_TO_DEG; }; }, function (t, e, i) { const n = i(9); t.exports = function (t, e) { if (void 0 === e && (e = new n()), t.length === 0) return e; for (var i, s, r, o = Number.MAX_VALUE, a = Number.MAX_VALUE, h = Number.MIN_SAFE_INTEGER, l = Number.MIN_SAFE_INTEGER, u = 0; u < t.length; u++)i = t[u], Array.isArray(i) ? (s = i[0], r = i[1]) : (s = i.x, r = i.y), o = Math.min(o, s), a = Math.min(a, r), h = Math.max(h, s), l = Math.max(l, r); return e.x = o, e.y = a, e.width = h - o, e.height = l - a, e; }; }, function (t, e, i) {
  const n = i(369); const s = i(368); const r = i(367); const o = i(366); const a = i(365); const h = i(364); const l = i(363); const u = i(362); const c = i(361); const d = i(360); const f = i(359); const p = i(358); t.exports = {
    Power0: l, Power1: u.Out, Power2: o.Out, Power3: c.Out, Power4: d.Out, Linear: l, Quad: u.Out, Cubic: o.Out, Quart: c.Out, Quint: d.Out, Sine: f.Out, Expo: h.Out, Circ: r.Out, Elastic: a.Out, Back: n.Out, Bounce: s.Out, Stepped: p, 'Quad.easeIn': u.In, 'Cubic.easeIn': o.In, 'Quart.easeIn': c.In, 'Quint.easeIn': d.In, 'Sine.easeIn': f.In, 'Expo.easeIn': h.In, 'Circ.easeIn': r.In, 'Elastic.easeIn': a.In, 'Back.easeIn': n.In, 'Bounce.easeIn': s.In, 'Quad.easeOut': u.Out, 'Cubic.easeOut': o.Out, 'Quart.easeOut': c.Out, 'Quint.easeOut': d.Out, 'Sine.easeOut': f.Out, 'Expo.easeOut': h.Out, 'Circ.easeOut': r.Out, 'Elastic.easeOut': a.Out, 'Back.easeOut': n.Out, 'Bounce.easeOut': s.Out, 'Quad.easeInOut': u.InOut, 'Cubic.easeInOut': o.InOut, 'Quart.easeInOut': c.InOut, 'Quint.easeInOut': d.InOut, 'Sine.easeInOut': f.InOut, 'Expo.easeInOut': h.InOut, 'Circ.easeInOut': r.InOut, 'Elastic.easeInOut': a.InOut, 'Back.easeInOut': n.InOut, 'Bounce.easeInOut': s.InOut,
  };
}, function (t, e) { t.exports = function (t, e, i) { return t.x = e - t.width / 2, t.y = i - t.height / 2, t; }; }, function (t, e, i) {
  const n = i(177); t.exports = function (t, e, i, s) {
    void 0 === e && (e = 1), void 0 === i && (i = 1); const r = Math.floor(6 * t); const o = 6 * t - r; const a = Math.floor(i * (1 - e) * 255); const h = Math.floor(i * (1 - o * e) * 255); const l = Math.floor(i * (1 - (1 - o) * e) * 255); let u = i = Math.floor(i *= 255); let c = i; let d = i; const f = r % 6; return f === 0 ? (c = l, d = a) : f === 1 ? (u = h, d = a) : f === 2 ? (u = a, d = l) : f === 3 ? (u = a, c = h) : f === 4 ? (u = l, c = a) : f === 5 && (c = a, d = h), s ? s.setTo ? s.setTo(u, c, d, s.alpha, !1) : (s.r = u, s.g = c, s.b = d, s.color = n(u, c, d), s) : {
      r: u, g: c, b: d, color: n(u, c, d),
    };
  };
}, function (t, e) { t.exports = function (t, e, i) { return t << 16 | e << 8 | i; }; }, function (t, e, i) { const n = i(377); const s = i(374); const r = i(372); const o = i(371); t.exports = function (t) { switch (typeof t) { case 'string': return t.substr(0, 3).toLowerCase() === 'rgb' ? o(t) : n(t); case 'number': return s(t); case 'object': return r(t); } }; }, function (t, e) { t.exports = function (t, e, i, n) { void 0 === e && (e = 0), void 0 === i && (i = ' '), void 0 === n && (n = 3); let s = 0; if (e + 1 >= (t = t.toString()).length) switch (n) { case 1: t = new Array(e + 1 - t.length).join(i) + t; break; case 3: var r = Math.ceil((s = e - t.length) / 2); t = new Array(s - r + 1).join(i) + t + new Array(r + 1).join(i); break; default: t += new Array(e + 1 - t.length).join(i); } return t; }; }, function (t, e, i) {
  const n = new (i(0))({
    initialize(t) { if (this.entries = {}, this.size = 0, Array.isArray(t)) for (let e = 0; e < t.length; e++) this.set(t[e][0], t[e][1]); }, set(t, e) { return this.has(t) || (this.entries[t] = e, this.size++), this; }, get(t) { if (this.has(t)) return this.entries[t]; }, getArray() { const t = []; const e = this.entries; for (const i in e)t.push(e[i]); return t; }, has(t) { return this.entries.hasOwnProperty(t); }, delete(t) { return this.has(t) && (delete this.entries[t], this.size--), this; }, clear() { return Object.keys(this.entries).forEach(function (t) { delete this.entries[t]; }, this), this.size = 0, this; }, keys() { return Object.keys(this.entries); }, values() { const t = []; const e = this.entries; for (const i in e)t.push(e[i]); return t; }, dump() { const t = this.entries; for (const e in console.group('Map'), t)console.log(e, t[e]); console.groupEnd(); }, each(t) { const e = this.entries; for (const i in e) if (!1 === t(i, e[i])) break; return this; }, contains(t) { const e = this.entries; for (const i in e) if (e[i] === t) return !0; return !1; }, merge(t, e) { void 0 === e && (e = !1); const i = this.entries; const n = t.entries; for (const s in n)i.hasOwnProperty(s) && e ? i[s] = n[s] : this.set(s, n[s]); return this; },
  }); t.exports = n;
}, function (t, e) { t.exports = function (t, e, i) { return t <= e ? 0 : t >= i ? 1 : (t = (t - e) / (i - e)) * t * (3 - 2 * t); }; }, function (t, e) { t.exports = function (t, e, i) { return (t = Math.max(0, Math.min(1, (t - e) / (i - e)))) * t * t * (t * (6 * t - 15) + 10); }; }, function (t, e) { t.exports = function (t, e, i, n, s) { const r = n + Math.atan2(t.y - i, t.x - e); return t.x = e + s * Math.cos(r), t.y = i + s * Math.sin(r), t; }; }, function (t, e, i) { const n = i(6); t.exports = function (t, e) { void 0 === e && (e = new n()); const i = t.x2 - t.x1; const s = t.y2 - t.y1; const r = t.x3 - t.x1; const o = t.y3 - t.y1; let a = Math.random(); let h = Math.random(); return a + h >= 1 && (a = 1 - a, h = 1 - h), e.x = t.x1 + (i * a + r * h), e.y = t.y1 + (s * a + o * h), e; }; }, function (t, e, i) { const n = i(6); t.exports = function (t, e) { void 0 === e && (e = new n()); const i = Math.random() * Math.PI * 2; const s = Math.sqrt(Math.random()); return e.x = t.x + s * Math.cos(i) * t.width / 2, e.y = t.y + s * Math.sin(i) * t.height / 2, e; }; }, function (t, e) {
  const i = {
    defaultPipeline: null, pipeline: null, initPipeline(t) { void 0 === t && (t = 'TextureTintPipeline'); const e = this.scene.sys.game.renderer; return !!(e && e.gl && e.hasPipeline(t)) && (this.defaultPipeline = e.getPipeline(t), this.pipeline = this.defaultPipeline, !0); }, setPipeline(t) { const e = this.scene.sys.game.renderer; return e && e.gl && e.hasPipeline(t) && (this.pipeline = e.getPipeline(t)), this; }, resetPipeline() { return this.pipeline = this.defaultPipeline, this.pipeline !== null; }, getPipelineName() { return this.pipeline.name; },
  }; t.exports = i;
}, function (t, e, i) { const n = i(6); t.exports = function (t, e) { return void 0 === e && (e = new n()), e.x = t.x + Math.random() * t.width, e.y = t.y + Math.random() * t.height, e; }; }, function (t, e, i) { const n = i(6); t.exports = function (t, e) { void 0 === e && (e = new n()); const i = Math.random(); return e.x = t.x1 + i * (t.x2 - t.x1), e.y = t.y1 + i * (t.y2 - t.y1), e; }; }, function (t, e, i) { const n = i(65); const s = i(6); t.exports = function (t, e, i, r) { void 0 === r && (r = []), e || (e = n(t) / i); for (let o = t.x1, a = t.y1, h = t.x2, l = t.y2, u = 0; u < e; u++) { const c = u / e; const d = o + (h - o) * c; const f = a + (l - a) * c; r.push(new s(d, f)); } return r; }; }, function (t, e, i) { const n = i(124); const s = i(6); t.exports = function (t, e, i) { if (void 0 === i && (i = new s()), e <= 0 || e >= 1) return i.x = t.x, i.y = t.y, i; let r = n(t) * e; return e > 0.5 ? (r -= t.width + t.height) <= t.width ? (i.x = t.right - r, i.y = t.bottom) : (i.x = t.x, i.y = t.bottom - (r - t.width)) : r <= t.width ? (i.x = t.x + r, i.y = t.y) : (i.x = t.right, i.y = t.y + (r - t.width)), i; }; }, function (t, e, i) { const n = i(6); t.exports = function (t, e) { void 0 === e && (e = new n()); const i = 2 * Math.PI * Math.random(); const s = Math.random() + Math.random(); const r = s > 1 ? 2 - s : s; const o = r * Math.cos(i); const a = r * Math.sin(i); return e.x = t.x + o * t.radius, e.y = t.y + a * t.radius, e; }; }, function (t, e, i) { const n = i(6); t.exports = function (t, e, i) { return void 0 === i && (i = new n()), i.x = t.x + t.radius * Math.cos(e), i.y = t.y + t.radius * Math.sin(e), i; }; }, function (t, e) {
  t.exports = {
    TOP_LEFT: 0, TOP_CENTER: 1, TOP_RIGHT: 2, LEFT_TOP: 3, LEFT_CENTER: 4, LEFT_BOTTOM: 5, CENTER: 6, RIGHT_TOP: 7, RIGHT_CENTER: 8, RIGHT_BOTTOM: 9, BOTTOM_LEFT: 10, BOTTOM_CENTER: 11, BOTTOM_RIGHT: 12,
  };
}, function (t, e, i) {
  const n = {}; t.exports = n; const s = i(76); const r = i(81); const o = i(222); const a = i(80); const h = i(505); const l = i(33); n._warming = 0.4, n._torqueDampen = 1, n._minLength = 1e-6, n.create = function (t) {
    const e = t; e.bodyA && !e.pointA && (e.pointA = { x: 0, y: 0 }), e.bodyB && !e.pointB && (e.pointB = { x: 0, y: 0 }); const i = e.bodyA ? r.add(e.bodyA.position, e.pointA) : e.pointA; const n = e.bodyB ? r.add(e.bodyB.position, e.pointB) : e.pointB; const s = r.magnitude(r.sub(i, n)); e.length = void 0 !== e.length ? e.length : s, e.id = e.id || l.nextId(), e.label = e.label || 'Constraint', e.type = 'constraint', e.stiffness = e.stiffness || (e.length > 0 ? 1 : 0.7), e.damping = e.damping || 0, e.angularStiffness = e.angularStiffness || 0, e.angleA = e.bodyA ? e.bodyA.angle : e.angleA, e.angleB = e.bodyB ? e.bodyB.angle : e.angleB, e.plugin = {}; const o = {
      visible: !0, lineWidth: 2, strokeStyle: '#ffffff', type: 'line', anchors: !0,
    }; return e.length === 0 && e.stiffness > 0.1 ? (o.type = 'pin', o.anchors = !1) : e.stiffness < 0.9 && (o.type = 'spring'), e.render = l.extend(o, e.render), e;
  }, n.preSolveAll = function (t) { for (let e = 0; e < t.length; e += 1) { const i = t[e]; const n = i.constraintImpulse; i.isStatic || n.x === 0 && n.y === 0 && n.angle === 0 || (i.position.x += n.x, i.position.y += n.y, i.angle += n.angle); } }, n.solveAll = function (t, e) { for (var i = 0; i < t.length; i += 1) { var s = t[i]; var r = !s.bodyA || s.bodyA && s.bodyA.isStatic; var o = !s.bodyB || s.bodyB && s.bodyB.isStatic; (r || o) && n.solve(t[i], e); } for (i = 0; i < t.length; i += 1)r = !(s = t[i]).bodyA || s.bodyA && s.bodyA.isStatic, o = !s.bodyB || s.bodyB && s.bodyB.isStatic, r || o || n.solve(t[i], e); }, n.solve = function (t, e) { const i = t.bodyA; const s = t.bodyB; const o = t.pointA; const a = t.pointB; if (i || s) { i && !i.isStatic && (r.rotate(o, i.angle - t.angleA, o), t.angleA = i.angle), s && !s.isStatic && (r.rotate(a, s.angle - t.angleB, a), t.angleB = s.angle); let h = o; let l = a; if (i && (h = r.add(i.position, o)), s && (l = r.add(s.position, a)), h && l) { const u = r.sub(h, l); let c = r.magnitude(u); c < n._minLength && (c = n._minLength); let d; let f; let p; let g; let v; const y = (c - t.length) / c; const m = t.stiffness < 1 ? t.stiffness * e : t.stiffness; const x = r.mult(u, y * m); const w = (i ? i.inverseMass : 0) + (s ? s.inverseMass : 0); const b = w + ((i ? i.inverseInertia : 0) + (s ? s.inverseInertia : 0)); if (t.damping) { const T = r.create(); p = r.div(u, c), v = r.sub(s && r.sub(s.position, s.positionPrev) || T, i && r.sub(i.position, i.positionPrev) || T), g = r.dot(p, v); }i && !i.isStatic && (f = i.inverseMass / w, i.constraintImpulse.x -= x.x * f, i.constraintImpulse.y -= x.y * f, i.position.x -= x.x * f, i.position.y -= x.y * f, t.damping && (i.positionPrev.x -= t.damping * p.x * g * f, i.positionPrev.y -= t.damping * p.y * g * f), d = r.cross(o, x) / b * n._torqueDampen * i.inverseInertia * (1 - t.angularStiffness), i.constraintImpulse.angle -= d, i.angle -= d), s && !s.isStatic && (f = s.inverseMass / w, s.constraintImpulse.x += x.x * f, s.constraintImpulse.y += x.y * f, s.position.x += x.x * f, s.position.y += x.y * f, t.damping && (s.positionPrev.x += t.damping * p.x * g * f, s.positionPrev.y += t.damping * p.y * g * f), d = r.cross(a, x) / b * n._torqueDampen * s.inverseInertia * (1 - t.angularStiffness), s.constraintImpulse.angle += d, s.angle += d); } } }, n.postSolveAll = function (t) { for (let e = 0; e < t.length; e++) { const i = t[e]; const l = i.constraintImpulse; if (!(i.isStatic || l.x === 0 && l.y === 0 && l.angle === 0)) { o.set(i, !1); for (let u = 0; u < i.parts.length; u++) { const c = i.parts[u]; s.translate(c.vertices, l), u > 0 && (c.position.x += l.x, c.position.y += l.y), l.angle !== 0 && (s.rotate(c.vertices, l.angle, i.position), h.rotate(c.axes, l.angle), u > 0 && r.rotateAbout(c.position, l.angle, i.position, c.position)), a.update(c.bounds, c.vertices, i.velocity); }l.angle *= n._warming, l.x *= n._warming, l.y *= n._warming; } } };
}, function (t, e, i) { const n = {}; t.exports = n; const s = i(33); n.on = function (t, e, i) { for (var n, s = e.split(' '), r = 0; r < s.length; r++)n = s[r], t.events = t.events || {}, t.events[n] = t.events[n] || [], t.events[n].push(i); return i; }, n.off = function (t, e, i) { if (e) { typeof e === 'function' && (i = e, e = s.keys(t.events).join(' ')); for (let n = e.split(' '), r = 0; r < n.length; r++) { const o = t.events[n[r]]; const a = []; if (i && o) for (let h = 0; h < o.length; h++)o[h] !== i && a.push(o[h]); t.events[n[r]] = a; } } else t.events = {}; }, n.trigger = function (t, e, i) { let n; let r; let o; let a; const h = t.events; if (h && s.keys(h).length > 0) { i || (i = {}), n = e.split(' '); for (let l = 0; l < n.length; l++) if (o = h[r = n[l]]) { (a = s.clone(i, !1)).name = r, a.source = t; for (let u = 0; u < o.length; u++)o[u].apply(t, [a]); } } }; }, function (t, e, i) {
  const n = i(0); const s = i(64); const r = i(2); const o = i(894); const a = i(893); const h = i(892); const l = i(38); const u = i(10); const c = i(197); const d = new n({
    Extends: c,
    Mixins: [o],
    initialize(t) {
      const e = t.renderer.config; c.call(this, {
        game: t.game,
        renderer: t.renderer,
        gl: t.renderer.gl,
        topology: r(t, 'topology', t.renderer.gl.TRIANGLES),
        vertShader: r(t, 'vertShader', h),
        fragShader: r(t, 'fragShader', a),
        vertexCapacity: r(t, 'vertexCapacity', 6 * e.batchSize),
        vertexSize: r(t, 'vertexSize', 5 * Float32Array.BYTES_PER_ELEMENT + 4 * Uint8Array.BYTES_PER_ELEMENT),
        attributes: [{
          name: 'inPosition', size: 2, type: t.renderer.gl.FLOAT, normalized: !1, offset: 0,
        }, {
          name: 'inTexCoord', size: 2, type: t.renderer.gl.FLOAT, normalized: !1, offset: 2 * Float32Array.BYTES_PER_ELEMENT,
        }, {
          name: 'inTintEffect', size: 1, type: t.renderer.gl.FLOAT, normalized: !1, offset: 4 * Float32Array.BYTES_PER_ELEMENT,
        }, {
          name: 'inTint', size: 4, type: t.renderer.gl.UNSIGNED_BYTE, normalized: !0, offset: 5 * Float32Array.BYTES_PER_ELEMENT,
        }],
      }), this.vertexViewF32 = new Float32Array(this.vertexData), this.vertexViewU32 = new Uint32Array(this.vertexData), this.maxQuads = e.batchSize, this.batches = [], this._tempMatrix1 = new l(), this._tempMatrix2 = new l(), this._tempMatrix3 = new l(), this._tempMatrix4 = new l(), this.tempTriangle = [{ x: 0, y: 0, width: 0 }, { x: 0, y: 0, width: 0 }, { x: 0, y: 0, width: 0 }, { x: 0, y: 0, width: 0 }], this.tintEffect = 2, this.strokeTint = {
        TL: 0, TR: 0, BL: 0, BR: 0,
      }, this.fillTint = {
        TL: 0, TR: 0, BL: 0, BR: 0,
      }, this.currentFrame = {
        u0: 0, v0: 0, u1: 1, v1: 1,
      }, this.firstQuad = [0, 0, 0, 0, 0], this.prevQuad = [0, 0, 0, 0, 0], this.polygonCache = [], this.mvpInit();
    },
    onBind() { return c.prototype.onBind.call(this), this.mvpUpdate(), this.batches.length === 0 && this.pushBatch(), this; },
    resize(t, e, i) { return c.prototype.resize.call(this, t, e, i), this.projOrtho(0, this.width, this.height, 0, -1e3, 1e3), this; },
    setTexture2D(t, e) { t || (t = this.renderer.blankTexture.glTexture, e = 0); const i = this.batches; i.length === 0 && this.pushBatch(); const n = i[i.length - 1]; return e > 0 ? (n.textures[e - 1] && n.textures[e - 1] !== t && this.pushBatch(), i[i.length - 1].textures[e - 1] = t) : (n.texture !== null && n.texture !== t && this.pushBatch(), i[i.length - 1].texture = t), this; },
    pushBatch() { const t = { first: this.vertexCount, texture: null, textures: [] }; this.batches.push(t); },
    flush() { if (this.flushLocked) return this; this.flushLocked = !0; let t; let e; let i; const n = this.gl; const s = this.vertexCount; const r = this.topology; const o = this.vertexSize; const a = this.renderer; const h = this.batches; let l = 0; let u = null; if (h.length === 0 || s === 0) return this.flushLocked = !1, this; n.bufferSubData(n.ARRAY_BUFFER, 0, this.bytes.subarray(0, s * o)); for (let c = 0; c < h.length - 1; c++) { if (u = h[c], t = h[c + 1], u.textures.length > 0) { for (e = 0; e < u.textures.length; ++e)(i = u.textures[e]) && a.setTexture2D(i, 1 + e); n.activeTexture(n.TEXTURE0); }l = t.first - u.first, u.texture === null || l <= 0 || (a.setTexture2D(u.texture, 0), n.drawArrays(r, u.first, l)); } if ((u = h[h.length - 1]).textures.length > 0) { for (e = 0; e < u.textures.length; ++e)(i = u.textures[e]) && a.setTexture2D(i, 1 + e); n.activeTexture(n.TEXTURE0); } return l = s - u.first, u.texture && l > 0 && (a.setTexture2D(u.texture, 0), n.drawArrays(r, u.first, l)), this.vertexCount = 0, h.length = 0, this.pushBatch(), this.flushLocked = !1, this; },
    batchSprite(t, e, i) { this.renderer.setPipeline(this); const n = this._tempMatrix1; const s = this._tempMatrix2; const r = this._tempMatrix3; const o = t.frame; const a = o.glTexture; let h = o.u0; let l = o.v0; let c = o.u1; let d = o.v1; let f = o.x; let p = o.y; let g = o.cutWidth; let v = o.cutHeight; let y = -t.displayOriginX + f; let m = -t.displayOriginY + p; if (t.isCropped) { const x = t._crop; x.flipX === t.flipX && x.flipY === t.flipY || o.updateCropUVs(x, t.flipX, t.flipY), h = x.u0, l = x.v0, c = x.u1, d = x.v1, g = x.width, v = x.height, f = x.x, p = x.y, y = -t.displayOriginX + f, m = -t.displayOriginY + p; }t.flipX && (y += g, g *= -1), t.flipY && (m += v, v *= -1); const w = y + g; const b = m + v; s.applyITRS(t.x, t.y, t.rotation, t.scaleX, t.scaleY), n.copyFrom(e.matrix), i ? (n.multiplyWithOffset(i, -e.scrollX * t.scrollFactorX, -e.scrollY * t.scrollFactorY), s.e = t.x, s.f = t.y, n.multiply(s, r)) : (s.e -= e.scrollX * t.scrollFactorX, s.f -= e.scrollY * t.scrollFactorY, n.multiply(s, r)); let T = r.getX(y, m); let S = r.getY(y, m); let _ = r.getX(y, b); let A = r.getY(y, b); let C = r.getX(w, b); let M = r.getY(w, b); let P = r.getX(w, m); let E = r.getY(w, m); const k = u.getTintAppendFloatAlpha(t._tintTL, e.alpha * t._alphaTL); const L = u.getTintAppendFloatAlpha(t._tintTR, e.alpha * t._alphaTR); const F = u.getTintAppendFloatAlpha(t._tintBL, e.alpha * t._alphaBL); const R = u.getTintAppendFloatAlpha(t._tintBR, e.alpha * t._alphaBR); e.roundPixels && (T |= 0, S |= 0, _ |= 0, A |= 0, C |= 0, M |= 0, P |= 0, E |= 0), this.setTexture2D(a, 0); const O = t._isTinted && t.tintFill; this.batchQuad(T, S, _, A, C, M, P, E, h, l, c, d, k, L, F, R, O); },
    batchQuad(t, e, i, n, s, r, o, a, h, l, u, c, d, f, p, g, v) { let y = !1; this.vertexCount + 6 > this.vertexCapacity && (this.flush(), y = !0); const m = this.vertexViewF32; const x = this.vertexViewU32; let w = this.vertexCount * this.vertexComponentCount - 1; return m[++w] = t, m[++w] = e, m[++w] = h, m[++w] = l, m[++w] = v, x[++w] = d, m[++w] = i, m[++w] = n, m[++w] = h, m[++w] = c, m[++w] = v, x[++w] = p, m[++w] = s, m[++w] = r, m[++w] = u, m[++w] = c, m[++w] = v, x[++w] = g, m[++w] = t, m[++w] = e, m[++w] = h, m[++w] = l, m[++w] = v, x[++w] = d, m[++w] = s, m[++w] = r, m[++w] = u, m[++w] = c, m[++w] = v, x[++w] = g, m[++w] = o, m[++w] = a, m[++w] = u, m[++w] = l, m[++w] = v, x[++w] = f, this.vertexCount += 6, y; },
    batchTri(t, e, i, n, s, r, o, a, h, l, u, c, d, f) { let p = !1; this.vertexCount + 3 > this.vertexCapacity && (this.flush(), p = !0); const g = this.vertexViewF32; const v = this.vertexViewU32; let y = this.vertexCount * this.vertexComponentCount - 1; return g[++y] = t, g[++y] = e, g[++y] = o, g[++y] = a, g[++y] = f, v[++y] = u, g[++y] = i, g[++y] = n, g[++y] = o, g[++y] = l, g[++y] = f, v[++y] = c, g[++y] = s, g[++y] = r, g[++y] = h, g[++y] = l, g[++y] = f, v[++y] = d, this.vertexCount += 3, p; },
    batchTexture(t, e, i, n, s, r, o, a, h, l, u, c, d, f, p, g, v, y, m, x, w, b, T, S, _, A, C, M, P, E, k) { this.renderer.setPipeline(this, t); const L = this._tempMatrix1; const F = this._tempMatrix2; const R = this._tempMatrix3; let O = y / i + C; let D = m / n + M; let B = (y + x) / i + C; let I = (m + w) / n + M; let Y = o; let X = a; let z = -g; let N = -v; if (t.isCropped) { const U = t._crop; Y = U.width, X = U.height, o = U.width, a = U.height; let V = y = U.x; let G = m = U.y; c && (V = x - U.x - U.width), d && !e.isRenderTexture && (G = w - U.y - U.height), O = V / i + C, D = G / n + M, B = (V + U.width) / i + C, I = (G + U.height) / n + M, z = -g + y, N = -v + m; }d ^= !k && e.isRenderTexture ? 1 : 0, c && (Y *= -1, z += o), d && (X *= -1, N += a); const W = z + Y; const H = N + X; F.applyITRS(s, r, u, h, l), L.copyFrom(P.matrix), E ? (L.multiplyWithOffset(E, -P.scrollX * f, -P.scrollY * p), F.e = s, F.f = r, L.multiply(F, R)) : (F.e -= P.scrollX * f, F.f -= P.scrollY * p, L.multiply(F, R)); let j = R.getX(z, N); let q = R.getY(z, N); let K = R.getX(z, H); let J = R.getY(z, H); let Z = R.getX(W, H); let Q = R.getY(W, H); let $ = R.getX(W, N); let tt = R.getY(W, N); P.roundPixels && (j |= 0, q |= 0, K |= 0, J |= 0, Z |= 0, Q |= 0, $ |= 0, tt |= 0), this.setTexture2D(e, 0), this.batchQuad(j, q, K, J, Z, Q, $, tt, O, D, B, I, b, T, S, _, A); },
    batchTextureFrame(t, e, i, n, s, r, o) { this.renderer.setPipeline(this); const a = this._tempMatrix1.copyFrom(r); let h = this._tempMatrix2; const l = e + t.width; const c = i + t.height; o ? a.multiply(o, h) : h = a; const d = h.getX(e, i); const f = h.getY(e, i); const p = h.getX(e, c); const g = h.getY(e, c); const v = h.getX(l, c); const y = h.getY(l, c); const m = h.getX(l, i); const x = h.getY(l, i); this.setTexture2D(t.glTexture, 0), n = u.getTintAppendFloatAlpha(n, s), this.batchQuad(d, f, p, g, v, y, m, x, t.u0, t.v0, t.u1, t.v1, n, n, n, n, 0); },
    drawFillRect(t, e, i, n, s, r) { const o = t + i; const a = e + n; const h = u.getTintAppendFloatAlphaAndSwap(s, r); this.batchQuad(t, e, t, a, o, a, o, e, 0, 0, 1, 1, h, h, h, h, 2); },
    batchFillRect(t, e, i, n, s, r) { this.renderer.setPipeline(this); const o = this._tempMatrix3; r && r.multiply(s, o); const a = t + i; const h = e + n; const l = o.getX(t, e); const u = o.getY(t, e); const c = o.getX(t, h); const d = o.getY(t, h); const f = o.getX(a, h); const p = o.getY(a, h); const g = o.getX(a, e); const v = o.getY(a, e); const y = this.currentFrame; const m = y.u0; const x = y.v0; const w = y.u1; const b = y.v1; this.batchQuad(l, u, c, d, f, p, g, v, m, x, w, b, this.fillTint.TL, this.fillTint.TR, this.fillTint.BL, this.fillTint.BR, this.tintEffect); },
    batchFillTriangle(t, e, i, n, s, r, o, a) { this.renderer.setPipeline(this); const h = this._tempMatrix3; a && a.multiply(o, h); const l = h.getX(t, e); const u = h.getY(t, e); const c = h.getX(i, n); const d = h.getY(i, n); const f = h.getX(s, r); const p = h.getY(s, r); const g = this.currentFrame; const v = g.u0; const y = g.v0; const m = g.u1; const x = g.v1; this.batchTri(l, u, c, d, f, p, v, y, m, x, this.fillTint.TL, this.fillTint.TR, this.fillTint.BL, this.tintEffect); },
    batchStrokeTriangle(t, e, i, n, s, r, o, a, h) { const l = this.tempTriangle; l[0].x = t, l[0].y = e, l[0].width = o, l[1].x = i, l[1].y = n, l[1].width = o, l[2].x = s, l[2].y = r, l[2].width = o, l[3].x = t, l[3].y = e, l[3].width = o, this.batchStrokePath(l, o, !1, a, h); },
    batchFillPath(t, e, i) { this.renderer.setPipeline(this); const n = this._tempMatrix3; i && i.multiply(e, n); for (var r, o, a = t.length, h = this.polygonCache, l = this.fillTint.TL, u = this.fillTint.TR, c = this.fillTint.BL, d = this.tintEffect, f = 0; f < a; ++f)o = t[f], h.push(o.x, o.y); a = (r = s(h)).length; for (let p = this.currentFrame, g = 0; g < a; g += 3) { const v = 2 * r[g + 0]; const y = 2 * r[g + 1]; const m = 2 * r[g + 2]; const x = h[v + 0]; const w = h[v + 1]; const b = h[y + 0]; const T = h[y + 1]; const S = h[m + 0]; const _ = h[m + 1]; const A = n.getX(x, w); const C = n.getY(x, w); const M = n.getX(b, T); const P = n.getY(b, T); const E = n.getX(S, _); const k = n.getY(S, _); const L = p.u0; const F = p.v0; const R = p.u1; const O = p.v1; this.batchTri(A, C, M, P, E, k, L, F, R, O, l, u, c, d); }h.length = 0; },
    batchStrokePath(t, e, i, n, s) { this.renderer.setPipeline(this), this.prevQuad[4] = 0, this.firstQuad[4] = 0; for (let r = t.length - 1, o = 0; o < r; o++) { const a = t[o]; const h = t[o + 1]; this.batchLine(a.x, a.y, h.x, h.y, a.width / 2, h.width / 2, e, o, !i && o === r - 1, n, s); } },
    batchLine(t, e, i, n, s, r, o, a, h, l, u) { this.renderer.setPipeline(this); const c = this._tempMatrix3; u && u.multiply(l, c); const d = i - t; const f = n - e; const p = Math.sqrt(d * d + f * f); const g = s * (n - e) / p; const v = s * (t - i) / p; const y = r * (n - e) / p; const m = r * (t - i) / p; const x = i - y; const w = n - m; const b = t - g; const T = e - v; const S = i + y; const _ = n + m; const A = t + g; const C = e + v; const M = c.getX(x, w); const P = c.getY(x, w); const E = c.getX(b, T); const k = c.getY(b, T); const L = c.getX(S, _); const F = c.getY(S, _); const R = c.getX(A, C); const O = c.getY(A, C); const D = this.strokeTint; const B = this.tintEffect; const I = D.TL; const Y = D.TR; const X = D.BL; const z = D.BR; const N = this.currentFrame; const U = N.u0; const V = N.v0; const G = N.u1; const W = N.v1; if (this.batchQuad(R, O, E, k, M, P, L, F, U, V, G, W, I, Y, X, z, B), !(o <= 2)) { const H = this.prevQuad; const j = this.firstQuad; a > 0 && H[4] ? this.batchQuad(R, O, E, k, H[0], H[1], H[2], H[3], U, V, G, W, I, Y, X, z, B) : (j[0] = R, j[1] = O, j[2] = E, j[3] = k, j[4] = 1), h && j[4] ? this.batchQuad(M, P, L, F, j[0], j[1], j[2], j[3], U, V, G, W, I, Y, X, z, B) : (H[0] = M, H[1] = P, H[2] = L, H[3] = F, H[4] = 1); } },
  }); t.exports = d;
}, function (t, e, i) {
  const n = i(0); const s = i(10); const r = new n({
    initialize(t) { this.name = 'WebGLPipeline', this.game = t.game, this.view = t.game.canvas, this.resolution = t.game.config.resolution, this.width = t.game.config.width * this.resolution, this.height = t.game.config.height * this.resolution, this.gl = t.gl, this.vertexCount = 0, this.vertexCapacity = t.vertexCapacity, this.renderer = t.renderer, this.vertexData = t.vertices ? t.vertices : new ArrayBuffer(t.vertexCapacity * t.vertexSize), this.vertexBuffer = this.renderer.createVertexBuffer(t.vertices ? t.vertices : this.vertexData.byteLength, this.gl.STREAM_DRAW), this.program = this.renderer.createProgram(t.vertShader, t.fragShader), this.attributes = t.attributes, this.vertexSize = t.vertexSize, this.topology = t.topology, this.bytes = new Uint8Array(this.vertexData), this.vertexComponentCount = s.getComponentCount(t.attributes, this.gl), this.flushLocked = !1, this.active = !1; },
    boot() {},
    addAttribute(t, e, i, n, s) {
      return this.attributes.push({
        name: t, size: e, type: this.renderer.glFormats[i], normalized: n, offset: s,
      }), this;
    },
    shouldFlush() { return this.vertexCount >= this.vertexCapacity; },
    resize(t, e, i) { return this.width = t * i, this.height = e * i, this; },
    bind() { const t = this.gl; const e = this.vertexBuffer; const i = this.attributes; const n = this.program; const s = this.renderer; const r = this.vertexSize; s.setProgram(n), s.setVertexBuffer(e); for (let o = 0; o < i.length; ++o) { const a = i[o]; const h = t.getAttribLocation(n, a.name); h >= 0 ? (t.enableVertexAttribArray(h), t.vertexAttribPointer(h, a.size, a.type, a.normalized, r, a.offset)) : t.disableVertexAttribArray(h); } return this; },
    onBind() { return this; },
    onPreRender() { return this; },
    onRender() { return this; },
    onPostRender() { return this; },
    flush() { if (this.flushLocked) return this; this.flushLocked = !0; const t = this.gl; const e = this.vertexCount; const i = this.topology; const n = this.vertexSize; if (e !== 0) return t.bufferSubData(t.ARRAY_BUFFER, 0, this.bytes.subarray(0, e * n)), t.drawArrays(i, 0, e), this.vertexCount = 0, this.flushLocked = !1, this; this.flushLocked = !1; },
    destroy() { const t = this.gl; return t.deleteProgram(this.program), t.deleteBuffer(this.vertexBuffer), delete this.program, delete this.vertexBuffer, delete this.gl, this; },
    setFloat1(t, e) { return this.renderer.setFloat1(this.program, t, e), this; },
    setFloat2(t, e, i) { return this.renderer.setFloat2(this.program, t, e, i), this; },
    setFloat3(t, e, i, n) { return this.renderer.setFloat3(this.program, t, e, i, n), this; },
    setFloat4(t, e, i, n, s) { return this.renderer.setFloat4(this.program, t, e, i, n, s), this; },
    setFloat1v(t, e) { return this.renderer.setFloat1v(this.program, t, e), this; },
    setFloat2v(t, e) { return this.renderer.setFloat2v(this.program, t, e), this; },
    setFloat3v(t, e) { return this.renderer.setFloat3v(this.program, t, e), this; },
    setFloat4v(t, e) { return this.renderer.setFloat4v(this.program, t, e), this; },
    setInt1(t, e) { return this.renderer.setInt1(this.program, t, e), this; },
    setInt2(t, e, i) { return this.renderer.setInt2(this.program, t, e, i), this; },
    setInt3(t, e, i, n) { return this.renderer.setInt3(this.program, t, e, i, n), this; },
    setInt4(t, e, i, n, s) { return this.renderer.setInt4(this.program, t, e, i, n, s), this; },
    setMatrix2(t, e, i) { return this.renderer.setMatrix2(this.program, t, e, i), this; },
    setMatrix3(t, e, i) { return this.renderer.setMatrix3(this.program, t, e, i), this; },
    setMatrix4(t, e, i) { return this.renderer.setMatrix4(this.program, t, e, i), this; },
  }); t.exports = r;
}, function (t, e, i) { const n = i(53); t.exports = function (t) { return n(t, -180, 180); }; }, function (t, e, i) { const n = i(53); t.exports = function (t) { return n(t, -Math.PI, Math.PI); }; }, function (t, e) { let i; i = (function () { return this; }()); try { i = i || Function('return this')() || (0, eval)('this'); } catch (t) { typeof window === 'object' && (i = window); }t.exports = i; }, function (t, e, i) {
  const n = i(0); const s = i(11); const r = i(97); const o = i(83); var a = new n({
    Extends: s,
    initialize(t) {
      s.call(this), this.manager = t, this.isTimeline = !0, this.data = [], this.totalData = 0, this.useFrames = !1, this.timeScale = 1, this.loop = 0, this.loopDelay = 0, this.loopCounter = 0, this.completeDelay = 0, this.countdown = 0, this.state = o.PENDING_ADD, this._pausedState = o.PENDING_ADD, this.paused = !1, this.elapsed = 0, this.totalElapsed = 0, this.duration = 0, this.progress = 0, this.totalDuration = 0, this.totalProgress = 0, this.callbacks = {
        onComplete: null, onLoop: null, onStart: null, onUpdate: null, onYoyo: null,
      }, this.callbackScope;
    },
    setTimeScale(t) { return this.timeScale = t, this; },
    getTimeScale() { return this.timeScale; },
    isPlaying() { return this.state === o.ACTIVE; },
    add(t) { return this.queue(r(this, t)); },
    queue(t) { return this.isPlaying() || (t.parent = this, t.parentIsTimeline = !0, this.data.push(t), this.totalData = this.data.length), this; },
    hasOffset(t) { return t.offset !== null; },
    isOffsetAbsolute(t) { return typeof t === 'number'; },
    isOffsetRelative(t) { if (typeof t === 'string') { const e = t[0]; if (e === '-' || e === '+') return !0; } return !1; },
    getRelativeOffset(t, e) { const i = t[0]; const n = parseFloat(t.substr(2)); let s = e; switch (i) { case '+': s += n; break; case '-': s -= n; } return Math.max(0, s); },
    calcDuration() { for (var t = 0, e = 0, i = 0, n = 0; n < this.totalData; n++) { const s = this.data[n]; s.init(), this.hasOffset(s) ? this.isOffsetAbsolute(s.offset) ? (s.calculatedOffset = s.offset, s.offset === 0 && (i = 0)) : this.isOffsetRelative(s.offset) && (s.calculatedOffset = this.getRelativeOffset(s.offset, t)) : s.calculatedOffset = i, t = s.totalDuration + s.calculatedOffset, e += s.totalDuration, i += s.totalDuration; } this.duration = e, this.loopCounter = this.loop === -1 ? 999999999999 : this.loop, this.loopCounter > 0 ? this.totalDuration = this.duration + this.completeDelay + (this.duration + this.loopDelay) * this.loopCounter : this.totalDuration = this.duration + this.completeDelay; },
    init() { return this.calcDuration(), this.progress = 0, this.totalProgress = 0, !this.paused || (this.state = o.PAUSED, !1); },
    resetTweens(t) { for (let e = 0; e < this.totalData; e++) { this.data[e].play(t); } },
    setCallback(t, e, i, n) { return a.TYPES.indexOf(t) !== -1 && (this.callbacks[t] = { func: e, scope: n, params: i }), this; },
    makeActive(t) { return this.manager.makeActive(t); },
    play() { if (this.state !== o.ACTIVE) { if (this.paused) return this.paused = !1, void this.manager.makeActive(this); this.resetTweens(!1), this.state = o.ACTIVE; const t = this.callbacks.onStart; t && t.func.apply(t.scope, t.params), this.emit('start', this); } },
    nextState() { if (this.loopCounter > 0) { this.elapsed = 0, this.progress = 0, this.loopCounter--; const t = this.callbacks.onLoop; t && t.func.apply(t.scope, t.params), this.emit('loop', this, this.loopCounter), this.resetTweens(!0), this.loopDelay > 0 ? (this.countdown = this.loopDelay, this.state = o.LOOP_DELAY) : this.state = o.ACTIVE; } else if (this.completeDelay > 0) this.countdown = this.completeDelay, this.state = o.COMPLETE_DELAY; else { const e = this.callbacks.onComplete; e && e.func.apply(e.scope, e.params), this.emit('complete', this), this.state = o.PENDING_REMOVE; } },
    update(t, e) { if (this.state !== o.PAUSED) { const i = e; switch (this.useFrames && (e = 1 * this.manager.timeScale), e *= this.timeScale, this.elapsed += e, this.progress = Math.min(this.elapsed / this.duration, 1), this.totalElapsed += e, this.totalProgress = Math.min(this.totalElapsed / this.totalDuration, 1), this.state) { case o.ACTIVE: for (var n = this.totalData, s = 0; s < this.totalData; s++) { this.data[s].update(t, i) && n--; } var r = this.callbacks.onUpdate; r && r.func.apply(r.scope, r.params), this.emit('update', this), n === 0 && this.nextState(); break; case o.LOOP_DELAY: this.countdown -= e, this.countdown <= 0 && (this.state = o.ACTIVE); break; case o.COMPLETE_DELAY: if (this.countdown -= e, this.countdown <= 0) { const a = this.callbacks.onComplete; a && a.func.apply(a.scope, a.params), this.emit('complete', this), this.state = o.PENDING_REMOVE; } } return this.state === o.PENDING_REMOVE; } },
    stop() { this.state = o.PENDING_REMOVE; },
    pause() { if (this.state !== o.PAUSED) return this.paused = !0, this._pausedState = this.state, this.state = o.PAUSED, this.emit('pause', this), this; },
    resume() { return this.state === o.PAUSED && (this.paused = !1, this.state = this._pausedState), this.emit('resume', this), this; },
    hasTarget(t) { for (let e = 0; e < this.data.length; e++) if (this.data[e].hasTarget(t)) return !0; return !1; },
    destroy() { for (let t = 0; t < this.data.length; t++) this.data[t].stop(); },
  }); a.TYPES = ['onStart', 'onUpdate', 'onLoop', 'onComplete', 'onYoyo'], t.exports = a;
}, function (t, e, i) { const n = i(63); const s = i(129); const r = i(12); const o = i(84); const a = i(86); const h = i(98); const l = i(131); const u = i(204); const c = i(4); const d = i(201); const f = i(97); t.exports = function (t, e) { const i = new d(t); const p = u(e); if (p.length === 0) return i.paused = !0, i; const g = n(s); g.targets = l(e); const v = r(e, 'totalDuration', 0); g.duration = v > 0 ? Math.floor(v / p.length) : h(e, 'duration', g.duration), g.delay = h(e, 'delay', g.delay), g.easeParams = c(e, 'easeParams', g.easeParams), g.ease = a(c(e, 'ease', g.ease), g.easeParams), g.hold = h(e, 'hold', g.hold), g.repeat = h(e, 'repeat', g.repeat), g.repeatDelay = h(e, 'repeatDelay', g.repeatDelay), g.yoyo = o(e, 'yoyo', g.yoyo), g.flipX = o(e, 'flipX', g.flipX), g.flipY = o(e, 'flipY', g.flipY); for (let y = 0; y < p.length; y++)i.queue(f(i, p[y], g)); i.completeDelay = r(e, 'completeDelay', 0), i.loop = Math.round(r(e, 'loop', 0)), i.loopDelay = Math.round(r(e, 'loopDelay', 0)), i.paused = o(e, 'paused', !1), i.useFrames = o(e, 'useFrames', !1); const m = c(e, 'callbackScope', i); const x = [i]; const w = c(e, 'onStart', !1); if (w) { const b = c(e, 'onStartScope', m); const T = c(e, 'onStartParams', []); i.setCallback('onStart', w, x.concat(T), b); } const S = c(e, 'onUpdate', !1); if (S) { const _ = c(e, 'onUpdateScope', m); const A = c(e, 'onUpdateParams', []); i.setCallback('onUpdate', S, x.concat(A), _); } const C = c(e, 'onLoop', !1); if (C) { const M = c(e, 'onLoopScope', m); const P = c(e, 'onLoopParams', []); i.setCallback('onLoop', C, x.concat(P), M); } const E = c(e, 'onYoyo', !1); if (E) { const k = c(e, 'onYoyoScope', m); const L = c(e, 'onYoyoParams', []); i.setCallback('onYoyo', E, x.concat(null, L), k); } const F = c(e, 'onComplete', !1); if (F) { const R = c(e, 'onCompleteScope', m); const O = c(e, 'onCompleteParams', []); i.setCallback('onComplete', F, x.concat(O), R); } return i; }; }, function (t, e, i) { const n = i(129); const s = i(12); const r = i(84); const o = i(86); const a = i(98); const h = i(4); const l = i(130); const u = i(128); const c = i(127); t.exports = function (t, e, i) { void 0 === i && (i = n); const d = h(e, 'from', 0); const f = h(e, 'to', 1); const p = [{ value: d }]; const g = a(e, 'delay', i.delay); const v = a(e, 'duration', i.duration); const y = h(e, 'easeParams', i.easeParams); const m = o(h(e, 'ease', i.ease), y); const x = a(e, 'hold', i.hold); const w = a(e, 'repeat', i.repeat); const b = a(e, 'repeatDelay', i.repeatDelay); const T = r(e, 'yoyo', i.yoyo); const S = []; const _ = l('value', f); const A = c(p[0], 'value', _.getEnd, _.getStart, m, g, v, T, x, w, b, !1, !1); A.start = d, A.current = d, A.to = f, S.push(A); const C = new u(t, S, p); C.offset = s(e, 'offset', null), C.completeDelay = s(e, 'completeDelay', 0), C.loop = Math.round(s(e, 'loop', 0)), C.loopDelay = Math.round(s(e, 'loopDelay', 0)), C.paused = r(e, 'paused', !1), C.useFrames = r(e, 'useFrames', !1); for (let M = h(e, 'callbackScope', C), P = [C, null], E = u.TYPES, k = 0; k < E.length; k++) { const L = E[k]; const F = h(e, L, !1); if (F) { const R = h(e, `${L}Scope`, M); const O = h(e, `${L}Params`, []); C.setCallback(L, F, P.concat(O), R); } } return C; }; }, function (t, e, i) { const n = i(4); t.exports = function (t) { let e = n(t, 'tweens', null); return e === null ? [] : (typeof e === 'function' && (e = e.call()), Array.isArray(e) || (e = [e]), e); }; }, function (t, e, i) { const n = i(437); t.exports = function (t) { let e; const i = []; if (t.hasOwnProperty('props')) for (e in t.props)e.substr(0, 1) !== '_' && i.push({ key: e, value: t.props[e] }); else for (e in t)n.indexOf(e) === -1 && e.substr(0, 1) !== '_' && i.push({ key: e, value: t[e] }); return i; }; }, function (t, e, i) {
  const n = i(0); const s = i(2); const r = new n({
    initialize(t) { this.delay = 0, this.repeat = 0, this.repeatCount = 0, this.loop = !1, this.callback, this.callbackScope, this.args, this.timeScale = 1, this.startAt = 0, this.elapsed = 0, this.paused = !1, this.hasDispatched = !1, this.reset(t); }, reset(t) { return this.delay = s(t, 'delay', 0), this.repeat = s(t, 'repeat', 0), this.loop = s(t, 'loop', !1), this.callback = s(t, 'callback', void 0), this.callbackScope = s(t, 'callbackScope', this.callback), this.args = s(t, 'args', []), this.timeScale = s(t, 'timeScale', 1), this.startAt = s(t, 'startAt', 0), this.paused = s(t, 'paused', !1), this.elapsed = this.startAt, this.hasDispatched = !1, this.repeatCount = this.repeat === -1 || this.loop ? 999999999999 : this.repeat, this; }, getProgress() { return this.elapsed / this.delay; }, getOverallProgress() { if (this.repeat > 0) { const t = this.delay + this.delay * this.repeat; return (this.elapsed + this.delay * (this.repeat - this.repeatCount)) / t; } return this.getProgress(); }, getRepeatCount() { return this.repeatCount; }, getElapsed() { return this.elapsed; }, getElapsedSeconds() { return 0.001 * this.elapsed; }, remove(t) { void 0 === t && (t = !1), this.elapsed = this.delay, this.hasDispatched = !t, this.repeatCount = 0; }, destroy() { this.callback = void 0, this.callbackScope = void 0, this.args = []; },
  }); t.exports = r;
}, function (t, e, i) {
  const n = i(0); const s = i(14); const r = i(26); const o = i(19); const a = i(446); const h = i(103); const l = i(38); const u = i(10); const c = new n({
    Extends: o, Mixins: [s.Alpha, s.BlendMode, s.ComputedSize, s.Depth, s.Flip, s.GetBounds, s.Origin, s.Pipeline, s.ScaleMode, s.Transform, s.Visible, s.ScrollFactor, a], initialize(t, e, i, n, s, a) { o.call(this, t, 'StaticTilemapLayer'), this.isTilemap = !0, this.tilemap = e, this.layerIndex = i, this.layer = e.layers[i], this.layer.tilemapLayer = this, this.tileset = [], this.culledTiles = [], this.skipCull = !1, this.tilesDrawn = 0, this.tilesTotal = this.layer.width * this.layer.height, this.cullPaddingX = 1, this.cullPaddingY = 1, this.cullCallback = h.CullTiles, this.renderer = t.sys.game.renderer, this.vertexBuffer = [], this.bufferData = [], this.vertexViewF32 = [], this.vertexViewU32 = [], this.dirty = [], this.vertexCount = [], this._renderOrder = 0, this._tempMatrix = new l(), this.gidMap = [], this.setTilesets(n), this.setAlpha(this.layer.alpha), this.setPosition(s, a), this.setOrigin(), this.setSize(this.layer.tileWidth * this.layer.width, this.layer.tileHeight * this.layer.height), this.updateVBOData(), this.initPipeline('TextureTintPipeline'), t.sys.game.config.renderType === r.WEBGL && t.sys.game.renderer.onContextRestored(function () { this.updateVBOData(); }, this); }, setTilesets(t) { const e = []; const i = []; const n = this.tilemap; Array.isArray(t) || (t = [t]); for (let s = 0; s < t.length; s++) { let r = t[s]; if (typeof r === 'string' && (r = n.getTileset(r)), r) { i.push(r); for (let o = r.firstgid, a = 0; a < r.total; a++)e[o + a] = r; } } this.gidMap = e, this.tileset = i; }, updateVBOData() { for (let t = 0; t < this.tileset.length; t++) this.dirty[t] = !0, this.vertexCount[t] = 0, this.vertexBuffer[t] = null, this.bufferData[t] = null, this.vertexViewF32[t] = null, this.vertexViewU32[t] = null; return this; }, upload(t, e) { const i = this.renderer; const n = i.gl; const s = i.pipelines.TextureTintPipeline; if (this.dirty[e]) { let r; let o; let a; const h = this.tileset[e]; const l = this.layer.width; const u = this.layer.height; const c = h.image.source[0].width; const d = h.image.source[0].height; const f = this.layer.data; const p = this._renderOrder; const g = h.firstgid; const v = h.firstgid + h.total; let y = this.vertexBuffer[e]; let m = this.bufferData[e]; let x = -1; const w = l * u * s.vertexSize * 6; if (this.vertexCount[e] = 0, m === null && (m = new ArrayBuffer(w), this.bufferData[e] = m, this.vertexViewF32[e] = new Float32Array(m), this.vertexViewU32[e] = new Uint32Array(m)), p === 0) for (o = 0; o < u; o++) for (a = 0; a < l; a++)!(r = f[o][a]) || r.index < g || r.index > v || !r.visible || (x = this.batchTile(x, r, h, c, d, t, e)); else if (p === 1) for (o = 0; o < u; o++) for (a = l - 1; a >= 0; a--)!(r = f[o][a]) || r.index < g || r.index > v || !r.visible || (x = this.batchTile(x, r, h, c, d, t, e)); else if (p === 2) for (o = u - 1; o >= 0; o--) for (a = 0; a < l; a++)!(r = f[o][a]) || r.index < g || r.index > v || !r.visible || (x = this.batchTile(x, r, h, c, d, t, e)); else if (p === 3) for (o = u - 1; o >= 0; o--) for (a = l - 1; a >= 0; a--)!(r = f[o][a]) || r.index < g || r.index > v || !r.visible || (x = this.batchTile(x, r, h, c, d, t, e)); this.dirty[e] = !1, y === null ? (y = i.createVertexBuffer(m, n.STATIC_DRAW), this.vertexBuffer[e] = y) : (i.setVertexBuffer(y), n.bufferSubData(n.ARRAY_BUFFER, 0, m)); } return this; }, batchTile(t, e, i, n, s, r, o) { const a = i.getTileTextureCoordinates(e.index); if (!a) return t; const h = a.x / n; const l = a.y / s; const c = (a.x + e.width) / n; const d = (a.y + e.height) / s; const f = this._tempMatrix; let p = e.width; let g = e.height; const v = p / 2; const y = g / 2; let m = -v; let x = -y; e.flipX && (p *= -1, m += e.width), e.flipY && (g *= -1, x += e.height); const w = m + p; const b = x + g; f.applyITRS(v + e.pixelX, y + e.pixelY, e.rotation, 1, 1); const T = u.getTintAppendFloatAlpha(16777215, r.alpha * this.alpha * e.alpha); let S = f.getX(m, x); let _ = f.getY(m, x); let A = f.getX(m, b); let C = f.getY(m, b); let M = f.getX(w, b); let P = f.getY(w, b); let E = f.getX(w, x); let k = f.getY(w, x); r.roundPixels && (S |= 0, _ |= 0, A |= 0, C |= 0, M |= 0, P |= 0, E |= 0, k |= 0); const L = this.vertexViewF32[o]; const F = this.vertexViewU32[o]; return L[++t] = S, L[++t] = _, L[++t] = h, L[++t] = l, L[++t] = 0, F[++t] = T, L[++t] = A, L[++t] = C, L[++t] = h, L[++t] = d, L[++t] = 0, F[++t] = T, L[++t] = M, L[++t] = P, L[++t] = c, L[++t] = d, L[++t] = 0, F[++t] = T, L[++t] = S, L[++t] = _, L[++t] = h, L[++t] = l, L[++t] = 0, F[++t] = T, L[++t] = M, L[++t] = P, L[++t] = c, L[++t] = d, L[++t] = 0, F[++t] = T, L[++t] = E, L[++t] = k, L[++t] = c, L[++t] = l, L[++t] = 0, F[++t] = T, this.vertexCount[o] += 6, t; }, setRenderOrder(t) { if (typeof t === 'string' && (t = ['right-down', 'left-down', 'right-up', 'left-up'].indexOf(t)), t >= 0 && t < 4) { this._renderOrder = t; for (let e = 0; e < this.tileset.length; e++) this.dirty[e] = !0; } return this; }, calculateFacesAt(t, e) { return h.CalculateFacesAt(t, e, this.layer), this; }, calculateFacesWithin(t, e, i, n) { return h.CalculateFacesWithin(t, e, i, n, this.layer), this; }, createFromTiles(t, e, i, n, s) { return h.CreateFromTiles(t, e, i, n, s, this.layer); }, cull(t) { return this.cullCallback(this.layer, t, this.culledTiles); }, setSkipCull(t) { return void 0 === t && (t = !0), this.skipCull = t, this; }, setCullPadding(t, e) { return void 0 === t && (t = 1), void 0 === e && (e = 1), this.cullPaddingX = t, this.cullPaddingY = e, this; }, findByIndex(t, e, i) { return h.FindByIndex(t, e, i, this.layer); }, findTile(t, e, i, n, s, r, o) { return h.FindTile(t, e, i, n, s, r, o, this.layer); }, filterTiles(t, e, i, n, s, r, o) { return h.FilterTiles(t, e, i, n, s, r, o, this.layer); }, forEachTile(t, e, i, n, s, r, o) { return h.ForEachTile(t, e, i, n, s, r, o, this.layer), this; }, getTileAt(t, e, i) { return h.GetTileAt(t, e, i, this.layer); }, getTileAtWorldXY(t, e, i, n) { return h.GetTileAtWorldXY(t, e, i, n, this.layer); }, getTilesWithin(t, e, i, n, s) { return h.GetTilesWithin(t, e, i, n, s, this.layer); }, getTilesWithinWorldXY(t, e, i, n, s, r) { return h.GetTilesWithinWorldXY(t, e, i, n, s, r, this.layer); }, getTilesWithinShape(t, e, i) { return h.GetTilesWithinShape(t, e, i, this.layer); }, hasTileAt(t, e) { return h.HasTileAt(t, e, this.layer); }, hasTileAtWorldXY(t, e, i) { return h.HasTileAtWorldXY(t, e, i, this.layer); }, renderDebug(t, e) { return h.RenderDebug(t, e, this.layer), this; }, setCollision(t, e, i) { return h.SetCollision(t, e, i, this.layer), this; }, setCollisionBetween(t, e, i, n) { return h.SetCollisionBetween(t, e, i, n, this.layer), this; }, setCollisionByProperty(t, e, i) { return h.SetCollisionByProperty(t, e, i, this.layer), this; }, setCollisionByExclusion(t, e, i) { return h.SetCollisionByExclusion(t, e, i, this.layer), this; }, setTileIndexCallback(t, e, i) { return h.SetTileIndexCallback(t, e, i, this.layer), this; }, setCollisionFromCollisionGroup(t, e) { return h.SetCollisionFromCollisionGroup(t, e, this.layer), this; }, setTileLocationCallback(t, e, i, n, s, r) { return h.SetTileLocationCallback(t, e, i, n, s, r, this.layer), this; }, tileToWorldX(t, e) { return h.TileToWorldX(t, e, this.layer); }, tileToWorldY(t, e) { return h.TileToWorldY(t, e, this.layer); }, tileToWorldXY(t, e, i, n) { return h.TileToWorldXY(t, e, i, n, this.layer); }, worldToTileX(t, e, i) { return h.WorldToTileX(t, e, i, this.layer); }, worldToTileY(t, e, i) { return h.WorldToTileY(t, e, i, this.layer); }, worldToTileXY(t, e, i, n, s) { return h.WorldToTileXY(t, e, i, n, s, this.layer); }, destroy() { this.layer.tilemapLayer === this && (this.layer.tilemapLayer = void 0), this.tilemap = void 0, this.layer = void 0, this.culledTiles.length = 0, this.cullCallback = null; for (let t = 0; t < this.tileset.length; t++) this.dirty[t] = !0, this.vertexCount[t] = 0, this.vertexBuffer[t] = null, this.bufferData[t] = null, this.vertexViewF32[t] = null, this.vertexViewU32[t] = null; this.gidMap = [], this.tileset = [], o.prototype.destroy.call(this); },
  }); t.exports = c;
}, function (t, e, i) {
  const n = i(0); const s = i(14); const r = i(449); const o = i(19); const a = i(103); const h = new n({
    Extends: o, Mixins: [s.Alpha, s.BlendMode, s.ComputedSize, s.Depth, s.Flip, s.GetBounds, s.Origin, s.Pipeline, s.ScaleMode, s.Transform, s.Visible, s.ScrollFactor, r], initialize(t, e, i, n, s, r) { o.call(this, t, 'DynamicTilemapLayer'), this.isTilemap = !0, this.tilemap = e, this.layerIndex = i, this.layer = e.layers[i], this.layer.tilemapLayer = this, this.tileset = [], this.culledTiles = [], this.skipCull = !1, this.tilesDrawn = 0, this.tilesTotal = this.layer.width * this.layer.height, this.cullPaddingX = 1, this.cullPaddingY = 1, this.cullCallback = a.CullTiles, this._renderOrder = 0, this.gidMap = [], this.setTilesets(n), this.setAlpha(this.layer.alpha), this.setPosition(s, r), this.setOrigin(), this.setSize(this.layer.tileWidth * this.layer.width, this.layer.tileHeight * this.layer.height), this.initPipeline('TextureTintPipeline'); }, setTilesets(t) { const e = []; const i = []; const n = this.tilemap; Array.isArray(t) || (t = [t]); for (let s = 0; s < t.length; s++) { let r = t[s]; if (typeof r === 'string' && (r = n.getTileset(r)), r) { i.push(r); for (let o = r.firstgid, a = 0; a < r.total; a++)e[o + a] = r; } } this.gidMap = e, this.tileset = i; }, setRenderOrder(t) { return typeof t === 'string' && (t = ['right-down', 'left-down', 'right-up', 'left-up'].indexOf(t)), t >= 0 && t < 4 && (this._renderOrder = t), this; }, calculateFacesAt(t, e) { return a.CalculateFacesAt(t, e, this.layer), this; }, calculateFacesWithin(t, e, i, n) { return a.CalculateFacesWithin(t, e, i, n, this.layer), this; }, createFromTiles(t, e, i, n, s) { return a.CreateFromTiles(t, e, i, n, s, this.layer); }, cull(t) { return this.cullCallback(this.layer, t, this.culledTiles, this._renderOrder); }, copy(t, e, i, n, s, r, o) { return a.Copy(t, e, i, n, s, r, o, this.layer), this; }, destroy() { this.layer.tilemapLayer === this && (this.layer.tilemapLayer = void 0), this.tilemap = void 0, this.layer = void 0, this.culledTiles.length = 0, this.cullCallback = null, this.gidMap = [], this.tileset = [], o.prototype.destroy.call(this); }, fill(t, e, i, n, s, r) { return a.Fill(t, e, i, n, s, r, this.layer), this; }, filterTiles(t, e, i, n, s, r, o) { return a.FilterTiles(t, e, i, n, s, r, o, this.layer); }, findByIndex(t, e, i) { return a.FindByIndex(t, e, i, this.layer); }, findTile(t, e, i, n, s, r, o) { return a.FindTile(t, e, i, n, s, r, o, this.layer); }, forEachTile(t, e, i, n, s, r, o) { return a.ForEachTile(t, e, i, n, s, r, o, this.layer), this; }, getTileAt(t, e, i) { return a.GetTileAt(t, e, i, this.layer); }, getTileAtWorldXY(t, e, i, n) { return a.GetTileAtWorldXY(t, e, i, n, this.layer); }, getTilesWithin(t, e, i, n, s) { return a.GetTilesWithin(t, e, i, n, s, this.layer); }, getTilesWithinShape(t, e, i) { return a.GetTilesWithinShape(t, e, i, this.layer); }, getTilesWithinWorldXY(t, e, i, n, s, r) { return a.GetTilesWithinWorldXY(t, e, i, n, s, r, this.layer); }, hasTileAt(t, e) { return a.HasTileAt(t, e, this.layer); }, hasTileAtWorldXY(t, e, i) { return a.HasTileAtWorldXY(t, e, i, this.layer); }, putTileAt(t, e, i, n) { return a.PutTileAt(t, e, i, n, this.layer); }, putTileAtWorldXY(t, e, i, n, s) { return a.PutTileAtWorldXY(t, e, i, n, s, this.layer); }, putTilesAt(t, e, i, n) { return a.PutTilesAt(t, e, i, n, this.layer), this; }, randomize(t, e, i, n, s) { return a.Randomize(t, e, i, n, s, this.layer), this; }, removeTileAt(t, e, i, n) { return a.RemoveTileAt(t, e, i, n, this.layer); }, removeTileAtWorldXY(t, e, i, n, s) { return a.RemoveTileAtWorldXY(t, e, i, n, s, this.layer); }, renderDebug(t, e) { return a.RenderDebug(t, e, this.layer), this; }, replaceByIndex(t, e, i, n, s, r) { return a.ReplaceByIndex(t, e, i, n, s, r, this.layer), this; }, setSkipCull(t) { return void 0 === t && (t = !0), this.skipCull = t, this; }, setCullPadding(t, e) { return void 0 === t && (t = 1), void 0 === e && (e = 1), this.cullPaddingX = t, this.cullPaddingY = e, this; }, setCollision(t, e, i) { return a.SetCollision(t, e, i, this.layer), this; }, setCollisionBetween(t, e, i, n) { return a.SetCollisionBetween(t, e, i, n, this.layer), this; }, setCollisionByProperty(t, e, i) { return a.SetCollisionByProperty(t, e, i, this.layer), this; }, setCollisionByExclusion(t, e, i) { return a.SetCollisionByExclusion(t, e, i, this.layer), this; }, setCollisionFromCollisionGroup(t, e) { return a.SetCollisionFromCollisionGroup(t, e, this.layer), this; }, setTileIndexCallback(t, e, i) { return a.SetTileIndexCallback(t, e, i, this.layer), this; }, setTileLocationCallback(t, e, i, n, s, r) { return a.SetTileLocationCallback(t, e, i, n, s, r, this.layer), this; }, shuffle(t, e, i, n) { return a.Shuffle(t, e, i, n, this.layer), this; }, swapByIndex(t, e, i, n, s, r) { return a.SwapByIndex(t, e, i, n, s, r, this.layer), this; }, tileToWorldX(t, e) { return a.TileToWorldX(t, e, this.layer); }, tileToWorldY(t, e) { return a.TileToWorldY(t, e, this.layer); }, tileToWorldXY(t, e, i, n) { return a.TileToWorldXY(t, e, i, n, this.layer); }, weightedRandomize(t, e, i, n, s) { return a.WeightedRandomize(t, e, i, n, s, this.layer), this; }, worldToTileX(t, e, i) { return a.WorldToTileX(t, e, i, this.layer); }, worldToTileY(t, e, i) { return a.WorldToTileY(t, e, i, this.layer); }, worldToTileXY(t, e, i, n, s) { return a.WorldToTileXY(t, e, i, n, s, this.layer); },
  }); t.exports = h;
}, function (t, e, i) {
  const n = i(0); const s = i(31); const r = i(208); const o = i(20); const a = i(29); const h = i(78); const l = i(242); const u = i(207); const c = i(55); const d = i(103); const f = i(99); const p = new n({
    initialize(t, e) { this.scene = t, this.tileWidth = e.tileWidth, this.tileHeight = e.tileHeight, this.width = e.width, this.height = e.height, this.orientation = e.orientation, this.renderOrder = e.renderOrder, this.format = e.format, this.version = e.version, this.properties = e.properties, this.widthInPixels = e.widthInPixels, this.heightInPixels = e.heightInPixels, this.imageCollections = e.imageCollections, this.images = e.images, this.layers = e.layers, this.tilesets = e.tilesets, this.objects = e.objects, this.currentLayerIndex = 0; },
    setRenderOrder(t) { const e = ['right-down', 'left-down', 'right-up', 'left-up']; return typeof t === 'number' && (t = e[t]), e.indexOf(t) > -1 && (this.renderOrder = t), this; },
    addTilesetImage(t, e, i, n, s, r, o) { if (void 0 === t) return null; if (void 0 !== e && e !== null || (e = t), !this.scene.sys.textures.exists(e)) return console.warn(`Invalid Tileset Image: ${e}`), null; const h = this.scene.sys.textures.get(e); const l = this.getTilesetIndex(t); if (l === null && this.format === a.TILED_JSON) return console.warn(`No data found for Tileset: ${t}`), null; let u = this.tilesets[l]; return u ? (u.setTileSize(i, n), u.setSpacing(s, r), u.setImage(h), u) : (void 0 === i && (i = this.tileWidth), void 0 === n && (n = this.tileHeight), void 0 === s && (s = 0), void 0 === r && (r = 0), void 0 === o && (o = 0), (u = new f(t, o, i, n, s, r)).setImage(h), this.tilesets.push(u), u); },
    convertLayerToStatic(t) { if ((t = this.getLayer(t)) === null) return null; const e = t.tilemapLayer; if (!(e && e instanceof r)) return null; const i = new u(e.scene, e.tilemap, e.layerIndex, e.tileset, e.x, e.y); return this.scene.sys.displayList.add(i), e.destroy(), i; },
    copy(t, e, i, n, s, r, o, a) { return a = this.getLayer(a), this._isStaticCall(a, 'copy') ? this : (a !== null && d.Copy(t, e, i, n, s, r, o, a), this); },
    createBlankDynamicLayer(t, e, i, n, s, o, a, l) {
      if (void 0 === a && (a = e.tileWidth), void 0 === l && (l = e.tileHeight), void 0 === s && (s = this.width), void 0 === o && (o = this.height), void 0 === i && (i = 0), void 0 === n && (n = 0), this.getLayerIndex(t) !== null) return console.warn(`Invalid Tilemap Layer ID: ${t}`), null; for (var u, d = new h({
          name: t, tileWidth: a, tileHeight: l, width: s, height: o,
        }), f = 0; f < o; f++) { u = []; for (let p = 0; p < s; p++)u.push(new c(d, -1, p, f, a, l, this.tileWidth, this.tileHeight)); d.data.push(u); } this.layers.push(d), this.currentLayerIndex = this.layers.length - 1; const g = new r(this.scene, this, this.currentLayerIndex, e, i, n); return g.setRenderOrder(this.renderOrder), this.scene.sys.displayList.add(g), g;
    },
    createDynamicLayer(t, e, i, n) { const s = this.getLayerIndex(t); if (s === null) return console.warn(`Invalid Tilemap Layer ID: ${t}`), null; if (this.layers[s].tilemapLayer) return console.warn(`Tilemap Layer ID already exists:${t}`), null; this.currentLayerIndex = s, void 0 === i && this.layers[s].x && (i = this.layers[s].x), void 0 === n && this.layers[s].y && (n = this.layers[s].y); const o = new r(this.scene, this, s, e, i, n); return o.setRenderOrder(this.renderOrder), this.scene.sys.displayList.add(o), o; },
    createFromObjects(t, e, i, n) { void 0 === i && (i = {}), void 0 === n && (n = this.scene); const r = this.getObjectLayer(t); if (r) { for (var a = r.objects, h = [], u = 0; u < a.length; u++) { let c = !1; const d = a[u]; if ((void 0 !== d.gid && typeof e === 'number' && d.gid === e || void 0 !== d.id && typeof e === 'number' && d.id === e || void 0 !== d.name && typeof e === 'string' && d.name === e) && (c = !0), c) { const f = o({}, i, d.properties); f.x = d.x, f.y = d.y; const p = this.scene.make.sprite(f); p.name = d.name, d.width && (p.displayWidth = d.width), d.height && (p.displayHeight = d.height); const g = { x: p.originX * p.displayWidth, y: (p.originY - 1) * p.displayHeight }; if (d.rotation) { const v = s(d.rotation); l(g, v), p.rotation = v; } for (const y in p.x += g.x, p.y += g.y, void 0 === d.flippedHorizontal && void 0 === d.flippedVertical || p.setFlip(d.flippedHorizontal, d.flippedVertical), d.visible || (p.visible = !1), d.properties)p.hasOwnProperty(y) || p.setData(y, d.properties[y]); h.push(p); } } return h; }console.warn(`Cannot create from object. Invalid objectgroup name given: ${t}`); },
    createFromTiles(t, e, i, n, s, r) { return (r = this.getLayer(r)) === null ? null : d.CreateFromTiles(t, e, i, n, s, r); },
    createStaticLayer(t, e, i, n) { const s = this.getLayerIndex(t); if (s === null) return console.warn(`Invalid Tilemap Layer ID: ${t}`), null; if (this.layers[s].tilemapLayer) return console.warn(`Tilemap Layer ID already exists:${t}`), null; this.currentLayerIndex = s, void 0 === i && this.layers[s].x && (i = this.layers[s].x), void 0 === n && this.layers[s].y && (n = this.layers[s].y); const r = new u(this.scene, this, s, e, i, n); return r.setRenderOrder(this.renderOrder), this.scene.sys.displayList.add(r), r; },
    destroy() { this.removeAllLayers(), this.tilesets.length = 0, this.objects.length = 0, this.scene = void 0; },
    fill(t, e, i, n, s, r, o) { return o = this.getLayer(o), this._isStaticCall(o, 'fill') ? this : (o !== null && d.Fill(t, e, i, n, s, r, o), this); },
    filterObjects(t, e, i) { if (typeof t === 'string') { const n = t; if (!(t = this.getObjectLayer(t))) return console.warn(`No object layer found with the name: ${n}`), null; } return t.objects.filter(e, i); },
    filterTiles(t, e, i, n, s, r, o, a) { return (a = this.getLayer(a)) === null ? null : d.FilterTiles(t, e, i, n, s, r, o, a); },
    findByIndex(t, e, i, n) { return (n = this.getLayer(n)) === null ? null : d.FindByIndex(t, e, i, n); },
    findObject(t, e, i) { if (typeof t === 'string') { const n = t; if (!(t = this.getObjectLayer(t))) return console.warn(`No object layer found with the name: ${n}`), null; } return t.objects.find(e, i) || null; },
    findTile(t, e, i, n, s, r, o, a) { return (a = this.getLayer(a)) === null ? null : d.FindTile(t, e, i, n, s, r, o, a); },
    forEachTile(t, e, i, n, s, r, o, a) { return (a = this.getLayer(a)) !== null && d.ForEachTile(t, e, i, n, s, r, o, a), this; },
    getImageIndex(t) { return this.getIndex(this.images, t); },
    getIndex(t, e) { for (let i = 0; i < t.length; i++) if (t[i].name === e) return i; return null; },
    getLayer(t) { const e = this.getLayerIndex(t); return e !== null ? this.layers[e] : null; },
    getObjectLayer(t) { const e = this.getIndex(this.objects, t); return e !== null ? this.objects[e] : null; },
    getLayerIndex(t) { return void 0 === t ? this.currentLayerIndex : typeof t === 'string' ? this.getLayerIndexByName(t) : typeof t === 'number' && t < this.layers.length ? t : t instanceof u || t instanceof r ? t.layerIndex : null; },
    getLayerIndexByName(t) { return this.getIndex(this.layers, t); },
    getTileAt(t, e, i, n) { return (n = this.getLayer(n)) === null ? null : d.GetTileAt(t, e, i, n); },
    getTileAtWorldXY(t, e, i, n, s) { return (s = this.getLayer(s)) === null ? null : d.GetTileAtWorldXY(t, e, i, n, s); },
    getTilesWithin(t, e, i, n, s, r) { return (r = this.getLayer(r)) === null ? null : d.GetTilesWithin(t, e, i, n, s, r); },
    getTilesWithinShape(t, e, i, n) { return (n = this.getLayer(n)) === null ? null : d.GetTilesWithinShape(t, e, i, n); },
    getTilesWithinWorldXY(t, e, i, n, s, r, o) { return (o = this.getLayer(o)) === null ? null : d.GetTilesWithinWorldXY(t, e, i, n, s, r, o); },
    getTileset(t) { const e = this.getIndex(this.tilesets, t); return e !== null ? this.tilesets[e] : null; },
    getTilesetIndex(t) { return this.getIndex(this.tilesets, t); },
    hasTileAt(t, e, i) { return (i = this.getLayer(i)) === null ? null : d.HasTileAt(t, e, i); },
    hasTileAtWorldXY(t, e, i, n) { return (n = this.getLayer(n)) === null ? null : d.HasTileAtWorldXY(t, e, i, n); },
    layer: { get() { return this.layers[this.currentLayerIndex]; }, set(t) { this.setLayer(t); } },
    putTileAt(t, e, i, n, s) { return s = this.getLayer(s), this._isStaticCall(s, 'putTileAt') ? null : s === null ? null : d.PutTileAt(t, e, i, n, s); },
    putTileAtWorldXY(t, e, i, n, s, r) { return r = this.getLayer(r), this._isStaticCall(r, 'putTileAtWorldXY') ? null : r === null ? null : d.PutTileAtWorldXY(t, e, i, n, s, r); },
    putTilesAt(t, e, i, n, s) { return s = this.getLayer(s), this._isStaticCall(s, 'putTilesAt') ? this : (s !== null && d.PutTilesAt(t, e, i, n, s), this); },
    randomize(t, e, i, n, s, r) { return r = this.getLayer(r), this._isStaticCall(r, 'randomize') ? this : (r !== null && d.Randomize(t, e, i, n, s, r), this); },
    calculateFacesAt(t, e, i) { return (i = this.getLayer(i)) === null ? this : (d.CalculateFacesAt(t, e, i), this); },
    calculateFacesWithin(t, e, i, n, s) { return (s = this.getLayer(s)) === null ? this : (d.CalculateFacesWithin(t, e, i, n, s), this); },
    removeAllLayers() { for (let t = 0; t < this.layers.length; t++) this.layers[t].tilemapLayer && this.layers[t].tilemapLayer.destroy(); return this.layers.length = 0, this.currentLayerIndex = 0, this; },
    removeTileAt(t, e, i, n, s) { return s = this.getLayer(s), this._isStaticCall(s, 'removeTileAt') ? null : s === null ? null : d.RemoveTileAt(t, e, i, n, s); },
    removeTileAtWorldXY(t, e, i, n, s, r) { return r = this.getLayer(r), this._isStaticCall(r, 'removeTileAtWorldXY') ? null : r === null ? null : d.RemoveTileAtWorldXY(t, e, i, n, s, r); },
    renderDebug(t, e, i) { return (i = this.getLayer(i)) === null ? this : (d.RenderDebug(t, e, i), this); },
    replaceByIndex(t, e, i, n, s, r, o) { return o = this.getLayer(o), this._isStaticCall(o, 'replaceByIndex') ? this : (o !== null && d.ReplaceByIndex(t, e, i, n, s, r, o), this); },
    setCollision(t, e, i, n) { return (n = this.getLayer(n)) === null ? this : (d.SetCollision(t, e, i, n), this); },
    setCollisionBetween(t, e, i, n, s) { return (s = this.getLayer(s)) === null ? this : (d.SetCollisionBetween(t, e, i, n, s), this); },
    setCollisionByProperty(t, e, i, n) { return (n = this.getLayer(n)) === null ? this : (d.SetCollisionByProperty(t, e, i, n), this); },
    setCollisionByExclusion(t, e, i, n) { return (n = this.getLayer(n)) === null ? this : (d.SetCollisionByExclusion(t, e, i, n), this); },
    setCollisionFromCollisionGroup(t, e, i) { return (i = this.getLayer(i)) === null ? this : (d.SetCollisionFromCollisionGroup(t, e, i), this); },
    setTileIndexCallback(t, e, i, n) { return (n = this.getLayer(n)) === null ? this : (d.SetTileIndexCallback(t, e, i, n), this); },
    setTileLocationCallback(t, e, i, n, s, r, o) { return (o = this.getLayer(o)) === null ? this : (d.SetTileLocationCallback(t, e, i, n, s, r, o), this); },
    setLayer(t) { const e = this.getLayerIndex(t); return e !== null && (this.currentLayerIndex = e), this; },
    setBaseTileSize(t, e) { this.tileWidth = t, this.tileHeight = e, this.widthInPixels = this.width * t, this.heightInPixels = this.height * e; for (let i = 0; i < this.layers.length; i++) { this.layers[i].baseTileWidth = t, this.layers[i].baseTileHeight = e; for (let n = this.layers[i].data, s = this.layers[i].width, r = this.layers[i].height, o = 0; o < r; ++o) for (let a = 0; a < s; ++a) { const h = n[o][a]; h !== null && h.setSize(void 0, void 0, t, e); } } return this; },
    setLayerTileSize(t, e, i) { if ((i = this.getLayer(i)) === null) return this; i.tileWidth = t, i.tileHeight = e; for (let n = i.data, s = i.width, r = i.height, o = 0; o < r; ++o) for (let a = 0; a < s; ++a) { const h = n[o][a]; h !== null && h.setSize(t, e); } return this; },
    shuffle(t, e, i, n, s) { return s = this.getLayer(s), this._isStaticCall(s, 'shuffle') ? this : (s !== null && d.Shuffle(t, e, i, n, s), this); },
    swapByIndex(t, e, i, n, s, r, o) { return o = this.getLayer(o), this._isStaticCall(o, 'swapByIndex') ? this : (o !== null && d.SwapByIndex(t, e, i, n, s, r, o), this); },
    tileToWorldX(t, e, i) { return (i = this.getLayer(i)) === null ? null : d.TileToWorldX(t, e, i); },
    tileToWorldY(t, e, i) { return (i = this.getLayer(i)) === null ? null : d.TileToWorldY(t, e, i); },
    tileToWorldXY(t, e, i, n, s) { return (s = this.getLayer(s)) === null ? null : d.TileToWorldXY(t, e, i, n, s); },
    weightedRandomize(t, e, i, n, s, r) { return r = this.getLayer(r), this._isStaticCall(r, 'weightedRandomize') ? this : (r !== null && d.WeightedRandomize(t, e, i, n, s, r), this); },
    worldToTileX(t, e, i, n) { return (n = this.getLayer(n)) === null ? null : d.WorldToTileX(t, e, i, n); },
    worldToTileY(t, e, i, n) { return (n = this.getLayer(n)) === null ? null : d.WorldToTileY(t, e, i, n); },
    worldToTileXY(t, e, i, n, s, r) { return (r = this.getLayer(r)) === null ? null : d.WorldToTileXY(t, e, i, n, s, r); },
    _isStaticCall(t, e) { return t.tilemapLayer instanceof u && (console.warn(`${e}: You cannot change the tiles in a static tilemap layer`), !0); },
  }); t.exports = p;
}, function (t, e, i) {
  const n = i(29); const s = i(77); const r = i(451); const o = i(450); t.exports = function (t, e, i) {
    if (e.layer.length === 0) return console.warn(`No layers found in the Weltmeister map: ${t}`), null; for (var a = 0, h = 0, l = 0; l < e.layer.length; l++)e.layer[l].width > a && (a = e.layer[l].width), e.layer[l].height > h && (h = e.layer[l].height); const u = new s({
      width: a, height: h, name: t, tileWidth: e.layer[0].tilesize, tileHeight: e.layer[0].tilesize, format: n.WELTMEISTER,
    }); return u.layers = r(e, i), u.tilesets = o(e), u;
  };
}, function (t, e, i) { const n = i(0); const s = i(2); const r = new n({ initialize(t) { void 0 === t && (t = {}), this.name = s(t, 'name', 'object layer'), this.opacity = s(t, 'opacity', 1), this.properties = s(t, 'properties', {}), this.propertyTypes = s(t, 'propertytypes', {}), this.type = s(t, 'type', 'objectgroup'), this.visible = s(t, 'visible', !0), this.objects = s(t, 'objects', []); } }); t.exports = r; }, function (t, e, i) { const n = i(455); const s = i(214); const r = function (t) { return { x: t.x, y: t.y }; }; const o = ['id', 'name', 'type', 'rotation', 'properties', 'visible', 'x', 'y', 'width', 'height']; t.exports = function (t, e, i) { void 0 === e && (e = 0), void 0 === i && (i = 0); const a = n(t, o); if (a.x += e, a.y += i, t.gid) { const h = s(t.gid); a.gid = h.gid, a.flippedHorizontal = h.flippedHorizontal, a.flippedVertical = h.flippedVertical, a.flippedAntiDiagonal = h.flippedAntiDiagonal; } else t.polyline ? a.polyline = t.polyline.map(r) : t.polygon ? a.polygon = t.polygon.map(r) : t.ellipse ? (a.ellipse = t.ellipse, a.width = t.width, a.height = t.height) : t.text ? (a.width = t.width, a.height = t.height, a.text = t.text) : (a.rectangle = !0, a.width = t.width, a.height = t.height); return a; }; }, function (t, e, i) { const n = new (i(0))({ initialize(t, e, i, n, s, r, o) { (void 0 === i || i <= 0) && (i = 32), (void 0 === n || n <= 0) && (n = 32), void 0 === s && (s = 0), void 0 === r && (r = 0), this.name = t, this.firstgid = 0 | e, this.imageWidth = 0 | i, this.imageHeight = 0 | n, this.imageMargin = 0 | s, this.imageSpacing = 0 | r, this.properties = o || {}, this.images = [], this.total = 0; }, containsImageIndex(t) { return t >= this.firstgid && t < this.firstgid + this.total; }, addImage(t, e) { return this.images.push({ gid: t, image: e }), this.total++, this; } }); t.exports = n; }, function (t, e) {
  t.exports = function (t) {
    const e = Boolean(2147483648 & t); const i = Boolean(1073741824 & t); const n = Boolean(536870912 & t); t &= 536870911; let s = 0; let r = !1; return e && i && n ? (s = Math.PI / 2, r = !0) : e && i && !n ? (s = Math.PI, r = !1) : e && !i && n ? (s = Math.PI / 2, r = !1) : !e || i || n ? !e && i && n ? (s = 3 * Math.PI / 2, r = !1) : e || !i || n ? e || i || !n ? e || i || n || (s = 0, r = !1) : (s = 3 * Math.PI / 2, r = !0) : (s = Math.PI, r = !0) : (s = 0, r = !0), {
      gid: t, flippedHorizontal: e, flippedVertical: i, flippedAntiDiagonal: n, rotation: s, flipped: r,
    };
  };
}, function (t, e, i) {
  const n = i(29); const s = i(77); const r = i(459); const o = i(457); const a = i(456); const h = i(454); const l = i(453); const u = i(452); t.exports = function (t, e, i) {
    if (e.orientation !== 'orthogonal') return console.warn('Only orthogonal map types are supported in this version of Phaser'), null; const c = new s({
      width: e.width, height: e.height, name: t, tileWidth: e.tilewidth, tileHeight: e.tileheight, orientation: e.orientation, format: n.TILED_JSON, version: e.version, properties: e.properties, renderOrder: e.renderorder,
    }); c.layers = r(e, i), c.images = o(e); const d = a(e); return c.tilesets = d.tilesets, c.imageCollections = d.imageCollections, c.objects = h(e), c.tiles = l(c), u(c), c;
  };
}, function (t, e, i) { const n = i(29); const s = i(133); t.exports = function (t, e, i, r, o) { const a = e.trim().split('\n').map((t) => t.split(',')); const h = s(t, a, i, r, o); return h.format = n.CSV, h; }; }, function (t, e, i) { const n = i(29); const s = i(133); const r = i(216); const o = i(215); const a = i(210); t.exports = function (t, e, i, h, l, u) { let c; switch (e) { case n.ARRAY_2D: c = s(t, i, h, l, u); break; case n.CSV: c = r(t, i, h, l, u); break; case n.TILED_JSON: c = o(t, i, u); break; case n.WELTMEISTER: c = a(t, i, u); break; default: console.warn(`Unrecognized tilemap data format: ${e}`), c = null; } return c; }; }, function (t, e, i) { const n = i(55); const s = i(79); const r = i(136); t.exports = function (t, e, i, o, a) { if (void 0 === i && (i = !1), void 0 === o && (o = !0), !s(t, e, a)) return null; const h = a.data[e][t]; return h === null ? null : (a.data[e][t] = i ? null : new n(a, -1, t, e, h.width, h.height), o && h && h.collides && r(t, e, a), h); }; }, function (t, e, i) { const n = i(79); t.exports = function (t, e, i) { if (n(t, e, i)) { const s = i.data[e][t]; return s !== null && s.index > -1; } return !1; }; }, function (t, e, i) { const n = i(17); t.exports = function (t, e, i, s, r, o, a) { for (let h = n(i, s, r, o, null, a), l = 0; l < h.length; l++)h[l] && h[l].index === t && (h[l].index = e); }; }, function (t, e, i) {
  const n = new (i(0))({
    initialize(t) { this.pluginManager = t, this.game = t.game, this.scene, this.systems; }, init() {}, start() {}, stop() {}, boot() {}, destroy() { this.pluginManager = null, this.game = null, this.scene = null, this.systems = null; },
  }); t.exports = n;
}, function (t, e, i) { const n = {}; t.exports = n; const s = i(195); n._motionWakeThreshold = 0.18, n._motionSleepThreshold = 0.08, n._minBias = 0.9, n.update = function (t, e) { for (let i = e * e * e, s = 0; s < t.length; s++) { const r = t[s]; const o = r.speed * r.speed + r.angularSpeed * r.angularSpeed; if (r.force.x === 0 && r.force.y === 0) { const a = Math.min(r.motion, o); const h = Math.max(r.motion, o); r.motion = n._minBias * a + (1 - n._minBias) * h, r.sleepThreshold > 0 && r.motion < n._motionSleepThreshold * i ? (r.sleepCounter += 1, r.sleepCounter >= r.sleepThreshold && n.set(r, !0)) : r.sleepCounter > 0 && (r.sleepCounter -= 1); } else n.set(r, !1); } }, n.afterCollisions = function (t, e) { for (let i = e * e * e, s = 0; s < t.length; s++) { const r = t[s]; if (r.isActive) { const o = r.collision; const a = o.bodyA.parent; const h = o.bodyB.parent; if (!(a.isSleeping && h.isSleeping || a.isStatic || h.isStatic) && (a.isSleeping || h.isSleeping)) { const l = a.isSleeping && !a.isStatic ? a : h; const u = l === a ? h : a; !l.isStatic && u.motion > n._motionWakeThreshold * i && n.set(l, !1); } } } }, n.set = function (t, e) { const i = t.isSleeping; e ? (t.isSleeping = !0, t.sleepCounter = t.sleepThreshold, t.positionImpulse.x = 0, t.positionImpulse.y = 0, t.positionPrev.x = t.position.x, t.positionPrev.y = t.position.y, t.anglePrev = t.angle, t.speed = 0, t.angularSpeed = 0, t.motion = 0, i || s.trigger(t, 'sleepStart')) : (t.isSleeping = !1, t.sleepCounter = 0, i && s.trigger(t, 'sleepEnd')); }; }, function (t, e) {
  t.exports = {
    NONE: 0, A: 1, B: 2, BOTH: 3,
  };
}, function (t, e) {
  t.exports = {
    NEVER: 0, LITE: 1, PASSIVE: 2, ACTIVE: 4, FIXED: 8,
  };
}, function (t, e, i) {
  const n = i(40); const s = i(0); const r = i(35); const o = i(39); const a = i(3); const h = new s({
    initialize(t, e) {
      const i = e.width ? e.width : 64; const n = e.height ? e.height : 64; this.world = t, this.gameObject = e, this.debugShowBody = t.defaults.debugShowStaticBody, this.debugBodyColor = t.defaults.staticBodyDebugColor, this.enable = !0, this.isCircle = !1, this.radius = 0, this.offset = new a(), this.position = new a(e.x - e.displayOriginX, e.y - e.displayOriginY), this.width = i, this.height = n, this.halfWidth = Math.abs(this.width / 2), this.halfHeight = Math.abs(this.height / 2), this.center = new a(e.x + this.halfWidth, e.y + this.halfHeight), this.velocity = a.ZERO, this.allowGravity = !1, this.gravity = a.ZERO, this.bounce = a.ZERO, this.onWorldBounds = !1, this.onCollide = !1, this.onOverlap = !1, this.mass = 1, this.immovable = !0, this.customSeparateX = !1, this.customSeparateY = !1, this.overlapX = 0, this.overlapY = 0, this.overlapR = 0, this.embedded = !1, this.collideWorldBounds = !1, this.checkCollision = {
        none: !1, up: !0, down: !0, left: !0, right: !0,
      }, this.touching = {
        none: !0, up: !1, down: !1, left: !1, right: !1,
      }, this.wasTouching = {
        none: !0, up: !1, down: !1, left: !1, right: !1,
      }, this.blocked = {
        none: !0, up: !1, down: !1, left: !1, right: !1,
      }, this.physicsType = r.STATIC_BODY, this._dx = 0, this._dy = 0;
    },
    setGameObject(t, e) { return t && t !== this.gameObject && (this.gameObject.body = null, t.body = this, this.gameObject = t), e && this.updateFromGameObject(), this; },
    updateFromGameObject() { this.world.staticTree.remove(this); const t = this.gameObject; return t.getTopLeft(this.position), this.width = t.displayWidth, this.height = t.displayHeight, this.halfWidth = Math.abs(this.width / 2), this.halfHeight = Math.abs(this.height / 2), this.center.set(this.position.x + this.halfWidth, this.position.y + this.halfHeight), this.world.staticTree.insert(this), this; },
    setOffset(t, e) { return void 0 === e && (e = t), this.world.staticTree.remove(this), this.position.x -= this.offset.x, this.position.y -= this.offset.y, this.offset.set(t, e), this.position.x += this.offset.x, this.position.y += this.offset.y, this.updateCenter(), this.world.staticTree.insert(this), this; },
    setSize(t, e, i, n) { void 0 === i && (i = this.offset.x), void 0 === n && (n = this.offset.y); const s = this.gameObject; return !t && s.frame && (t = s.frame.realWidth), !e && s.frame && (e = s.frame.realHeight), this.world.staticTree.remove(this), this.width = t, this.height = e, this.halfWidth = Math.floor(t / 2), this.halfHeight = Math.floor(e / 2), this.offset.set(i, n), this.updateCenter(), this.isCircle = !1, this.radius = 0, this.world.staticTree.insert(this), this; },
    setCircle(t, e, i) { return void 0 === e && (e = this.offset.x), void 0 === i && (i = this.offset.y), t > 0 ? (this.world.staticTree.remove(this), this.isCircle = !0, this.radius = t, this.width = 2 * t, this.height = 2 * t, this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.offset.set(e, i), this.updateCenter(), this.world.staticTree.insert(this)) : this.isCircle = !1, this; },
    updateCenter() { this.center.set(this.position.x + this.halfWidth, this.position.y + this.halfHeight); },
    reset(t, e) { const i = this.gameObject; void 0 === t && (t = i.x), void 0 === e && (e = i.y), this.world.staticTree.remove(this), i.getTopLeft(this.position), this.updateCenter(), this.world.staticTree.insert(this); },
    stop() { return this; },
    getBounds(t) { return t.x = this.x, t.y = this.y, t.right = this.right, t.bottom = this.bottom, t; },
    hitTest(t, e) { return this.isCircle ? n(this, t, e) : o(this, t, e); },
    postUpdate() {},
    deltaAbsX() { return 0; },
    deltaAbsY() { return 0; },
    deltaX() { return 0; },
    deltaY() { return 0; },
    deltaZ() { return 0; },
    destroy() { this.enable = !1, this.world.pendingDestroy.set(this); },
    drawDebug(t) { const e = this.position; this.debugShowBody && (t.lineStyle(1, this.debugBodyColor, 1), t.strokeRect(e.x, e.y, this.width, this.height)); },
    willDrawDebug() { return this.debugShowBody; },
    setMass(t) { return t <= 0 && (t = 0.1), this.mass = t, this; },
    x: { get() { return this.position.x; }, set(t) { this.world.staticTree.remove(this), this.position.x = t, this.world.staticTree.insert(this); } },
    y: { get() { return this.position.y; }, set(t) { this.world.staticTree.remove(this), this.position.y = t, this.world.staticTree.insert(this); } },
    left: { get() { return this.position.x; } },
    right: { get() { return this.position.x + this.width; } },
    top: { get() { return this.position.y; } },
    bottom: { get() { return this.position.y + this.height; } },
  }); t.exports = h;
}, function (t, e) { t.exports = function (t, e) { return !(e.right <= t.left || e.bottom <= t.top || e.position.x >= t.right || e.position.y >= t.bottom); }; }, function (t, e, i) {
  const n = i(313); function s(t) { if (!(this instanceof s)) return new s(t, ['.left', '.top', '.right', '.bottom']); this._maxEntries = Math.max(4, t || 9), this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries)), this.clear(); } function r(t, e, i) { if (!i) return e.indexOf(t); for (let n = 0; n < e.length; n++) if (i(t, e[n])) return n; return -1; } function o(t, e) { a(t, 0, t.children.length, e, t); } function a(t, e, i, n, s) { s || (s = g(null)), s.minX = 1 / 0, s.minY = 1 / 0, s.maxX = -1 / 0, s.maxY = -1 / 0; for (var r, o = e; o < i; o++)r = t.children[o], h(s, t.leaf ? n(r) : r); return s; } function h(t, e) { return t.minX = Math.min(t.minX, e.minX), t.minY = Math.min(t.minY, e.minY), t.maxX = Math.max(t.maxX, e.maxX), t.maxY = Math.max(t.maxY, e.maxY), t; } function l(t, e) { return t.minX - e.minX; } function u(t, e) { return t.minY - e.minY; } function c(t) { return (t.maxX - t.minX) * (t.maxY - t.minY); } function d(t) { return t.maxX - t.minX + (t.maxY - t.minY); } function f(t, e) { return t.minX <= e.minX && t.minY <= e.minY && e.maxX <= t.maxX && e.maxY <= t.maxY; } function p(t, e) { return e.minX <= t.maxX && e.minY <= t.maxY && e.maxX >= t.minX && e.maxY >= t.minY; } function g(t) {
    return {
      children: t, height: 1, leaf: !0, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0,
    };
  } function v(t, e, i, s, r) { for (var o, a = [e, i]; a.length;)(i = a.pop()) - (e = a.pop()) <= s || (o = e + Math.ceil((i - e) / s / 2) * s, n(t, o, e, i, r), a.push(e, o, o, i)); }s.prototype = {
    all() { return this._all(this.data, []); },
    search(t) { let e = this.data; const i = []; const n = this.toBBox; if (!p(t, e)) return i; for (var s, r, o, a, h = []; e;) { for (s = 0, r = e.children.length; s < r; s++)o = e.children[s], p(t, a = e.leaf ? n(o) : o) && (e.leaf ? i.push(o) : f(t, a) ? this._all(o, i) : h.push(o)); e = h.pop(); } return i; },
    collides(t) { let e = this.data; const i = this.toBBox; if (!p(t, e)) return !1; for (var n, s, r, o, a = []; e;) { for (n = 0, s = e.children.length; n < s; n++) if (r = e.children[n], p(t, o = e.leaf ? i(r) : r)) { if (e.leaf || f(t, o)) return !0; a.push(r); }e = a.pop(); } return !1; },
    load(t) { if (!t || !t.length) return this; if (t.length < this._minEntries) { for (let e = 0, i = t.length; e < i; e++) this.insert(t[e]); return this; } let n = this._build(t.slice(), 0, t.length - 1, 0); if (this.data.children.length) if (this.data.height === n.height) this._splitRoot(this.data, n); else { if (this.data.height < n.height) { const s = this.data; this.data = n, n = s; } this._insert(n, this.data.height - n.height - 1, !0); } else this.data = n; return this; },
    insert(t) { return t && this._insert(t, this.data.height - 1), this; },
    clear() { return this.data = g([]), this; },
    remove(t, e) { if (!t) return this; for (var i, n, s, o, a = this.data, h = this.toBBox(t), l = [], u = []; a || l.length;) { if (a || (a = l.pop(), n = l[l.length - 1], i = u.pop(), o = !0), a.leaf && (s = r(t, a.children, e)) !== -1) return a.children.splice(s, 1), l.push(a), this._condense(l), this; o || a.leaf || !f(a, h) ? n ? (i++, a = n.children[i], o = !1) : a = null : (l.push(a), u.push(i), i = 0, n = a, a = a.children[0]); } return this; },
    toBBox(t) { return t; },
    compareMinX: l,
    compareMinY: u,
    toJSON() { return this.data; },
    fromJSON(t) { return this.data = t, this; },
    _all(t, e) { for (let i = []; t;)t.leaf ? e.push.apply(e, t.children) : i.push.apply(i, t.children), t = i.pop(); return e; },
    _build(t, e, i, n) { let s; const r = i - e + 1; let a = this._maxEntries; if (r <= a) return o(s = g(t.slice(e, i + 1)), this.toBBox), s; n || (n = Math.ceil(Math.log(r) / Math.log(a)), a = Math.ceil(r / Math.pow(a, n - 1))), (s = g([])).leaf = !1, s.height = n; let h; let l; let u; let c; const d = Math.ceil(r / a); const f = d * Math.ceil(Math.sqrt(a)); for (v(t, e, i, f, this.compareMinX), h = e; h <= i; h += f) for (v(t, h, u = Math.min(h + f - 1, i), d, this.compareMinY), l = h; l <= u; l += d)c = Math.min(l + d - 1, u), s.children.push(this._build(t, l, c, n - 1)); return o(s, this.toBBox), s; },
    _chooseSubtree(t, e, i, n) { for (var s, r, o, a, h, l, u, d, f, p; n.push(e), !e.leaf && n.length - 1 !== i;) { for (u = d = 1 / 0, s = 0, r = e.children.length; s < r; s++)h = c(o = e.children[s]), f = t, p = o, (l = (Math.max(p.maxX, f.maxX) - Math.min(p.minX, f.minX)) * (Math.max(p.maxY, f.maxY) - Math.min(p.minY, f.minY)) - h) < d ? (d = l, u = h < u ? h : u, a = o) : l === d && h < u && (u = h, a = o); e = a || e.children[0]; } return e; },
    _insert(t, e, i) { const n = this.toBBox; const s = i ? t : n(t); const r = []; const o = this._chooseSubtree(s, this.data, e, r); for (o.children.push(t), h(o, s); e >= 0 && r[e].children.length > this._maxEntries;) this._split(r, e), e--; this._adjustParentBBoxes(s, r, e); },
    _split(t, e) { const i = t[e]; const n = i.children.length; const s = this._minEntries; this._chooseSplitAxis(i, s, n); const r = this._chooseSplitIndex(i, s, n); const a = g(i.children.splice(r, i.children.length - r)); a.height = i.height, a.leaf = i.leaf, o(i, this.toBBox), o(a, this.toBBox), e ? t[e - 1].children.push(a) : this._splitRoot(i, a); },
    _splitRoot(t, e) { this.data = g([t, e]), this.data.height = t.height + 1, this.data.leaf = !1, o(this.data, this.toBBox); },
    _chooseSplitIndex(t, e, i) { let n; let s; let r; let o; let h; let l; let u; let d; let f; let p; let g; let v; let y; let m; for (l = u = 1 / 0, n = e; n <= i - e; n++)s = a(t, 0, n, this.toBBox), r = a(t, n, i, this.toBBox), f = s, p = r, void 0, void 0, void 0, void 0, g = Math.max(f.minX, p.minX), v = Math.max(f.minY, p.minY), y = Math.min(f.maxX, p.maxX), m = Math.min(f.maxY, p.maxY), o = Math.max(0, y - g) * Math.max(0, m - v), h = c(s) + c(r), o < l ? (l = o, d = n, u = h < u ? h : u) : o === l && h < u && (u = h, d = n); return d; },
    _chooseSplitAxis(t, e, i) { const n = t.leaf ? this.compareMinX : l; const s = t.leaf ? this.compareMinY : u; this._allDistMargin(t, e, i, n) < this._allDistMargin(t, e, i, s) && t.children.sort(n); },
    _allDistMargin(t, e, i, n) { t.children.sort(n); let s; let r; const o = this.toBBox; const l = a(t, 0, e, o); const u = a(t, i - e, i, o); let c = d(l) + d(u); for (s = e; s < i - e; s++)r = t.children[s], h(l, t.leaf ? o(r) : r), c += d(l); for (s = i - e - 1; s >= e; s--)r = t.children[s], h(u, t.leaf ? o(r) : r), c += d(u); return c; },
    _adjustParentBBoxes(t, e, i) { for (let n = i; n >= 0; n--)h(e[n], t); },
    _condense(t) { for (var e, i = t.length - 1; i >= 0; i--)t[i].children.length === 0 ? i > 0 ? (e = t[i - 1].children).splice(e.indexOf(t[i]), 1) : this.clear() : o(t[i], this.toBBox); },
    compareMinX(t, e) { return t.left - e.left; },
    compareMinY(t, e) { return t.top - e.top; },
    toBBox(t) {
      return {
        minX: t.left, minY: t.top, maxX: t.right, maxY: t.bottom,
      };
    },
  }, t.exports = s;
}, function (t, e, i) {
  const n = new (i(0))({
    initialize() { this._pending = [], this._active = [], this._destroy = [], this._toProcess = 0; }, add(t) { return this._pending.push(t), this._toProcess++, this; }, remove(t) { return this._destroy.push(t), this._toProcess++, this; }, update() { if (this._toProcess === 0) return this._active; let t; let e; let i = this._destroy; const n = this._active; for (t = 0; t < i.length; t++) { e = i[t]; const s = n.indexOf(e); s !== -1 && n.splice(s, 1); } for (i.length = 0, i = this._pending, t = 0; t < i.length; t++)e = i[t], this._active.push(e); return i.length = 0, this._toProcess = 0, this._active; }, getActive() { return this._active; }, destroy() { this._pending = [], this._active = [], this._destroy = []; },
  }); t.exports = n;
}, function (t, e, i) { const n = i(35); t.exports = function (t, e, i, s) { let r = 0; const o = t.deltaAbsY() + e.deltaAbsY() + s; return t._dy === 0 && e._dy === 0 ? (t.embedded = !0, e.embedded = !0) : t._dy > e._dy ? (r = t.bottom - e.y) > o && !i || !1 === t.checkCollision.down || !1 === e.checkCollision.up ? r = 0 : (t.touching.none = !1, t.touching.down = !0, e.touching.none = !1, e.touching.up = !0, e.physicsType === n.STATIC_BODY && (t.blocked.none = !1, t.blocked.down = !0), t.physicsType === n.STATIC_BODY && (e.blocked.none = !1, e.blocked.up = !0)) : t._dy < e._dy && (-(r = t.y - e.bottom) > o && !i || !1 === t.checkCollision.up || !1 === e.checkCollision.down ? r = 0 : (t.touching.none = !1, t.touching.up = !0, e.touching.none = !1, e.touching.down = !0, e.physicsType === n.STATIC_BODY && (t.blocked.none = !1, t.blocked.up = !0), t.physicsType === n.STATIC_BODY && (e.blocked.none = !1, e.blocked.down = !0))), t.overlapY = r, e.overlapY = r, r; }; }, function (t, e, i) { const n = i(35); t.exports = function (t, e, i, s) { let r = 0; const o = t.deltaAbsX() + e.deltaAbsX() + s; return t._dx === 0 && e._dx === 0 ? (t.embedded = !0, e.embedded = !0) : t._dx > e._dx ? (r = t.right - e.x) > o && !i || !1 === t.checkCollision.right || !1 === e.checkCollision.left ? r = 0 : (t.touching.none = !1, t.touching.right = !0, e.touching.none = !1, e.touching.left = !0, e.physicsType === n.STATIC_BODY && (t.blocked.none = !1, t.blocked.right = !0), t.physicsType === n.STATIC_BODY && (e.blocked.none = !1, e.blocked.left = !0)) : t._dx < e._dx && (-(r = t.x - e.width - e.x) > o && !i || !1 === t.checkCollision.left || !1 === e.checkCollision.right ? r = 0 : (t.touching.none = !1, t.touching.left = !0, e.touching.none = !1, e.touching.right = !0, e.physicsType === n.STATIC_BODY && (t.blocked.none = !1, t.blocked.left = !0), t.physicsType === n.STATIC_BODY && (e.blocked.none = !1, e.blocked.right = !0))), t.overlapX = r, e.overlapX = r, r; }; }, function (t, e, i) {
  const n = new (i(0))({
    initialize(t, e, i, n, s, r, o) { this.world = t, this.name = '', this.active = !0, this.overlapOnly = e, this.object1 = i, this.object2 = n, this.collideCallback = s, this.processCallback = r, this.callbackContext = o; }, setName(t) { return this.name = t, this; }, update() { this.world.collideObjects(this.object1, this.object2, this.collideCallback, this.processCallback, this.callbackContext, this.overlapOnly); }, destroy() { this.world.removeCollider(this), this.active = !1, this.world = null, this.object1 = null, this.object2 = null, this.collideCallback = null, this.processCallback = null, this.callbackContext = null; },
  }); t.exports = n;
}, function (t, e, i) {
  const n = i(40); const s = i(0); const r = i(35); const o = i(172); const a = i(9); const h = i(39); const l = i(3); const u = new s({
    initialize(t, e) {
      const i = e.width ? e.width : 64; const n = e.height ? e.height : 64; this.world = t, this.gameObject = e, this.transform = {
        x: e.x, y: e.y, rotation: e.angle, scaleX: e.scaleX, scaleY: e.scaleY, displayOriginX: e.displayOriginX, displayOriginY: e.displayOriginY,
      }, this.debugShowBody = t.defaults.debugShowBody, this.debugShowVelocity = t.defaults.debugShowVelocity, this.debugBodyColor = t.defaults.bodyDebugColor, this.enable = !0, this.isCircle = !1, this.radius = 0, this.offset = new l(), this.position = new l(e.x, e.y), this.prev = new l(e.x, e.y), this.allowRotation = !0, this.rotation = e.angle, this.preRotation = e.angle, this.width = i, this.height = n, this.sourceWidth = i, this.sourceHeight = n, e.frame && (this.sourceWidth = e.frame.realWidth, this.sourceHeight = e.frame.realHeight), this.halfWidth = Math.abs(i / 2), this.halfHeight = Math.abs(n / 2), this.center = new l(e.x + this.halfWidth, e.y + this.halfHeight), this.velocity = new l(), this.newVelocity = new l(), this.deltaMax = new l(), this.acceleration = new l(), this.allowDrag = !0, this.drag = new l(), this.allowGravity = !0, this.gravity = new l(), this.bounce = new l(), this.worldBounce = null, this.onWorldBounds = !1, this.onCollide = !1, this.onOverlap = !1, this.maxVelocity = new l(1e4, 1e4), this.friction = new l(1, 0), this.useDamping = !1, this.angularVelocity = 0, this.angularAcceleration = 0, this.angularDrag = 0, this.maxAngular = 1e3, this.mass = 1, this.angle = 0, this.speed = 0, this.facing = r.FACING_NONE, this.immovable = !1, this.moves = !0, this.customSeparateX = !1, this.customSeparateY = !1, this.overlapX = 0, this.overlapY = 0, this.overlapR = 0, this.embedded = !1, this.collideWorldBounds = !1, this.checkCollision = {
        none: !1, up: !0, down: !0, left: !0, right: !0,
      }, this.touching = {
        none: !0, up: !1, down: !1, left: !1, right: !1,
      }, this.wasTouching = {
        none: !0, up: !1, down: !1, left: !1, right: !1,
      }, this.blocked = {
        none: !0, up: !1, down: !1, left: !1, right: !1,
      }, this.syncBounds = !1, this.isMoving = !1, this.stopVelocityOnCollide = !0, this.physicsType = r.DYNAMIC_BODY, this._reset = !0, this._sx = e.scaleX, this._sy = e.scaleY, this._dx = 0, this._dy = 0, this._bounds = new a();
    },
    updateBounds() { const t = this.gameObject; const e = this.transform; if (t.parentContainer) { const i = t.getWorldTransformMatrix(this.world._tempMatrix, this.world._tempMatrix2); e.x = i.tx, e.y = i.ty, e.rotation = o(i.rotation), e.scaleX = i.scaleX, e.scaleY = i.scaleY, e.displayOriginX = t.displayOriginX, e.displayOriginY = t.displayOriginY; } else e.x = t.x, e.y = t.y, e.rotation = t.angle, e.scaleX = t.scaleX, e.scaleY = t.scaleY, e.displayOriginX = t.displayOriginX, e.displayOriginY = t.displayOriginY; let n = !1; if (this.syncBounds) { const s = t.getBounds(this._bounds); this.width = s.width, this.height = s.height, n = !0; } else { const r = Math.abs(e.scaleX); const a = Math.abs(e.scaleY); this._sx === r && this._sy === a || (this.width = this.sourceWidth * r, this.height = this.sourceHeight * a, this._sx = r, this._sy = a, n = !0); }n && (this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.updateCenter()); },
    updateCenter() { this.center.set(this.position.x + this.halfWidth, this.position.y + this.halfHeight); },
    update(t) { this.wasTouching.none = this.touching.none, this.wasTouching.up = this.touching.up, this.wasTouching.down = this.touching.down, this.wasTouching.left = this.touching.left, this.wasTouching.right = this.touching.right, this.touching.none = !0, this.touching.up = !1, this.touching.down = !1, this.touching.left = !1, this.touching.right = !1, this.blocked.none = !0, this.blocked.up = !1, this.blocked.down = !1, this.blocked.left = !1, this.blocked.right = !1, this.overlapR = 0, this.overlapX = 0, this.overlapY = 0, this.embedded = !1, this.updateBounds(); const e = this.transform; if (this.position.x = e.x + e.scaleX * (this.offset.x - e.displayOriginX), this.position.y = e.y + e.scaleY * (this.offset.y - e.displayOriginY), this.updateCenter(), this.rotation = e.rotation, this.preRotation = this.rotation, this._reset && (this.prev.x = this.position.x, this.prev.y = this.position.y), this.moves) { this.world.updateMotion(this, t); const i = this.velocity.x; const n = this.velocity.y; this.newVelocity.set(i * t, n * t), this.position.add(this.newVelocity), this.updateCenter(), this.angle = Math.atan2(n, i), this.speed = Math.sqrt(i * i + n * n), this.collideWorldBounds && this.checkWorldBounds() && this.onWorldBounds && this.world.emit('worldbounds', this, this.blocked.up, this.blocked.down, this.blocked.left, this.blocked.right); } this._dx = this.position.x - this.prev.x, this._dy = this.position.y - this.prev.y; },
    postUpdate() { this._dx = this.position.x - this.prev.x, this._dy = this.position.y - this.prev.y, this.moves && (this.deltaMax.x !== 0 && this._dx !== 0 && (this._dx < 0 && this._dx < -this.deltaMax.x ? this._dx = -this.deltaMax.x : this._dx > 0 && this._dx > this.deltaMax.x && (this._dx = this.deltaMax.x)), this.deltaMax.y !== 0 && this._dy !== 0 && (this._dy < 0 && this._dy < -this.deltaMax.y ? this._dy = -this.deltaMax.y : this._dy > 0 && this._dy > this.deltaMax.y && (this._dy = this.deltaMax.y)), this.gameObject.x += this._dx, this.gameObject.y += this._dy, this._reset = !0), this._dx < 0 ? this.facing = r.FACING_LEFT : this._dx > 0 && (this.facing = r.FACING_RIGHT), this._dy < 0 ? this.facing = r.FACING_UP : this._dy > 0 && (this.facing = r.FACING_DOWN), this.allowRotation && (this.gameObject.angle += this.deltaZ()), this.prev.x = this.position.x, this.prev.y = this.position.y; },
    checkWorldBounds() { const t = this.position; const e = this.world.bounds; const i = this.world.checkCollision; const n = this.worldBounce ? -this.worldBounce.x : -this.bounce.x; const s = this.worldBounce ? -this.worldBounce.y : -this.bounce.y; return t.x < e.x && i.left ? (t.x = e.x, this.velocity.x *= n, this.blocked.left = !0, this.blocked.none = !1) : this.right > e.right && i.right && (t.x = e.right - this.width, this.velocity.x *= n, this.blocked.right = !0, this.blocked.none = !1), t.y < e.y && i.up ? (t.y = e.y, this.velocity.y *= s, this.blocked.up = !0, this.blocked.none = !1) : this.bottom > e.bottom && i.down && (t.y = e.bottom - this.height, this.velocity.y *= s, this.blocked.down = !0, this.blocked.none = !1), !this.blocked.none; },
    setOffset(t, e) { return void 0 === e && (e = t), this.offset.set(t, e), this; },
    setSize(t, e, i) { void 0 === i && (i = !0); const n = this.gameObject; if (!t && n.frame && (t = n.frame.realWidth), !e && n.frame && (e = n.frame.realHeight), this.sourceWidth = t, this.sourceHeight = e, this.width = this.sourceWidth * this._sx, this.height = this.sourceHeight * this._sy, this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.updateCenter(), i && n.getCenter) { const s = n.displayWidth / 2; const r = n.displayHeight / 2; this.offset.set(s - this.halfWidth, r - this.halfHeight); } return this.isCircle = !1, this.radius = 0, this; },
    setCircle(t, e, i) { return void 0 === e && (e = this.offset.x), void 0 === i && (i = this.offset.y), t > 0 ? (this.isCircle = !0, this.radius = t, this.sourceWidth = 2 * t, this.sourceHeight = 2 * t, this.width = this.sourceWidth * this._sx, this.height = this.sourceHeight * this._sy, this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.offset.set(e, i), this.updateCenter()) : this.isCircle = !1, this; },
    reset(t, e) { this.stop(); const i = this.gameObject; i.setPosition(t, e), i.getTopLeft(this.position), this.prev.copy(this.position), this.rotation = i.angle, this.preRotation = i.angle, this.updateBounds(), this.updateCenter(); },
    stop() { return this.velocity.set(0), this.acceleration.set(0), this.speed = 0, this.angularVelocity = 0, this.angularAcceleration = 0, this; },
    getBounds(t) { return t.x = this.x, t.y = this.y, t.right = this.right, t.bottom = this.bottom, t; },
    hitTest(t, e) { return this.isCircle ? n(this, t, e) : h(this, t, e); },
    onFloor() { return this.blocked.down; },
    onCeiling() { return this.blocked.up; },
    onWall() { return this.blocked.left || this.blocked.right; },
    deltaAbsX() { return this._dx > 0 ? this._dx : -this._dx; },
    deltaAbsY() { return this._dy > 0 ? this._dy : -this._dy; },
    deltaX() { return this._dx; },
    deltaY() { return this._dy; },
    deltaZ() { return this.rotation - this.preRotation; },
    destroy() { this.enable = !1, this.world.pendingDestroy.set(this); },
    drawDebug(t) { const e = this.position; const i = e.x + this.halfWidth; const n = e.y + this.halfHeight; this.debugShowBody && (t.lineStyle(1, this.debugBodyColor), this.isCircle ? t.strokeCircle(i, n, this.width / 2) : t.strokeRect(e.x, e.y, this.width, this.height)), this.debugShowVelocity && (t.lineStyle(1, this.world.defaults.velocityDebugColor, 1), t.lineBetween(i, n, i + this.velocity.x / 2, n + this.velocity.y / 2)); },
    willDrawDebug() { return this.debugShowBody || this.debugShowVelocity; },
    setCollideWorldBounds(t) { return void 0 === t && (t = !0), this.collideWorldBounds = t, this; },
    setVelocity(t, e) { return this.velocity.set(t, e), this.speed = Math.sqrt(t * t + e * e), this; },
    setVelocityX(t) { this.velocity.x = t; const e = t; const i = this.velocity.y; return this.speed = Math.sqrt(e * e + i * i), this; },
    setVelocityY(t) { this.velocity.y = t; const e = this.velocity.x; const i = t; return this.speed = Math.sqrt(e * e + i * i), this; },
    setMaxVelocity(t, e) { return this.maxVelocity.set(t, e), this; },
    setBounce(t, e) { return this.bounce.set(t, e), this; },
    setBounceX(t) { return this.bounce.x = t, this; },
    setBounceY(t) { return this.bounce.y = t, this; },
    setAcceleration(t, e) { return this.acceleration.set(t, e), this; },
    setAccelerationX(t) { return this.acceleration.x = t, this; },
    setAccelerationY(t) { return this.acceleration.y = t, this; },
    setAllowDrag(t) { return void 0 === t && (t = !0), this.allowDrag = t, this; },
    setAllowGravity(t) { return void 0 === t && (t = !0), this.allowGravity = t, this; },
    setAllowRotation(t) { return void 0 === t && (t = !0), this.allowRotation = t, this; },
    setDrag(t, e) { return this.drag.set(t, e), this; },
    setDragX(t) { return this.drag.x = t, this; },
    setDragY(t) { return this.drag.y = t, this; },
    setGravity(t, e) { return this.gravity.set(t, e), this; },
    setGravityX(t) { return this.gravity.x = t, this; },
    setGravityY(t) { return this.gravity.y = t, this; },
    setFriction(t, e) { return this.friction.set(t, e), this; },
    setFrictionX(t) { return this.friction.x = t, this; },
    setFrictionY(t) { return this.friction.y = t, this; },
    setAngularVelocity(t) { return this.angularVelocity = t, this; },
    setAngularAcceleration(t) { return this.angularAcceleration = t, this; },
    setAngularDrag(t) { return this.angularDrag = t, this; },
    setMass(t) { return this.mass = t, this; },
    setImmovable(t) { return void 0 === t && (t = !0), this.immovable = t, this; },
    setEnable(t) { return void 0 === t && (t = !0), this.enable = t, this; },
    x: { get() { return this.position.x; }, set(t) { this.position.x = t; } },
    y: { get() { return this.position.y; }, set(t) { this.position.y = t; } },
    left: { get() { return this.position.x; } },
    right: { get() { return this.position.x + this.width; } },
    top: { get() { return this.position.y; } },
    bottom: { get() { return this.position.y + this.height; } },
  }); t.exports = u;
}, function (t, e, i) {
  const n = i(232); const s = i(23); const r = i(0); const o = i(231); const a = i(35); const h = i(52); const l = i(11); const u = i(248); const c = i(247); const d = i(246); const f = i(230); const p = i(229); const g = i(4); const v = i(228); const y = i(514); const m = i(9); const x = i(227); const w = i(513); const b = i(508); const T = i(507); const S = i(95); const _ = i(225); const A = i(226); const C = i(38); const M = i(3); const P = i(53); const E = new r({
    Extends: l,
    initialize(t, e) {
      l.call(this), this.scene = t, this.bodies = new S(), this.staticBodies = new S(), this.pendingDestroy = new S(), this.colliders = new v(), this.gravity = new M(g(e, 'gravity.x', 0), g(e, 'gravity.y', 0)), this.bounds = new m(g(e, 'x', 0), g(e, 'y', 0), g(e, 'width', t.sys.game.config.width), g(e, 'height', t.sys.game.config.height)), this.checkCollision = {
        up: g(e, 'checkCollision.up', !0), down: g(e, 'checkCollision.down', !0), left: g(e, 'checkCollision.left', !0), right: g(e, 'checkCollision.right', !0),
      }, this.fps = g(e, 'fps', 60), this._elapsed = 0, this._frameTime = 1 / this.fps, this._frameTimeMS = 1e3 * this._frameTime, this.stepsLastFrame = 0, this.timeScale = g(e, 'timeScale', 1), this.OVERLAP_BIAS = g(e, 'overlapBias', 4), this.TILE_BIAS = g(e, 'tileBias', 16), this.forceX = g(e, 'forceX', !1), this.isPaused = g(e, 'isPaused', !1), this._total = 0, this.drawDebug = g(e, 'debug', !1), this.debugGraphic, this.defaults = {
        debugShowBody: g(e, 'debugShowBody', !0), debugShowStaticBody: g(e, 'debugShowStaticBody', !0), debugShowVelocity: g(e, 'debugShowVelocity', !0), bodyDebugColor: g(e, 'debugBodyColor', 16711935), staticBodyDebugColor: g(e, 'debugStaticBodyColor', 255), velocityDebugColor: g(e, 'debugVelocityColor', 65280),
      }, this.maxEntries = g(e, 'maxEntries', 16), this.useTree = g(e, 'useTree', !0), this.tree = new x(this.maxEntries), this.staticTree = new x(this.maxEntries), this.treeMinMax = {
        minX: 0, minY: 0, maxX: 0, maxY: 0,
      }, this._tempMatrix = new C(), this._tempMatrix2 = new C(), this.drawDebug && this.createDebugGraphic();
    },
    enable(t, e) { void 0 === e && (e = a.DYNAMIC_BODY), Array.isArray(t) || (t = [t]); for (let i = 0; i < t.length; i++) { const n = t[i]; if (n.isParent) for (let s = n.getChildren(), r = 0; r < s.length; r++) { const o = s[r]; o.isParent ? this.enable(o, e) : this.enableBody(o, e); } else this.enableBody(n, e); } },
    enableBody(t, e) { return void 0 === e && (e = a.DYNAMIC_BODY), t.body || (e === a.DYNAMIC_BODY ? t.body = new n(this, t) : e === a.STATIC_BODY && (t.body = new _(this, t))), this.add(t.body), t; },
    add(t) { return t.physicsType === a.DYNAMIC_BODY ? this.bodies.set(t) : t.physicsType === a.STATIC_BODY && (this.staticBodies.set(t), this.staticTree.insert(t)), t.enable = !0, t; },
    disable(t) { Array.isArray(t) || (t = [t]); for (let e = 0; e < t.length; e++) { const i = t[e]; if (i.isParent) for (let n = i.getChildren(), s = 0; s < n.length; s++) { const r = n[s]; r.isParent ? this.disable(r) : this.disableBody(r.body); } else this.disableBody(i.body); } },
    disableBody(t) { this.remove(t), t.enable = !1; },
    remove(t) { t.physicsType === a.DYNAMIC_BODY ? (this.tree.remove(t), this.bodies.delete(t)) : t.physicsType === a.STATIC_BODY && (this.staticBodies.delete(t), this.staticTree.remove(t)); },
    createDebugGraphic() { const t = this.scene.sys.add.graphics({ x: 0, y: 0 }); return t.setDepth(Number.MAX_VALUE), this.debugGraphic = t, this.drawDebug = !0, t; },
    setBounds(t, e, i, n, s, r, o, a) { return this.bounds.setTo(t, e, i, n), void 0 !== s && this.setBoundsCollision(s, r, o, a), this; },
    setBoundsCollision(t, e, i, n) { return void 0 === t && (t = !0), void 0 === e && (e = !0), void 0 === i && (i = !0), void 0 === n && (n = !0), this.checkCollision.left = t, this.checkCollision.right = e, this.checkCollision.up = i, this.checkCollision.down = n, this; },
    pause() { return this.isPaused = !0, this.emit('pause'), this; },
    resume() { return this.isPaused = !1, this.emit('resume'), this; },
    addCollider(t, e, i, n, s) { void 0 === i && (i = null), void 0 === n && (n = null), void 0 === s && (s = i); const r = new o(this, !1, t, e, i, n, s); return this.colliders.add(r), r; },
    addOverlap(t, e, i, n, s) { void 0 === i && (i = null), void 0 === n && (n = null), void 0 === s && (s = i); const r = new o(this, !0, t, e, i, n, s); return this.colliders.add(r), r; },
    removeCollider(t) { return this.colliders.remove(t), this; },
    setFPS(t) { return this.fps = t, this._frameTime = 1 / this.fps, this._frameTimeMS = 1e3 * this._frameTime, this; },
    update(t, e) { if (!this.isPaused && this.bodies.size !== 0) { let i = 0; const n = this._frameTime; const s = this._frameTimeMS * this.timeScale; for (this._elapsed += e; this._elapsed >= s;) this._elapsed -= s, i++, this.step(n); this.stepsLastFrame = i; } },
    step(t) { let e; let i; const n = this.bodies.entries; let s = n.length; for (e = 0; e < s; e++)(i = n[e]).enable && i.update(t); this.useTree && (this.tree.clear(), this.tree.load(n)); const r = this.colliders.update(); for (e = 0; e < r.length; e++) { const o = r[e]; o.active && o.update(); } for (s = n.length, e = 0; e < s; e++)(i = n[e]).enable && i.postUpdate(); },
    postUpdate() { let t; let e; const i = this.bodies; const n = this.staticBodies; const s = this.pendingDestroy; let r = i.entries; let o = r.length; if (this.drawDebug) { const h = this.debugGraphic; for (h.clear(), t = 0; t < o; t++)(e = r[t]).willDrawDebug() && e.drawDebug(h); for (o = (r = n.entries).length, t = 0; t < o; t++)(e = r[t]).willDrawDebug() && e.drawDebug(h); } if (s.size > 0) { const l = this.tree; const u = this.staticTree; for (o = (r = s.entries).length, t = 0; t < o; t++)(e = r[t]).physicsType === a.DYNAMIC_BODY ? (l.remove(e), i.delete(e)) : e.physicsType === a.STATIC_BODY && (u.remove(e), n.delete(e)), e.world = void 0, e.gameObject = void 0; s.clear(); } },
    updateMotion(t, e) { t.allowRotation && this.computeAngularVelocity(t, e), this.computeVelocity(t, e); },
    computeAngularVelocity(t, e) { let i = t.angularVelocity; const n = t.angularAcceleration; let r = t.angularDrag; const o = t.maxAngular; n ? i += n * e : t.allowDrag && r && (c(i - (r *= e), 0, 0.1) ? i -= r : d(i + r, 0, 0.1) ? i += r : i = 0); const a = (i = s(i, -o, o)) - t.angularVelocity; t.angularVelocity += a, t.rotation += t.angularVelocity * e; },
    computeVelocity(t, e) { let i = t.velocity.x; const n = t.acceleration.x; let r = t.drag.x; const o = t.maxVelocity.x; let a = t.velocity.y; const h = t.acceleration.y; let l = t.drag.y; const f = t.maxVelocity.y; const p = t.speed; const g = t.allowDrag; const v = t.useDamping; t.allowGravity && (i += (this.gravity.x + t.gravity.x) * e, a += (this.gravity.y + t.gravity.y) * e), n ? i += n * e : g && r && (v ? (i *= r, u(p, 0, 0.001) && (i = 0)) : c(i - (r *= e), 0, 0.01) ? i -= r : d(i + r, 0, 0.01) ? i += r : i = 0), h ? a += h * e : g && l && (v ? (a *= l, u(p, 0, 0.001) && (a = 0)) : c(a - (l *= e), 0, 0.01) ? a -= l : d(a + l, 0, 0.01) ? a += l : a = 0), i = s(i, -o, o), a = s(a, -f, f), t.velocity.set(i, a); },
    separate(t, e, i, n, s) {
      if (!t.enable || !e.enable || t.checkCollision.none || e.checkCollision.none || !this.intersects(t, e)) return !1; if (i && !1 === i.call(n, t.gameObject, e.gameObject)) return !1; if (t.isCircle && e.isCircle) return this.separateCircle(t, e, s); if (t.isCircle !== e.isCircle) {
        const r = t.isCircle ? e : t; const o = t.isCircle ? t : e; const a = {
          x: r.x, y: r.y, right: r.right, bottom: r.bottom,
        }; const h = o.center; if ((h.y < a.y || h.y > a.bottom) && (h.x < a.x || h.x > a.right)) return this.separateCircle(t, e, s);
      } let l = !1; let u = !1; this.forceX || Math.abs(this.gravity.y + t.gravity.y) < Math.abs(this.gravity.x + t.gravity.x) ? (l = b(t, e, s, this.OVERLAP_BIAS), this.intersects(t, e) && (u = T(t, e, s, this.OVERLAP_BIAS))) : (u = T(t, e, s, this.OVERLAP_BIAS), this.intersects(t, e) && (l = b(t, e, s, this.OVERLAP_BIAS))); const c = l || u; return c && (s && (t.onOverlap || e.onOverlap) ? this.emit('overlap', t.gameObject, e.gameObject, t, e) : (t.postUpdate(), e.postUpdate(), (t.onCollide || e.onCollide) && this.emit('collide', t.gameObject, e.gameObject, t, e))), c;
    },
    separateCircle(t, e, i, n) {
      f(t, e, !1, n), p(t, e, !1, n); const s = e.center.x - t.center.x; const r = e.center.y - t.center.y; const o = Math.atan2(r, s); let a = 0; if (t.isCircle !== e.isCircle) {
        const l = {
          x: e.isCircle ? t.position.x : e.position.x, y: e.isCircle ? t.position.y : e.position.y, right: e.isCircle ? t.right : e.right, bottom: e.isCircle ? t.bottom : e.bottom,
        }; const u = { x: t.isCircle ? t.center.x : e.center.x, y: t.isCircle ? t.center.y : e.center.y, radius: t.isCircle ? t.halfWidth : e.halfWidth }; u.y < l.y ? u.x < l.x ? a = h(u.x, u.y, l.x, l.y) - u.radius : u.x > l.right && (a = h(u.x, u.y, l.right, l.y) - u.radius) : u.y > l.bottom && (u.x < l.x ? a = h(u.x, u.y, l.x, l.bottom) - u.radius : u.x > l.right && (a = h(u.x, u.y, l.right, l.bottom) - u.radius)), a *= -1;
      } else a = t.halfWidth + e.halfWidth - h(t.center.x, t.center.y, e.center.x, e.center.y); if (i || a === 0 || t.immovable && e.immovable || t.customSeparateX || e.customSeparateX) return a !== 0 && (t.onOverlap || e.onOverlap) && this.emit('overlap', t.gameObject, e.gameObject, t, e), a !== 0; let c = t.velocity.x; let d = t.velocity.y; const g = t.mass; let v = e.velocity.x; let { y } = e.velocity; const m = e.mass; const x = c * Math.cos(o) + d * Math.sin(o); const w = c * Math.sin(o) - d * Math.cos(o); const b = v * Math.cos(o) + y * Math.sin(o); const T = v * Math.sin(o) - y * Math.cos(o); const S = ((g - m) * x + 2 * m * b) / (g + m); const _ = (2 * g * x + (m - g) * b) / (g + m); t.immovable || (t.velocity.x = (S * Math.cos(o) - w * Math.sin(o)) * t.bounce.x, t.velocity.y = (w * Math.cos(o) + S * Math.sin(o)) * t.bounce.y, c = t.velocity.x, d = t.velocity.y), e.immovable || (e.velocity.x = (_ * Math.cos(o) - T * Math.sin(o)) * e.bounce.x, e.velocity.y = (T * Math.cos(o) + _ * Math.sin(o)) * e.bounce.y, v = e.velocity.x, y = e.velocity.y), Math.abs(o) < Math.PI / 2 ? c > 0 && !t.immovable && v > c ? t.velocity.x *= -1 : v < 0 && !e.immovable && c < v ? e.velocity.x *= -1 : d > 0 && !t.immovable && y > d ? t.velocity.y *= -1 : y < 0 && !e.immovable && d < y && (e.velocity.y *= -1) : Math.abs(o) > Math.PI / 2 && (c < 0 && !t.immovable && v < c ? t.velocity.x *= -1 : v > 0 && !e.immovable && c > v ? e.velocity.x *= -1 : d < 0 && !t.immovable && y < d ? t.velocity.y *= -1 : y > 0 && !e.immovable && c > y && (e.velocity.y *= -1)); const A = this._frameTime; return t.immovable || (t.x += t.velocity.x * A - a * Math.cos(o), t.y += t.velocity.y * A - a * Math.sin(o)), e.immovable || (e.x += e.velocity.x * A + a * Math.cos(o), e.y += e.velocity.y * A + a * Math.sin(o)), (t.onCollide || e.onCollide) && this.emit('collide', t.gameObject, e.gameObject, t, e), t.postUpdate(), e.postUpdate(), !0;
    },
    intersects(t, e) { return t !== e && (t.isCircle || e.isCircle ? t.isCircle ? e.isCircle ? h(t.center.x, t.center.y, e.center.x, e.center.y) <= t.halfWidth + e.halfWidth : this.circleBodyIntersects(t, e) : this.circleBodyIntersects(e, t) : !(t.right <= e.position.x || t.bottom <= e.position.y || t.position.x >= e.right || t.position.y >= e.bottom)); },
    circleBodyIntersects(t, e) { const i = s(t.center.x, e.left, e.right); const n = s(t.center.y, e.top, e.bottom); return (t.center.x - i) * (t.center.x - i) + (t.center.y - n) * (t.center.y - n) <= t.halfWidth * t.halfWidth; },
    overlap(t, e, i, n, s) { return void 0 === i && (i = null), void 0 === n && (n = null), void 0 === s && (s = i), this.collideObjects(t, e, i, n, s, !0); },
    collide(t, e, i, n, s) { return void 0 === i && (i = null), void 0 === n && (n = null), void 0 === s && (s = i), this.collideObjects(t, e, i, n, s, !1); },
    collideObjects(t, e, i, n, s, r) { let o; t.isParent && void 0 === t.physicsType && (t = t.children.entries), e && e.isParent && void 0 === e.physicsType && (e = e.children.entries); const a = Array.isArray(t); const h = Array.isArray(e); if (this._total = 0, a || h) if (!a && h) for (o = 0; o < e.length; o++) this.collideHandler(t, e[o], i, n, s, r); else if (a && !h) for (o = 0; o < t.length; o++) this.collideHandler(t[o], e, i, n, s, r); else for (o = 0; o < t.length; o++) for (let l = 0; l < e.length; l++) this.collideHandler(t[o], e[l], i, n, s, r); else this.collideHandler(t, e, i, n, s, r); return this._total > 0; },
    collideHandler(t, e, i, n, s, r) { if (void 0 === e && t.isParent) return this.collideGroupVsGroup(t, t, i, n, s, r); if (!t || !e) return !1; if (t.body) { if (e.body) return this.collideSpriteVsSprite(t, e, i, n, s, r); if (e.isParent) return this.collideSpriteVsGroup(t, e, i, n, s, r); if (e.isTilemap) return this.collideSpriteVsTilemapLayer(t, e, i, n, s, r); } else if (t.isParent) { if (e.body) return this.collideSpriteVsGroup(e, t, i, n, s, r); if (e.isParent) return this.collideGroupVsGroup(t, e, i, n, s, r); if (e.isTilemap) return this.collideGroupVsTilemapLayer(t, e, i, n, s, r); } else if (t.isTilemap) { if (e.body) return this.collideSpriteVsTilemapLayer(e, t, i, n, s, r); if (e.isParent) return this.collideGroupVsTilemapLayer(e, t, i, n, s, r); } },
    collideSpriteVsSprite(t, e, i, n, s, r) { return !(!t.body || !e.body) && (this.separate(t.body, e.body, n, s, r) && (i && i.call(s, t, e), this._total++), !0); },
    collideSpriteVsGroup(t, e, i, n, s, r) { let o; let h; let l; const u = t.body; if (e.length !== 0 && u && u.enable) if (this.useTree) { const c = this.treeMinMax; c.minX = u.left, c.minY = u.top, c.maxX = u.right, c.maxY = u.bottom; const d = e.physicsType === a.DYNAMIC_BODY ? this.tree.search(c) : this.staticTree.search(c); for (h = d.length, o = 0; o < h; o++)u !== (l = d[o]) && e.contains(l.gameObject) && this.separate(u, l, n, s, r) && (i && i.call(s, u.gameObject, l.gameObject), this._total++); } else { const f = e.getChildren(); const p = e.children.entries.indexOf(t); for (h = f.length, o = 0; o < h; o++)(l = f[o].body) && o !== p && l.enable && this.separate(u, l, n, s, r) && (i && i.call(s, u.gameObject, l.gameObject), this._total++); } },
    collideGroupVsTilemapLayer(t, e, i, n, s, r) { const o = t.getChildren(); if (o.length === 0) return !1; for (var a = !1, h = 0; h < o.length; h++)o[h].body && this.collideSpriteVsTilemapLayer(o[h], e, i, n, s, r) && (a = !0); return a; },
    collideSpriteVsTilemapLayer(t, e, i, n, s, r) {
      const o = t.body; if (!o.enable) return !1; let a = o.position.x; const h = o.position.y; let l = o.width; let u = o.height; const c = e.layer; if (c.tileWidth > c.baseTileWidth) { const d = (c.tileWidth - c.baseTileWidth) * e.scaleX; a -= d, l += d; }c.tileHeight > c.baseTileHeight && (u += (c.tileHeight - c.baseTileHeight) * e.scaleY); let f; const p = e.getTilesWithinWorldXY(a, h, l, u); if (p.length === 0) return !1; for (let g = {
          left: 0, right: 0, top: 0, bottom: 0,
        }, v = 0; v < p.length; v++)f = p[v], g.left = e.tileToWorldX(f.x), g.top = e.tileToWorldY(f.y), f.baseHeight !== f.height && (g.top -= (f.height - f.baseHeight) * e.scaleY), g.right = g.left + f.width * e.scaleX, g.bottom = g.top + f.height * e.scaleY, A(g, o) && (!n || n.call(s, t, f)) && y(f, t) && (r || w(v, o, f, g, e, this.TILE_BIAS)) && (this._total++, i && i.call(s, t, f), r && o.onOverlap ? t.emit('overlap', o.gameObject, f, o, null) : o.onCollide && t.emit('collide', o.gameObject, f, o, null), o.postUpdate());
    },
    collideGroupVsGroup(t, e, i, n, s, r) { if (t.length !== 0 && e.length !== 0) for (let o = t.getChildren(), a = 0; a < o.length; a++) this.collideSpriteVsGroup(o[a], e, i, n, s, r); },
    wrap(t, e) { t.body ? this.wrapObject(t, e) : t.getChildren ? this.wrapArray(t.getChildren(), e) : Array.isArray(t) ? this.wrapArray(t, e) : this.wrapObject(t, e); },
    wrapArray(t, e) { for (let i = 0; i < t.length; i++) this.wrapObject(t[i], e); },
    wrapObject(t, e) { void 0 === e && (e = 0), t.x = P(t.x, this.bounds.left - e, this.bounds.right + e), t.y = P(t.y, this.bounds.top - e, this.bounds.bottom + e); },
    shutdown() { this.tree.clear(), this.staticTree.clear(), this.bodies.clear(), this.staticBodies.clear(), this.colliders.destroy(), this.removeAllListeners(); },
    destroy() { this.shutdown(), this.scene = null; },
  }); t.exports = E;
}, function (t, e, i) {
  const n = i(104); const s = i(0); const r = i(35); const o = i(88); const a = i(8); const h = new s({
    Extends: o,
    initialize(t, e, i, s) {
      i || s ? a(i) ? (s = i, i = null, s.createCallback = this.createCallbackHandler, s.removeCallback = this.removeCallbackHandler, s.createMultipleCallback = this.createMultipleCallbackHandler, s.classType = n) : Array.isArray(i) && a(i[0]) && (s = i, i = null, s.forEach(function (t) { t.createCallback = this.createCallbackHandler, t.removeCallback = this.removeCallbackHandler, t.createMultipleCallback = this.createMultipleCallbackHandler, t.classType = n; })) : s = {
        createCallback: this.createCallbackHandler, removeCallback: this.removeCallbackHandler, createMultipleCallback: this.createMultipleCallbackHandler, classType: n,
      }, this.world = t, this.physicsType = r.STATIC_BODY, o.call(this, e, i, s);
    },
    createCallbackHandler(t) { t.body || this.world.enableBody(t, r.STATIC_BODY); },
    removeCallbackHandler(t) { t.body && this.world.disableBody(t); },
    createMultipleCallbackHandler() { this.refresh(); },
    refresh() { for (let t = this.children.entries, e = 0; e < t.length; e++)t[e].body.reset(); return this; },
  }); t.exports = h;
}, function (t, e, i) {
  const n = i(104); const s = i(0); const r = i(35); const o = i(2); const a = i(88); const h = i(8); const l = new s({
    Extends: a,
    initialize(t, e, i, s) {
      i || s ? h(i) ? (s = i, i = null, s.createCallback = this.createCallbackHandler, s.removeCallback = this.removeCallbackHandler) : Array.isArray(i) && h(i[0]) && (s = i, i = null, s.forEach(function (t) { t.createCallback = this.createCallbackHandler, t.removeCallback = this.removeCallbackHandler; })) : s = { createCallback: this.createCallbackHandler, removeCallback: this.removeCallbackHandler }, this.world = t, s.classType = o(s, 'classType', n), this.physicsType = r.DYNAMIC_BODY, this.defaults = {
        setCollideWorldBounds: o(s, 'collideWorldBounds', !1), setAccelerationX: o(s, 'accelerationX', 0), setAccelerationY: o(s, 'accelerationY', 0), setAllowDrag: o(s, 'allowDrag', !0), setAllowGravity: o(s, 'allowGravity', !0), setAllowRotation: o(s, 'allowRotation', !0), setBounceX: o(s, 'bounceX', 0), setBounceY: o(s, 'bounceY', 0), setDragX: o(s, 'dragX', 0), setDragY: o(s, 'dragY', 0), setEnable: o(s, 'enable', !0), setGravityX: o(s, 'gravityX', 0), setGravityY: o(s, 'gravityY', 0), setFrictionX: o(s, 'frictionX', 0), setFrictionY: o(s, 'frictionY', 0), setVelocityX: o(s, 'velocityX', 0), setVelocityY: o(s, 'velocityY', 0), setAngularVelocity: o(s, 'angularVelocity', 0), setAngularAcceleration: o(s, 'angularAcceleration', 0), setAngularDrag: o(s, 'angularDrag', 0), setMass: o(s, 'mass', 1), setImmovable: o(s, 'immovable', !1),
      }, a.call(this, e, i, s);
    },
    createCallbackHandler(t) { t.body || this.world.enableBody(t, r.DYNAMIC_BODY); const e = t.body; for (const i in this.defaults)e[i](this.defaults[i]); },
    removeCallbackHandler(t) { t.body && this.world.disableBody(t); },
    setVelocity(t, e, i) { void 0 === i && (i = 0); for (let n = this.getChildren(), s = 0; s < n.length; s++)n[s].body.velocity.set(t + s * i, e + s * i); return this; },
    setVelocityX(t, e) { void 0 === e && (e = 0); for (let i = this.getChildren(), n = 0; n < i.length; n++)i[n].body.velocity.x = t + n * e; return this; },
    setVelocityY(t, e) { void 0 === e && (e = 0); for (let i = this.getChildren(), n = 0; n < i.length; n++)i[n].body.velocity.y = t + n * e; return this; },
  }); t.exports = l;
}, function (t, e, i) {
  t.exports = {
    Acceleration: i(526), Angular: i(525), Bounce: i(524), Debug: i(523), Drag: i(522), Enable: i(521), Friction: i(520), Gravity: i(519), Immovable: i(518), Mass: i(517), Size: i(516), Velocity: i(515),
  };
}, function (t, e, i) { const n = i(0); const s = i(236); const r = i(87); const o = new n({ Extends: r, Mixins: [s.Acceleration, s.Angular, s.Bounce, s.Debug, s.Drag, s.Enable, s.Friction, s.Gravity, s.Immovable, s.Mass, s.Size, s.Velocity], initialize(t, e, i, n, s) { r.call(this, t, e, i, n, s), this.body = null; } }); t.exports = o; }, function (t, e, i) {
  const n = i(237); const s = i(104); const r = i(0); const o = i(35); const a = i(235); const h = i(234); const l = new r({
    initialize(t) { this.world = t, this.scene = t.scene, this.sys = t.scene.sys; }, collider(t, e, i, n, s) { return this.world.addCollider(t, e, i, n, s); }, overlap(t, e, i, n, s) { return this.world.addOverlap(t, e, i, n, s); }, existing(t, e) { const i = e ? o.STATIC_BODY : o.DYNAMIC_BODY; return this.world.enableBody(t, i), t; }, staticImage(t, e, i, s) { const r = new n(this.scene, t, e, i, s); return this.sys.displayList.add(r), this.world.enableBody(r, o.STATIC_BODY), r; }, image(t, e, i, s) { const r = new n(this.scene, t, e, i, s); return this.sys.displayList.add(r), this.world.enableBody(r, o.DYNAMIC_BODY), r; }, staticSprite(t, e, i, n) { const r = new s(this.scene, t, e, i, n); return this.sys.displayList.add(r), this.sys.updateList.add(r), this.world.enableBody(r, o.STATIC_BODY), r; }, sprite(t, e, i, n) { const r = new s(this.scene, t, e, i, n); return this.sys.displayList.add(r), this.sys.updateList.add(r), this.world.enableBody(r, o.DYNAMIC_BODY), r; }, staticGroup(t, e) { return this.sys.updateList.add(new h(this.world, this.world.scene, t, e)); }, group(t, e) { return this.sys.updateList.add(new a(this.world, this.world.scene, t, e)); }, destroy() { this.world = null, this.scene = null, this.sys = null; },
  }); t.exports = l;
}, function (t, e, i) {
  const n = i(0); const s = i(138); const r = i(241); const o = new Int8Array([1, 2, 0]); const a = new Float32Array([0, 0, 0]); const h = new s(1, 0, 0); const l = new s(0, 1, 0); const u = new s(); const c = new r(); const d = new n({
    initialize(t, e, i, n) { typeof t === 'object' ? (this.x = t.x || 0, this.y = t.y || 0, this.z = t.z || 0, this.w = t.w || 0) : (this.x = t || 0, this.y = e || 0, this.z = i || 0, this.w = n || 0); }, copy(t) { return this.x = t.x, this.y = t.y, this.z = t.z, this.w = t.w, this; }, set(t, e, i, n) { return typeof t === 'object' ? (this.x = t.x || 0, this.y = t.y || 0, this.z = t.z || 0, this.w = t.w || 0) : (this.x = t || 0, this.y = e || 0, this.z = i || 0, this.w = n || 0), this; }, add(t) { return this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this; }, subtract(t) { return this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this; }, scale(t) { return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this; }, length() { const t = this.x; const e = this.y; const i = this.z; const n = this.w; return Math.sqrt(t * t + e * e + i * i + n * n); }, lengthSq() { const t = this.x; const e = this.y; const i = this.z; const n = this.w; return t * t + e * e + i * i + n * n; }, normalize() { const t = this.x; const e = this.y; const i = this.z; const n = this.w; let s = t * t + e * e + i * i + n * n; return s > 0 && (s = 1 / Math.sqrt(s), this.x = t * s, this.y = e * s, this.z = i * s, this.w = n * s), this; }, dot(t) { return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w; }, lerp(t, e) { void 0 === e && (e = 0); const i = this.x; const n = this.y; const s = this.z; const r = this.w; return this.x = i + e * (t.x - i), this.y = n + e * (t.y - n), this.z = s + e * (t.z - s), this.w = r + e * (t.w - r), this; }, rotationTo(t, e) { const i = t.x * e.x + t.y * e.y + t.z * e.z; return i < -0.999999 ? (u.copy(h).cross(t).length() < 1e-6 && u.copy(l).cross(t), u.normalize(), this.setAxisAngle(u, Math.PI)) : i > 0.999999 ? (this.x = 0, this.y = 0, this.z = 0, this.w = 1, this) : (u.copy(t).cross(e), this.x = u.x, this.y = u.y, this.z = u.z, this.w = 1 + i, this.normalize()); }, setAxes(t, e, i) { const n = c.val; return n[0] = e.x, n[3] = e.y, n[6] = e.z, n[1] = i.x, n[4] = i.y, n[7] = i.z, n[2] = -t.x, n[5] = -t.y, n[8] = -t.z, this.fromMat3(c).normalize(); }, identity() { return this.x = 0, this.y = 0, this.z = 0, this.w = 1, this; }, setAxisAngle(t, e) { e *= 0.5; const i = Math.sin(e); return this.x = i * t.x, this.y = i * t.y, this.z = i * t.z, this.w = Math.cos(e), this; }, multiply(t) { const e = this.x; const i = this.y; const n = this.z; const s = this.w; const r = t.x; const o = t.y; const a = t.z; const h = t.w; return this.x = e * h + s * r + i * a - n * o, this.y = i * h + s * o + n * r - e * a, this.z = n * h + s * a + e * o - i * r, this.w = s * h - e * r - i * o - n * a, this; }, slerp(t, e) { const i = this.x; const n = this.y; const s = this.z; const r = this.w; let o = t.x; let a = t.y; let h = t.z; let l = t.w; let u = i * o + n * a + s * h + r * l; u < 0 && (u = -u, o = -o, a = -a, h = -h, l = -l); let c = 1 - e; let d = e; if (1 - u > 1e-6) { const f = Math.acos(u); const p = Math.sin(f); c = Math.sin((1 - e) * f) / p, d = Math.sin(e * f) / p; } return this.x = c * i + d * o, this.y = c * n + d * a, this.z = c * s + d * h, this.w = c * r + d * l, this; }, invert() { const t = this.x; const e = this.y; const i = this.z; const n = this.w; const s = t * t + e * e + i * i + n * n; const r = s ? 1 / s : 0; return this.x = -t * r, this.y = -e * r, this.z = -i * r, this.w = n * r, this; }, conjugate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this; }, rotateX(t) { t *= 0.5; const e = this.x; const i = this.y; const n = this.z; const s = this.w; const r = Math.sin(t); const o = Math.cos(t); return this.x = e * o + s * r, this.y = i * o + n * r, this.z = n * o - i * r, this.w = s * o - e * r, this; }, rotateY(t) { t *= 0.5; const e = this.x; const i = this.y; const n = this.z; const s = this.w; const r = Math.sin(t); const o = Math.cos(t); return this.x = e * o - n * r, this.y = i * o + s * r, this.z = n * o + e * r, this.w = s * o - i * r, this; }, rotateZ(t) { t *= 0.5; const e = this.x; const i = this.y; const n = this.z; const s = this.w; const r = Math.sin(t); const o = Math.cos(t); return this.x = e * o + i * r, this.y = i * o - e * r, this.z = n * o + s * r, this.w = s * o - n * r, this; }, calculateW() { const t = this.x; const e = this.y; const i = this.z; return this.w = -Math.sqrt(1 - t * t - e * e - i * i), this; }, fromMat3(t) { let e; const i = t.val; const n = i[0] + i[4] + i[8]; if (n > 0)e = Math.sqrt(n + 1), this.w = 0.5 * e, e = 0.5 / e, this.x = (i[7] - i[5]) * e, this.y = (i[2] - i[6]) * e, this.z = (i[3] - i[1]) * e; else { let s = 0; i[4] > i[0] && (s = 1), i[8] > i[3 * s + s] && (s = 2); const r = o[s]; const h = o[r]; e = Math.sqrt(i[3 * s + s] - i[3 * r + r] - i[3 * h + h] + 1), a[s] = 0.5 * e, e = 0.5 / e, a[r] = (i[3 * r + s] + i[3 * s + r]) * e, a[h] = (i[3 * h + s] + i[3 * s + h]) * e, this.x = a[0], this.y = a[1], this.z = a[2], this.w = (i[3 * h + r] - i[3 * r + h]) * e; } return this; },
  }); t.exports = d;
}, function (t, e, i) {
  var n = new (i(0))({
    initialize(t) { this.val = new Float32Array(16), t ? this.copy(t) : this.identity(); }, clone() { return new n(this); }, set(t) { return this.copy(t); }, copy(t) { const e = this.val; const i = t.val; return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], e[9] = i[9], e[10] = i[10], e[11] = i[11], e[12] = i[12], e[13] = i[13], e[14] = i[14], e[15] = i[15], this; }, fromArray(t) { const e = this.val; return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], this; }, zero() { const t = this.val; return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 0, this; }, xyz(t, e, i) { this.identity(); const n = this.val; return n[12] = t, n[13] = e, n[14] = i, this; }, scaling(t, e, i) { this.zero(); const n = this.val; return n[0] = t, n[5] = e, n[10] = i, n[15] = 1, this; }, identity() { const t = this.val; return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this; }, transpose() { const t = this.val; const e = t[1]; const i = t[2]; const n = t[3]; const s = t[6]; const r = t[7]; const o = t[11]; return t[1] = t[4], t[2] = t[8], t[3] = t[12], t[4] = e, t[6] = t[9], t[7] = t[13], t[8] = i, t[9] = s, t[11] = t[14], t[12] = n, t[13] = r, t[14] = o, this; }, invert() { const t = this.val; const e = t[0]; const i = t[1]; const n = t[2]; const s = t[3]; const r = t[4]; const o = t[5]; const a = t[6]; const h = t[7]; const l = t[8]; const u = t[9]; const c = t[10]; const d = t[11]; const f = t[12]; const p = t[13]; const g = t[14]; const v = t[15]; const y = e * o - i * r; const m = e * a - n * r; const x = e * h - s * r; const w = i * a - n * o; const b = i * h - s * o; const T = n * h - s * a; const S = l * p - u * f; const _ = l * g - c * f; const A = l * v - d * f; const C = u * g - c * p; const M = u * v - d * p; const P = c * v - d * g; let E = y * P - m * M + x * C + w * A - b * _ + T * S; return E ? (E = 1 / E, t[0] = (o * P - a * M + h * C) * E, t[1] = (n * M - i * P - s * C) * E, t[2] = (p * T - g * b + v * w) * E, t[3] = (c * b - u * T - d * w) * E, t[4] = (a * A - r * P - h * _) * E, t[5] = (e * P - n * A + s * _) * E, t[6] = (g * x - f * T - v * m) * E, t[7] = (l * T - c * x + d * m) * E, t[8] = (r * M - o * A + h * S) * E, t[9] = (i * A - e * M - s * S) * E, t[10] = (f * b - p * x + v * y) * E, t[11] = (u * x - l * b - d * y) * E, t[12] = (o * _ - r * C - a * S) * E, t[13] = (e * C - i * _ + n * S) * E, t[14] = (p * m - f * w - g * y) * E, t[15] = (l * w - u * m + c * y) * E, this) : null; }, adjoint() { const t = this.val; const e = t[0]; const i = t[1]; const n = t[2]; const s = t[3]; const r = t[4]; const o = t[5]; const a = t[6]; const h = t[7]; const l = t[8]; const u = t[9]; const c = t[10]; const d = t[11]; const f = t[12]; const p = t[13]; const g = t[14]; const v = t[15]; return t[0] = o * (c * v - d * g) - u * (a * v - h * g) + p * (a * d - h * c), t[1] = -(i * (c * v - d * g) - u * (n * v - s * g) + p * (n * d - s * c)), t[2] = i * (a * v - h * g) - o * (n * v - s * g) + p * (n * h - s * a), t[3] = -(i * (a * d - h * c) - o * (n * d - s * c) + u * (n * h - s * a)), t[4] = -(r * (c * v - d * g) - l * (a * v - h * g) + f * (a * d - h * c)), t[5] = e * (c * v - d * g) - l * (n * v - s * g) + f * (n * d - s * c), t[6] = -(e * (a * v - h * g) - r * (n * v - s * g) + f * (n * h - s * a)), t[7] = e * (a * d - h * c) - r * (n * d - s * c) + l * (n * h - s * a), t[8] = r * (u * v - d * p) - l * (o * v - h * p) + f * (o * d - h * u), t[9] = -(e * (u * v - d * p) - l * (i * v - s * p) + f * (i * d - s * u)), t[10] = e * (o * v - h * p) - r * (i * v - s * p) + f * (i * h - s * o), t[11] = -(e * (o * d - h * u) - r * (i * d - s * u) + l * (i * h - s * o)), t[12] = -(r * (u * g - c * p) - l * (o * g - a * p) + f * (o * c - a * u)), t[13] = e * (u * g - c * p) - l * (i * g - n * p) + f * (i * c - n * u), t[14] = -(e * (o * g - a * p) - r * (i * g - n * p) + f * (i * a - n * o)), t[15] = e * (o * c - a * u) - r * (i * c - n * u) + l * (i * a - n * o), this; }, determinant() { const t = this.val; const e = t[0]; const i = t[1]; const n = t[2]; const s = t[3]; const r = t[4]; const o = t[5]; const a = t[6]; const h = t[7]; const l = t[8]; const u = t[9]; const c = t[10]; const d = t[11]; const f = t[12]; const p = t[13]; const g = t[14]; const v = t[15]; return (e * o - i * r) * (c * v - d * g) - (e * a - n * r) * (u * v - d * p) + (e * h - s * r) * (u * g - c * p) + (i * a - n * o) * (l * v - d * f) - (i * h - s * o) * (l * g - c * f) + (n * h - s * a) * (l * p - u * f); }, multiply(t) { const e = this.val; const i = e[0]; const n = e[1]; const s = e[2]; const r = e[3]; const o = e[4]; const a = e[5]; const h = e[6]; const l = e[7]; const u = e[8]; const c = e[9]; const d = e[10]; const f = e[11]; const p = e[12]; const g = e[13]; const v = e[14]; const y = e[15]; const m = t.val; let x = m[0]; let w = m[1]; let b = m[2]; let T = m[3]; return e[0] = x * i + w * o + b * u + T * p, e[1] = x * n + w * a + b * c + T * g, e[2] = x * s + w * h + b * d + T * v, e[3] = x * r + w * l + b * f + T * y, x = m[4], w = m[5], b = m[6], T = m[7], e[4] = x * i + w * o + b * u + T * p, e[5] = x * n + w * a + b * c + T * g, e[6] = x * s + w * h + b * d + T * v, e[7] = x * r + w * l + b * f + T * y, x = m[8], w = m[9], b = m[10], T = m[11], e[8] = x * i + w * o + b * u + T * p, e[9] = x * n + w * a + b * c + T * g, e[10] = x * s + w * h + b * d + T * v, e[11] = x * r + w * l + b * f + T * y, x = m[12], w = m[13], b = m[14], T = m[15], e[12] = x * i + w * o + b * u + T * p, e[13] = x * n + w * a + b * c + T * g, e[14] = x * s + w * h + b * d + T * v, e[15] = x * r + w * l + b * f + T * y, this; }, multiplyLocal(t) { const e = []; const i = this.val; const n = t.val; return e[0] = i[0] * n[0] + i[1] * n[4] + i[2] * n[8] + i[3] * n[12], e[1] = i[0] * n[1] + i[1] * n[5] + i[2] * n[9] + i[3] * n[13], e[2] = i[0] * n[2] + i[1] * n[6] + i[2] * n[10] + i[3] * n[14], e[3] = i[0] * n[3] + i[1] * n[7] + i[2] * n[11] + i[3] * n[15], e[4] = i[4] * n[0] + i[5] * n[4] + i[6] * n[8] + i[7] * n[12], e[5] = i[4] * n[1] + i[5] * n[5] + i[6] * n[9] + i[7] * n[13], e[6] = i[4] * n[2] + i[5] * n[6] + i[6] * n[10] + i[7] * n[14], e[7] = i[4] * n[3] + i[5] * n[7] + i[6] * n[11] + i[7] * n[15], e[8] = i[8] * n[0] + i[9] * n[4] + i[10] * n[8] + i[11] * n[12], e[9] = i[8] * n[1] + i[9] * n[5] + i[10] * n[9] + i[11] * n[13], e[10] = i[8] * n[2] + i[9] * n[6] + i[10] * n[10] + i[11] * n[14], e[11] = i[8] * n[3] + i[9] * n[7] + i[10] * n[11] + i[11] * n[15], e[12] = i[12] * n[0] + i[13] * n[4] + i[14] * n[8] + i[15] * n[12], e[13] = i[12] * n[1] + i[13] * n[5] + i[14] * n[9] + i[15] * n[13], e[14] = i[12] * n[2] + i[13] * n[6] + i[14] * n[10] + i[15] * n[14], e[15] = i[12] * n[3] + i[13] * n[7] + i[14] * n[11] + i[15] * n[15], this.fromArray(e); }, translate(t) { const e = t.x; const i = t.y; const n = t.z; const s = this.val; return s[12] = s[0] * e + s[4] * i + s[8] * n + s[12], s[13] = s[1] * e + s[5] * i + s[9] * n + s[13], s[14] = s[2] * e + s[6] * i + s[10] * n + s[14], s[15] = s[3] * e + s[7] * i + s[11] * n + s[15], this; }, scale(t) { const e = t.x; const i = t.y; const n = t.z; const s = this.val; return s[0] *= e, s[1] *= e, s[2] *= e, s[3] *= e, s[4] *= i, s[5] *= i, s[6] *= i, s[7] *= i, s[8] *= n, s[9] *= n, s[10] *= n, s[11] *= n, this; }, makeRotationAxis(t, e) { const i = Math.cos(e); const n = Math.sin(e); const s = 1 - i; const r = t.x; const o = t.y; const a = t.z; const h = s * r; const l = s * o; return this.fromArray([h * r + i, h * o - n * a, h * a + n * o, 0, h * o + n * a, l * o + i, l * a - n * r, 0, h * a - n * o, l * a + n * r, s * a * a + i, 0, 0, 0, 0, 1]), this; }, rotate(t, e) { const i = this.val; let n = e.x; let s = e.y; let r = e.z; let o = Math.sqrt(n * n + s * s + r * r); if (Math.abs(o) < 1e-6) return null; n *= o = 1 / o, s *= o, r *= o; const a = Math.sin(t); const h = Math.cos(t); const l = 1 - h; const u = i[0]; const c = i[1]; const d = i[2]; const f = i[3]; const p = i[4]; const g = i[5]; const v = i[6]; const y = i[7]; const m = i[8]; const x = i[9]; const w = i[10]; const b = i[11]; const T = n * n * l + h; const S = s * n * l + r * a; const _ = r * n * l - s * a; const A = n * s * l - r * a; const C = s * s * l + h; const M = r * s * l + n * a; const P = n * r * l + s * a; const E = s * r * l - n * a; const k = r * r * l + h; return i[0] = u * T + p * S + m * _, i[1] = c * T + g * S + x * _, i[2] = d * T + v * S + w * _, i[3] = f * T + y * S + b * _, i[4] = u * A + p * C + m * M, i[5] = c * A + g * C + x * M, i[6] = d * A + v * C + w * M, i[7] = f * A + y * C + b * M, i[8] = u * P + p * E + m * k, i[9] = c * P + g * E + x * k, i[10] = d * P + v * E + w * k, i[11] = f * P + y * E + b * k, this; }, rotateX(t) { const e = this.val; const i = Math.sin(t); const n = Math.cos(t); const s = e[4]; const r = e[5]; const o = e[6]; const a = e[7]; const h = e[8]; const l = e[9]; const u = e[10]; const c = e[11]; return e[4] = s * n + h * i, e[5] = r * n + l * i, e[6] = o * n + u * i, e[7] = a * n + c * i, e[8] = h * n - s * i, e[9] = l * n - r * i, e[10] = u * n - o * i, e[11] = c * n - a * i, this; }, rotateY(t) { const e = this.val; const i = Math.sin(t); const n = Math.cos(t); const s = e[0]; const r = e[1]; const o = e[2]; const a = e[3]; const h = e[8]; const l = e[9]; const u = e[10]; const c = e[11]; return e[0] = s * n - h * i, e[1] = r * n - l * i, e[2] = o * n - u * i, e[3] = a * n - c * i, e[8] = s * i + h * n, e[9] = r * i + l * n, e[10] = o * i + u * n, e[11] = a * i + c * n, this; }, rotateZ(t) { const e = this.val; const i = Math.sin(t); const n = Math.cos(t); const s = e[0]; const r = e[1]; const o = e[2]; const a = e[3]; const h = e[4]; const l = e[5]; const u = e[6]; const c = e[7]; return e[0] = s * n + h * i, e[1] = r * n + l * i, e[2] = o * n + u * i, e[3] = a * n + c * i, e[4] = h * n - s * i, e[5] = l * n - r * i, e[6] = u * n - o * i, e[7] = c * n - a * i, this; }, fromRotationTranslation(t, e) { const i = this.val; const n = t.x; const s = t.y; const r = t.z; const o = t.w; const a = n + n; const h = s + s; const l = r + r; const u = n * a; const c = n * h; const d = n * l; const f = s * h; const p = s * l; const g = r * l; const v = o * a; const y = o * h; const m = o * l; return i[0] = 1 - (f + g), i[1] = c + m, i[2] = d - y, i[3] = 0, i[4] = c - m, i[5] = 1 - (u + g), i[6] = p + v, i[7] = 0, i[8] = d + y, i[9] = p - v, i[10] = 1 - (u + f), i[11] = 0, i[12] = e.x, i[13] = e.y, i[14] = e.z, i[15] = 1, this; }, fromQuat(t) { const e = this.val; const i = t.x; const n = t.y; const s = t.z; const r = t.w; const o = i + i; const a = n + n; const h = s + s; const l = i * o; const u = i * a; const c = i * h; const d = n * a; const f = n * h; const p = s * h; const g = r * o; const v = r * a; const y = r * h; return e[0] = 1 - (d + p), e[1] = u + y, e[2] = c - v, e[3] = 0, e[4] = u - y, e[5] = 1 - (l + p), e[6] = f + g, e[7] = 0, e[8] = c + v, e[9] = f - g, e[10] = 1 - (l + d), e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this; }, frustum(t, e, i, n, s, r) { const o = this.val; const a = 1 / (e - t); const h = 1 / (n - i); const l = 1 / (s - r); return o[0] = 2 * s * a, o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[5] = 2 * s * h, o[6] = 0, o[7] = 0, o[8] = (e + t) * a, o[9] = (n + i) * h, o[10] = (r + s) * l, o[11] = -1, o[12] = 0, o[13] = 0, o[14] = r * s * 2 * l, o[15] = 0, this; }, perspective(t, e, i, n) { const s = this.val; const r = 1 / Math.tan(t / 2); const o = 1 / (i - n); return s[0] = r / e, s[1] = 0, s[2] = 0, s[3] = 0, s[4] = 0, s[5] = r, s[6] = 0, s[7] = 0, s[8] = 0, s[9] = 0, s[10] = (n + i) * o, s[11] = -1, s[12] = 0, s[13] = 0, s[14] = 2 * n * i * o, s[15] = 0, this; }, perspectiveLH(t, e, i, n) { const s = this.val; return s[0] = 2 * i / t, s[1] = 0, s[2] = 0, s[3] = 0, s[4] = 0, s[5] = 2 * i / e, s[6] = 0, s[7] = 0, s[8] = 0, s[9] = 0, s[10] = -n / (i - n), s[11] = 1, s[12] = 0, s[13] = 0, s[14] = i * n / (i - n), s[15] = 0, this; }, ortho(t, e, i, n, s, r) { const o = this.val; let a = t - e; let h = i - n; let l = s - r; return a = a === 0 ? a : 1 / a, h = h === 0 ? h : 1 / h, l = l === 0 ? l : 1 / l, o[0] = -2 * a, o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[5] = -2 * h, o[6] = 0, o[7] = 0, o[8] = 0, o[9] = 0, o[10] = 2 * l, o[11] = 0, o[12] = (t + e) * a, o[13] = (n + i) * h, o[14] = (r + s) * l, o[15] = 1, this; }, lookAt(t, e, i) { const n = this.val; const s = t.x; const r = t.y; const o = t.z; const a = i.x; const h = i.y; const l = i.z; const u = e.x; const c = e.y; const d = e.z; if (Math.abs(s - u) < 1e-6 && Math.abs(r - c) < 1e-6 && Math.abs(o - d) < 1e-6) return this.identity(); let f = s - u; let p = r - c; let g = o - d; let v = 1 / Math.sqrt(f * f + p * p + g * g); let y = h * (g *= v) - l * (p *= v); let m = l * (f *= v) - a * g; let x = a * p - h * f; (v = Math.sqrt(y * y + m * m + x * x)) ? (y *= v = 1 / v, m *= v, x *= v) : (y = 0, m = 0, x = 0); let w = p * x - g * m; let b = g * y - f * x; let T = f * m - p * y; return (v = Math.sqrt(w * w + b * b + T * T)) ? (w *= v = 1 / v, b *= v, T *= v) : (w = 0, b = 0, T = 0), n[0] = y, n[1] = w, n[2] = f, n[3] = 0, n[4] = m, n[5] = b, n[6] = p, n[7] = 0, n[8] = x, n[9] = T, n[10] = g, n[11] = 0, n[12] = -(y * s + m * r + x * o), n[13] = -(w * s + b * r + T * o), n[14] = -(f * s + p * r + g * o), n[15] = 1, this; }, yawPitchRoll(t, e, i) { this.zero(), s.zero(), r.zero(); const n = this.val; const o = s.val; const a = r.val; let h = Math.sin(i); let l = Math.cos(i); return n[10] = 1, n[15] = 1, n[0] = l, n[1] = h, n[4] = -h, n[5] = l, h = Math.sin(e), l = Math.cos(e), o[0] = 1, o[15] = 1, o[5] = l, o[10] = l, o[9] = -h, o[6] = h, h = Math.sin(t), l = Math.cos(t), a[5] = 1, a[15] = 1, a[0] = l, a[2] = -h, a[8] = h, a[10] = l, this.multiplyLocal(s), this.multiplyLocal(r), this; }, setWorldMatrix(t, e, i, n, o) { return this.yawPitchRoll(t.y, t.x, t.z), s.scaling(i.x, i.y, i.z), r.xyz(e.x, e.y, e.z), this.multiplyLocal(s), this.multiplyLocal(r), void 0 !== n && this.multiplyLocal(n), void 0 !== o && this.multiplyLocal(o), this; },
  }); var s = new n(); var r = new n(); t.exports = n;
}, function (t, e, i) {
  var n = new (i(0))({
    initialize(t) { this.val = new Float32Array(9), t ? this.copy(t) : this.identity(); }, clone() { return new n(this); }, set(t) { return this.copy(t); }, copy(t) { const e = this.val; const i = t.val; return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], this; }, fromMat4(t) { const e = t.val; const i = this.val; return i[0] = e[0], i[1] = e[1], i[2] = e[2], i[3] = e[4], i[4] = e[5], i[5] = e[6], i[6] = e[8], i[7] = e[9], i[8] = e[10], this; }, fromArray(t) { const e = this.val; return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], this; }, identity() { const t = this.val; return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, this; }, transpose() { const t = this.val; const e = t[1]; const i = t[2]; const n = t[5]; return t[1] = t[3], t[2] = t[6], t[3] = e, t[5] = t[7], t[6] = i, t[7] = n, this; }, invert() { const t = this.val; const e = t[0]; const i = t[1]; const n = t[2]; const s = t[3]; const r = t[4]; const o = t[5]; const a = t[6]; const h = t[7]; const l = t[8]; const u = l * r - o * h; const c = -l * s + o * a; const d = h * s - r * a; let f = e * u + i * c + n * d; return f ? (f = 1 / f, t[0] = u * f, t[1] = (-l * i + n * h) * f, t[2] = (o * i - n * r) * f, t[3] = c * f, t[4] = (l * e - n * a) * f, t[5] = (-o * e + n * s) * f, t[6] = d * f, t[7] = (-h * e + i * a) * f, t[8] = (r * e - i * s) * f, this) : null; }, adjoint() { const t = this.val; const e = t[0]; const i = t[1]; const n = t[2]; const s = t[3]; const r = t[4]; const o = t[5]; const a = t[6]; const h = t[7]; const l = t[8]; return t[0] = r * l - o * h, t[1] = n * h - i * l, t[2] = i * o - n * r, t[3] = o * a - s * l, t[4] = e * l - n * a, t[5] = n * s - e * o, t[6] = s * h - r * a, t[7] = i * a - e * h, t[8] = e * r - i * s, this; }, determinant() { const t = this.val; const e = t[0]; const i = t[1]; const n = t[2]; const s = t[3]; const r = t[4]; const o = t[5]; const a = t[6]; const h = t[7]; const l = t[8]; return e * (l * r - o * h) + i * (-l * s + o * a) + n * (h * s - r * a); }, multiply(t) { const e = this.val; const i = e[0]; const n = e[1]; const s = e[2]; const r = e[3]; const o = e[4]; const a = e[5]; const h = e[6]; const l = e[7]; const u = e[8]; const c = t.val; const d = c[0]; const f = c[1]; const p = c[2]; const g = c[3]; const v = c[4]; const y = c[5]; const m = c[6]; const x = c[7]; const w = c[8]; return e[0] = d * i + f * r + p * h, e[1] = d * n + f * o + p * l, e[2] = d * s + f * a + p * u, e[3] = g * i + v * r + y * h, e[4] = g * n + v * o + y * l, e[5] = g * s + v * a + y * u, e[6] = m * i + x * r + w * h, e[7] = m * n + x * o + w * l, e[8] = m * s + x * a + w * u, this; }, translate(t) { const e = this.val; const i = t.x; const n = t.y; return e[6] = i * e[0] + n * e[3] + e[6], e[7] = i * e[1] + n * e[4] + e[7], e[8] = i * e[2] + n * e[5] + e[8], this; }, rotate(t) { const e = this.val; const i = e[0]; const n = e[1]; const s = e[2]; const r = e[3]; const o = e[4]; const a = e[5]; const h = Math.sin(t); const l = Math.cos(t); return e[0] = l * i + h * r, e[1] = l * n + h * o, e[2] = l * s + h * a, e[3] = l * r - h * i, e[4] = l * o - h * n, e[5] = l * a - h * s, this; }, scale(t) { const e = this.val; const i = t.x; const n = t.y; return e[0] = i * e[0], e[1] = i * e[1], e[2] = i * e[2], e[3] = n * e[3], e[4] = n * e[4], e[5] = n * e[5], this; }, fromQuat(t) { const e = t.x; const i = t.y; const n = t.z; const s = t.w; const r = e + e; const o = i + i; const a = n + n; const h = e * r; const l = e * o; const u = e * a; const c = i * o; const d = i * a; const f = n * a; const p = s * r; const g = s * o; const v = s * a; const y = this.val; return y[0] = 1 - (c + f), y[3] = l + v, y[6] = u - g, y[1] = l - v, y[4] = 1 - (h + f), y[7] = d + p, y[2] = u + g, y[5] = d - p, y[8] = 1 - (h + c), this; }, normalFromMat4(t) { const e = t.val; const i = this.val; const n = e[0]; const s = e[1]; const r = e[2]; const o = e[3]; const a = e[4]; const h = e[5]; const l = e[6]; const u = e[7]; const c = e[8]; const d = e[9]; const f = e[10]; const p = e[11]; const g = e[12]; const v = e[13]; const y = e[14]; const m = e[15]; const x = n * h - s * a; const w = n * l - r * a; const b = n * u - o * a; const T = s * l - r * h; const S = s * u - o * h; const _ = r * u - o * l; const A = c * v - d * g; const C = c * y - f * g; const M = c * m - p * g; const P = d * y - f * v; const E = d * m - p * v; const k = f * m - p * y; let L = x * k - w * E + b * P + T * M - S * C + _ * A; return L ? (L = 1 / L, i[0] = (h * k - l * E + u * P) * L, i[1] = (l * M - a * k - u * C) * L, i[2] = (a * E - h * M + u * A) * L, i[3] = (r * E - s * k - o * P) * L, i[4] = (n * k - r * M + o * C) * L, i[5] = (s * M - n * E - o * A) * L, i[6] = (v * _ - y * S + m * T) * L, i[7] = (y * b - g * _ - m * w) * L, i[8] = (g * S - v * b + m * x) * L, this) : null; },
  }); t.exports = n;
}, function (t, e) { t.exports = function (t, e) { const i = t.x; const n = t.y; return t.x = i * Math.cos(e) - n * Math.sin(e), t.y = i * Math.sin(e) + n * Math.cos(e), t; }; }, function (t, e) { t.exports = function (t, e, i, n) { return void 0 === i && (i = 0), e === 0 ? t : (t -= i, t = e * Math.ceil(t / e), n ? (i + t) / e : i + t); }; }, function (t, e) { t.exports = function (t) { if (t === 0) return 1; for (var e = t; --t;)e *= t; return e; }; }, function (t, e, i) { const n = i(244); t.exports = function (t, e) { return n(t) / n(e) / n(t - e); }; }, function (t, e) { t.exports = function (t, e, i) { return void 0 === i && (i = 1e-4), t < e + i; }; }, function (t, e) { t.exports = function (t, e, i) { return void 0 === i && (i = 1e-4), t > e - i; }; }, function (t, e) { t.exports = function (t, e, i) { return void 0 === i && (i = 1e-4), Math.abs(t - e) < i; }; }, function (t, e) { t.exports = function (t, e, i, n) { const s = t - i; const r = e - n; return s * s + r * r; }; }, function (t, e) { t.exports = function (t) { return (t %= 2 * Math.PI) >= 0 ? t : t + 2 * Math.PI; }; }, function (t, e, i) {
  const n = i(0); const s = i(18); const r = i(21); const o = i(7); const a = i(2); const h = i(8); const l = new n({
    Extends: r,
    initialize(t, e, i, n) {
      let s = 'txt'; if (h(e)) { const o = e; e = a(o, 'key'), i = a(o, 'url'), n = a(o, 'xhrSettings'), s = a(o, 'extension', s); } const l = {
        type: 'text', cache: t.cacheManager.text, extension: s, responseType: 'text', key: e, url: i, xhrSettings: n,
      }; r.call(this, t, l);
    },
    onProcess() { this.state = s.FILE_PROCESSING, this.data = this.xhrLoader.responseText, this.onProcessComplete(); },
  }); o.register('text', function (t, e, i) { if (Array.isArray(t)) for (let n = 0; n < t.length; n++) this.addFile(new l(this, t[n])); else this.addFile(new l(this, t, e, i)); return this; }), t.exports = l;
}, function (t, e, i) {
  const n = i(0); const s = i(21); const r = i(2); const o = i(141); const a = i(8); const h = new n({
    Extends: s,
    initialize(t, e, i, n) {
      if (a(e)) { const o = e; e = r(o, 'key'), n = r(o, 'config', n); } const h = {
        type: 'audio', cache: t.cacheManager.audio, extension: i.type, key: e, url: i.url, config: n,
      }; s.call(this, t, h), this.locked = 'ontouchstart' in window, this.loaded = !1, this.filesLoaded = 0, this.filesTotal = 0;
    },
    onLoad() { this.loaded || (this.loaded = !0, this.loader.nextFile(this, !0)); },
    onError() { for (let t = 0; t < this.data.length; t++) { const e = this.data[t]; e.oncanplaythrough = null, e.onerror = null; } this.loader.nextFile(this, !1); },
    onProgress(t) { const e = t.target; e.oncanplaythrough = null, e.onerror = null, this.filesLoaded++, this.percentComplete = Math.min(this.filesLoaded / this.filesTotal, 1), this.loader.emit('fileprogress', this, this.percentComplete), this.filesLoaded === this.filesTotal && this.onLoad(); },
    load() { this.data = []; const t = this.config && this.config.instances || 1; this.filesTotal = t, this.filesLoaded = 0, this.percentComplete = 0; for (var e = 0; e < t; e++) { var i = new Audio(); i.dataset.name = this.key + (`0${e}`).slice(-2), i.dataset.used = 'false', this.locked ? i.dataset.locked = 'true' : (i.dataset.locked = 'false', i.preload = 'auto', i.oncanplaythrough = this.onProgress.bind(this), i.onerror = this.onError.bind(this)), this.data.push(i); } for (e = 0; e < this.data.length; e++)(i = this.data[e]).src = o(this, this.loader.baseURL), this.locked || i.load(); this.locked && setTimeout(this.onLoad.bind(this)); },
  }); t.exports = h;
}, function (t, e, i) {
  const n = i(0); const s = i(26); const r = i(21); const o = i(7); const a = i(2); const h = i(252); const l = i(8); const u = new n({
    Extends: r,
    initialize(t, e, i, n, s) {
      if (l(e)) { const o = e; e = a(o, 'key'), n = a(o, 'xhrSettings'), s = a(o, 'context', s); } const h = {
        type: 'audio', cache: t.cacheManager.audio, extension: i.type, responseType: 'arraybuffer', key: e, url: i.url, xhrSettings: n, config: { context: s },
      }; r.call(this, t, h);
    },
    onProcess() { this.state = s.FILE_PROCESSING; const t = this; this.config.context.decodeAudioData(this.xhrLoader.response, (e) => { t.data = e, t.onProcessComplete(); }, function (e) { console.error(`Error decoding audio: ${this.key} - `, e ? e.message : null), t.onProcessError(); }), this.config.context = null; },
  }); u.create = function (t, e, i, n, s) { const r = t.systems.game; const o = r.config.audio; const c = r.device.audio; l(e) && (i = a(e, 'url', []), n = a(e, 'config', {})); const d = u.getAudioURL(r, i); return d ? !c.webAudio || o && o.disableWebAudio ? new h(t, e, d, n) : new u(t, e, d, s, r.sound.context) : null; }, u.getAudioURL = function (t, e) { Array.isArray(e) || (e = [e]); for (let i = 0; i < e.length; i++) { const n = a(e[i], 'url', e[i]); if (n.indexOf('blob:') === 0 || n.indexOf('data:') === 0) return n; let s = n.match(/\.([a-zA-Z0-9]+)($|\?)/); if (s = a(e[i], 'type', s ? s[1] : '').toLowerCase(), t.device.audio[s]) return { url: n, type: s }; } return null; }, o.register('audio', function (t, e, i, n) { let s; const r = this.systems.game; const o = r.config.audio; const a = r.device.audio; if (o && o.noAudio || !a.webAudio && !a.audioData) return this; if (Array.isArray(t)) for (let h = 0; h < t.length; h++)(s = u.create(this, t[h])) && this.addFile(s); else (s = u.create(this, t, e, i, n)) && this.addFile(s); return this; }), t.exports = u;
}, function (t, e, i) { const n = i(140); t.exports = function (t, e) { const i = n(e, t.xhrSettings); const s = new XMLHttpRequest(); return s.open('GET', t.src, i.async, i.user, i.password), s.responseType = t.xhrSettings.responseType, s.timeout = i.timeout, i.header && i.headerValue && s.setRequestHeader(i.header, i.headerValue), i.requestedWith && s.setRequestHeader('X-Requested-With', i.requestedWith), i.overrideMimeType && s.overrideMimeType(i.overrideMimeType), s.onload = t.onLoad.bind(t, s), s.onerror = t.onError.bind(t), s.onprogress = t.onProgress.bind(t), s.send(), s; }; }, function (t, e, i) { const n = i(0); const s = i(2); const r = i(605); const o = i(603); const a = new n({ initialize(t, e, i) { if (void 0 === i && (i = {}), e.length < 2) return !1; this.manager = t, this.enabled = !0, this.keyCodes = []; for (let n = 0; n < e.length; n++) { const a = e[n]; typeof a === 'string' ? this.keyCodes.push(a.toUpperCase().charCodeAt(0)) : typeof a === 'number' ? this.keyCodes.push(a) : a.hasOwnProperty('keyCode') && this.keyCodes.push(a.keyCode); } this.current = this.keyCodes[0], this.index = 0, this.size = this.keyCodes.length, this.timeLastMatched = 0, this.matched = !1, this.timeMatched = 0, this.resetOnWrongKey = s(i, 'resetOnWrongKey', !0), this.maxKeyDelay = s(i, 'maxKeyDelay', 0), this.resetOnMatch = s(i, 'resetOnMatch', !1), this.deleteOnMatch = s(i, 'deleteOnMatch', !1); const h = this; const l = function (t) { !h.matched && h.enabled && (r(t, h) && (h.manager.emit('keycombomatch', h, t), h.resetOnMatch ? o(h) : h.deleteOnMatch && h.destroy())); }; this.onKeyDown = l, this.manager.on('keydown', l); }, progress: { get() { return this.index / this.size; } }, destroy() { this.enabled = !1, this.keyCodes = [], this.manager.off('keydown', this.onKeyDown), this.manager = null; } }); t.exports = a; }, function (t, e, i) { const n = new (i(0))({ initialize(t) { this.keyCode = t, this.originalEvent = void 0, this.preventDefault = !0, this.enabled = !0, this.isDown = !1, this.isUp = !0, this.altKey = !1, this.ctrlKey = !1, this.shiftKey = !1, this.location = 0, this.timeDown = 0, this.duration = 0, this.timeUp = 0, this.repeats = 0, this._justDown = !1, this._justUp = !1, this._tick = -1; }, reset() { return this.preventDefault = !0, this.enabled = !0, this.isDown = !1, this.isUp = !0, this.altKey = !1, this.ctrlKey = !1, this.shiftKey = !1, this.timeDown = 0, this.duration = 0, this.timeUp = 0, this.repeats = 0, this._justDown = !1, this._justUp = !1, this._tick = -1, this; } }); t.exports = n; }, function (t, e, i) {
  const n = i(259); const s = i(258); const r = i(0); const o = i(11); const a = i(3); const h = new r({
    Extends: o, initialize(t, e) { o.call(this), this.manager = t, this.pad = e, this.id = e.id, this.index = e.index; for (var i = [], r = 0; r < e.buttons.length; r++)i.push(new s(this, r)); this.buttons = i; const h = []; for (r = 0; r < e.axes.length; r++)h.push(new n(this, r)); this.axes = h, this.vibration = e.vibrationActuator; const l = { value: 0, pressed: !1 }; this._LCLeft = i[14] ? i[14] : l, this._LCRight = i[15] ? i[15] : l, this._LCTop = i[12] ? i[12] : l, this._LCBottom = i[13] ? i[13] : l, this._RCLeft = i[2] ? i[2] : l, this._RCRight = i[1] ? i[1] : l, this._RCTop = i[3] ? i[3] : l, this._RCBottom = i[0] ? i[0] : l, this._FBLeftTop = i[4] ? i[4] : l, this._FBLeftBottom = i[6] ? i[6] : l, this._FBRightTop = i[5] ? i[5] : l, this._FBRightBottom = i[7] ? i[7] : l; const u = { value: 0 }; this._HAxisLeft = h[0] ? h[0] : u, this._VAxisLeft = h[1] ? h[1] : u, this._HAxisRight = h[2] ? h[2] : u, this._VAxisRight = h[3] ? h[3] : u, this.leftStick = new a(), this.rightStick = new a(); }, getAxisTotal() { return this.axes.length; }, getAxisValue(t) { return this.axes[t].getValue(); }, setAxisThreshold(t) { for (let e = 0; e < this.axes.length; e++) this.axes[e].threshold = t; }, getButtonTotal() { return this.buttons.length; }, getButtonValue(t) { return this.buttons[t].value; }, isButtonDown(t) { return this.buttons[t].pressed; }, update(t) { let e; const i = this.buttons; const n = t.buttons; let s = i.length; for (e = 0; e < s; e++)i[e].update(n[e].value); const r = this.axes; const o = t.axes; for (s = r.length, e = 0; e < s; e++)r[e].update(o[e]); s >= 2 && (this.leftStick.set(r[0].getValue(), r[1].getValue()), s >= 4 && this.rightStick.set(r[2].getValue(), r[3].getValue())); }, destroy() { let t; for (this.removeAllListeners(), this.manager = null, this.pad = null, t = 0; t < this.buttons.length; t++) this.buttons[t].destroy(); for (t = 0; t < this.axes.length; t++) this.axes[t].destroy(); this.buttons = [], this.axes = []; }, connected: { get() { return this.pad.connected; } }, timestamp: { get() { return this.pad.timestamp; } }, left: { get() { return this._LCLeft.pressed; } }, right: { get() { return this._LCRight.pressed; } }, up: { get() { return this._LCTop.pressed; } }, down: { get() { return this._LCBottom.pressed; } }, A: { get() { return this._RCBottom.pressed; } }, Y: { get() { return this._RCTop.pressed; } }, X: { get() { return this._RCLeft.pressed; } }, B: { get() { return this._RCRight.pressed; } }, L1: { get() { return this._FBLeftTop.value; } }, L2: { get() { return this._FBLeftBottom.value; } }, R1: { get() { return this._FBRightTop.value; } }, R2: { get() { return this._FBRightBottom.value; } },
  }); t.exports = h;
}, function (t, e, i) { const n = new (i(0))({ initialize(t, e) { this.pad = t, this.events = t.manager, this.index = e, this.value = 0, this.threshold = 1, this.pressed = !1; }, update(t) { this.value = t; const e = this.pad; const i = this.index; t >= this.threshold ? this.pressed || (this.pressed = !0, this.events.emit('down', e, this, t), this.pad.emit('down', i, t, this)) : this.pressed && (this.pressed = !1, this.events.emit('up', e, this, t), this.pad.emit('up', i, t, this)); }, destroy() { this.pad = null, this.events = null; } }); t.exports = n; }, function (t, e, i) {
  const n = new (i(0))({
    initialize(t, e) { this.pad = t, this.events = t.events, this.index = e, this.value = 0, this.threshold = 0.1; }, update(t) { this.value = t; }, getValue() { return Math.abs(this.value) < this.threshold ? 0 : this.value; }, destroy() { this.pad = null, this.events = null; },
  }); t.exports = n;
}, function (t, e) {
  t.exports = function (t, e, i) {
    return {
      gameObject: t, enabled: !0, draggable: !1, dropZone: !1, cursor: !1, target: null, camera: null, hitArea: e, hitAreaCallback: i, localX: 0, localY: 0, dragState: 0, dragStartX: 0, dragStartY: 0, dragX: 0, dragY: 0,
    };
  };
}, function (t, e, i) { const n = i(6); function s(t, e, i, n) { const s = t - i; const r = e - n; const o = s * s + r * r; return Math.sqrt(o); }t.exports = function (t, e) { void 0 === e && (e = new n()); const i = t.x1; const r = t.y1; const o = t.x2; const a = t.y2; const h = t.x3; const l = t.y3; const u = s(h, l, o, a); const c = s(i, r, h, l); const d = s(o, a, i, r); const f = u + c + d; return e.x = (i * u + o * c + h * d) / f, e.y = (r * u + a * c + l * d) / f, e; }; }, function (t, e) { t.exports = function (t, e, i) { return t.x1 += e, t.y1 += i, t.x2 += e, t.y2 += i, t.x3 += e, t.y3 += i, t; }; }, function (t, e, i) { const n = i(6); t.exports = function (t, e) { return void 0 === e && (e = new n()), e.x = (t.x1 + t.x2 + t.x3) / 3, e.y = (t.y1 + t.y2 + t.y3) / 3, e; }; }, function (t, e) { t.exports = function (t, e) { return !(e.width * e.height > t.width * t.height) && e.x > t.x && e.x < t.right && e.right > t.x && e.right < t.right && e.y > t.y && e.y < t.bottom && e.bottom > t.y && e.bottom < t.bottom; }; }, function (t, e, i) { const n = i(9); n.Area = i(656), n.Ceil = i(655), n.CeilAll = i(654), n.CenterOn = i(175), n.Clone = i(653), n.Contains = i(39), n.ContainsPoint = i(652), n.ContainsRect = i(264), n.CopyFrom = i(651), n.Decompose = i(270), n.Equals = i(650), n.FitInside = i(649), n.FitOutside = i(648), n.Floor = i(647), n.FloorAll = i(646), n.FromPoints = i(173), n.GetAspectRatio = i(145), n.GetCenter = i(645), n.GetPoint = i(190), n.GetPoints = i(398), n.GetSize = i(644), n.Inflate = i(643), n.Intersection = i(642), n.MarchingAnts = i(388), n.MergePoints = i(641), n.MergeRect = i(640), n.MergeXY = i(639), n.Offset = i(638), n.OffsetPoint = i(637), n.Overlaps = i(636), n.Perimeter = i(124), n.PerimeterPoint = i(635), n.Random = i(187), n.RandomOutside = i(634), n.SameDimensions = i(633), n.Scale = i(632), n.Union = i(309), t.exports = n; }, function (t, e) { t.exports = function (t) { return t.x * t.x + t.y * t.y; }; }, function (t, e) { t.exports = function (t) { return Math.sqrt(t.x * t.x + t.y * t.y); }; }, function (t, e, i) { const n = i(16); const s = i(53); const r = i(68); t.exports = function (t) { const e = r(t) - n.TAU; return s(e, -Math.PI, Math.PI); }; }, function (t, e) { t.exports = function (t, e) { return void 0 === e && (e = []), e.push({ x: t.x1, y: t.y1 }), e.push({ x: t.x2, y: t.y2 }), e.push({ x: t.x3, y: t.y3 }), e; }; }, function (t, e) { t.exports = function (t, e) { return void 0 === e && (e = []), e.push({ x: t.x, y: t.y }), e.push({ x: t.right, y: t.y }), e.push({ x: t.right, y: t.bottom }), e.push({ x: t.x, y: t.bottom }), e; }; }, function (t, e) { t.exports = function (t, e) { return (t.x - e.x1) * (e.y2 - e.y1) == (e.x2 - e.x1) * (t.y - e.y1); }; }, function (t, e, i) { const n = i(40); const s = new (i(6))(); t.exports = function (t, e, i) { if (void 0 === i && (i = s), n(e, t.x1, t.y1)) return i.x = t.x1, i.y = t.y1, !0; if (n(e, t.x2, t.y2)) return i.x = t.x2, i.y = t.y2, !0; const r = t.x2 - t.x1; const o = t.y2 - t.y1; const a = e.x - t.x1; const h = e.y - t.y1; const l = r * r + o * o; let u = r; let c = o; if (l > 0) { const d = (a * r + h * o) / l; u *= d, c *= d; } return i.x = t.x1 + u, i.y = t.y1 + c, u * u + c * c <= l && u * r + c * o >= 0 && n(e, i.x, i.y); }; }, function (t, e, i) {
  t.exports = {
    CircleToCircle: i(703), CircleToRectangle: i(702), GetRectangleIntersection: i(701), LineToCircle: i(272), LineToLine: i(107), LineToRectangle: i(700), PointToLine: i(271), PointToLineSegment: i(699), RectangleToRectangle: i(148), RectangleToTriangle: i(698), RectangleToValues: i(697), TriangleToCircle: i(696), TriangleToLine: i(695), TriangleToTriangle: i(694),
  };
}, function (t, e, i) {
  t.exports = {
    Circle: i(723), Ellipse: i(713), Intersects: i(273), Line: i(693), Point: i(675), Polygon: i(661), Rectangle: i(265), Triangle: i(631),
  };
}, function (t, e, i) {
  const n = i(0); const s = i(276); const r = i(10); const o = new n({
    initialize() { this.lightPool = [], this.lights = [], this.culledLights = [], this.ambientColor = { r: 0.1, g: 0.1, b: 0.1 }, this.active = !1, this.maxLights = -1; }, enable() { return this.maxLights === -1 && (this.maxLights = this.scene.sys.game.renderer.config.maxLights), this.active = !0, this; }, disable() { return this.active = !1, this; }, cull(t) { const e = this.lights; const i = this.culledLights; const n = e.length; const s = t.x + t.width / 2; const r = t.y + t.height / 2; const o = (t.width + t.height) / 2; const a = { x: 0, y: 0 }; const h = t.matrix; const l = this.systems.game.config.height; i.length = 0; for (let u = 0; u < n && i.length < this.maxLights; u++) { const c = e[u]; h.transformPoint(c.x, c.y, a); const d = s - (a.x - t.scrollX * c.scrollFactorX * t.zoom); const f = r - (l - (a.y - t.scrollY * c.scrollFactorY * t.zoom)); Math.sqrt(d * d + f * f) < c.radius + o && i.push(e[u]); } return i; }, forEachLight(t) { if (t) { for (let e = this.lights, i = e.length, n = 0; n < i; ++n)t(e[n]); return this; } }, setAmbientColor(t) { const e = r.getFloatsFromUintRGB(t); return this.ambientColor.r = e[0], this.ambientColor.g = e[1], this.ambientColor.b = e[2], this; }, getMaxVisibleLights() { return 10; }, getLightCount() { return this.lights.length; }, addLight(t, e, i, n, o) { let a; let h = null; return t = void 0 === t ? 0 : t, e = void 0 === e ? 0 : e, n = void 0 === n ? 16777215 : n, i = void 0 === i ? 100 : i, o = void 0 === o ? 1 : o, a = r.getFloatsFromUintRGB(n), h = null, this.lightPool.length > 0 ? (h = this.lightPool.pop()).set(t, e, i, a[0], a[1], a[2], o) : h = new s(t, e, i, a[0], a[1], a[2], o), this.lights.push(h), h; }, removeLight(t) { const e = this.lights.indexOf(t); return e >= 0 && (this.lightPool.push(t), this.lights.splice(e, 1)), this; }, shutdown() { for (;this.lights.length > 0;) this.lightPool.push(this.lights.pop()); this.ambientColor = { r: 0.1, g: 0.1, b: 0.1 }, this.culledLights.length = 0, this.lights.length = 0; }, destroy() { this.shutdown(); },
  }); t.exports = o;
}, function (t, e, i) {
  const n = i(0); const s = i(10); const r = new n({
    initialize(t, e, i, n, s, r, o) { this.x = t, this.y = e, this.radius = i, this.r = n, this.g = s, this.b = r, this.intensity = o, this.scrollFactorX = 1, this.scrollFactorY = 1; }, set(t, e, i, n, s, r, o) { return this.x = t, this.y = e, this.radius = i, this.r = n, this.g = s, this.b = r, this.intensity = o, this.scrollFactorX = 1, this.scrollFactorY = 1, this; }, setScrollFactor(t, e) { return void 0 === t && (t = 1), void 0 === e && (e = t), this.scrollFactorX = t, this.scrollFactorY = e, this; }, setColor(t) { const e = s.getFloatsFromUintRGB(t); return this.r = e[0], this.g = e[1], this.b = e[2], this; }, setIntensity(t) { return this.intensity = t, this; }, setPosition(t, e) { return this.x = t, this.y = e, this; }, setRadius(t) { return this.radius = t, this; },
  }); t.exports = r;
}, function (t, e, i) { const n = i(65); const s = i(6); t.exports = function (t, e, i, r) { void 0 === r && (r = []); const o = t.getLineA(); const a = t.getLineB(); const h = t.getLineC(); const l = n(o); const u = n(a); const c = n(h); const d = l + u + c; e || (e = d / i); for (let f = 0; f < e; f++) { let p = d * (f / e); let g = 0; const v = new s(); p < l ? (g = p / l, v.x = o.x1 + (o.x2 - o.x1) * g, v.y = o.y1 + (o.y2 - o.y1) * g) : p > l + u ? (g = (p -= l + u) / c, v.x = h.x1 + (h.x2 - h.x1) * g, v.y = h.y1 + (h.y2 - h.y1) * g) : (g = (p -= l) / u, v.x = a.x1 + (a.x2 - a.x1) * g, v.y = a.y1 + (a.y2 - a.y1) * g), r.push(v); } return r; }; }, function (t, e, i) { const n = i(6); const s = i(65); t.exports = function (t, e, i) { void 0 === i && (i = new n()); const r = t.getLineA(); const o = t.getLineB(); const a = t.getLineC(); if (e <= 0 || e >= 1) return i.x = r.x1, i.y = r.y1, i; const h = s(r); const l = s(o); const u = s(a); let c = (h + l + u) * e; let d = 0; return c < h ? (d = c / h, i.x = r.x1 + (r.x2 - r.x1) * d, i.y = r.y1 + (r.y2 - r.y1) * d) : c > h + l ? (d = (c -= h + l) / u, i.x = a.x1 + (a.x2 - a.x1) * d, i.y = a.y1 + (a.y2 - a.y1) * d) : (d = (c -= h) / l, i.x = o.x1 + (o.x2 - o.x1) * d, i.y = o.y1 + (o.y2 - o.y1) * d), i; }; }, function (t, e, i) {
  const n = i(0); const s = i(27); const r = i(59); const o = i(772); const a = new n({
    Extends: s, Mixins: [o], initialize(t, e, i, n, o, a, h, l, u, c, d) { void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), void 0 === o && (o = 128), void 0 === a && (a = 64), void 0 === h && (h = 0), void 0 === l && (l = 128), void 0 === u && (u = 128), s.call(this, t, 'Triangle', new r(n, o, a, h, l, u)); const f = this.geom.right - this.geom.left; const p = this.geom.bottom - this.geom.top; this.setPosition(e, i), this.setSize(f, p), void 0 !== c && this.setFillStyle(c, d), this.updateDisplayOrigin(), this.updateData(); }, setTo(t, e, i, n, s, r) { return this.geom.setTo(t, e, i, n, s, r), this.updateData(); }, updateData() { const t = []; const e = this.geom; const i = this._tempLine; return e.getLineA(i), t.push(i.x1, i.y1, i.x2, i.y2), e.getLineB(i), t.push(i.x2, i.y2), e.getLineC(i), t.push(i.x2, i.y2), this.pathData = t, this; },
  }); t.exports = a;
}, function (t, e, i) {
  const n = i(775); const s = i(0); const r = i(64); const o = i(27); const a = new s({
    Extends: o, Mixins: [n], initialize(t, e, i, n, s, r, a, h) { void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 5), void 0 === s && (s = 32), void 0 === r && (r = 64), o.call(this, t, 'Star', null), this._points = n, this._innerRadius = s, this._outerRadius = r, this.setPosition(e, i), this.setSize(2 * r, 2 * r), void 0 !== a && this.setFillStyle(a, h), this.updateDisplayOrigin(), this.updateData(); }, setPoints(t) { return this._points = t, this.updateData(); }, setInnerRadius(t) { return this._innerRadius = t, this.updateData(); }, setOuterRadius(t) { return this._outerRadius = t, this.updateData(); }, points: { get() { return this._points; }, set(t) { this._points = t, this.updateData(); } }, innerRadius: { get() { return this._innerRadius; }, set(t) { this._innerRadius = t, this.updateData(); } }, outerRadius: { get() { return this._outerRadius; }, set(t) { this._outerRadius = t, this.updateData(); } }, updateData() { const t = []; const e = this._points; const i = this._innerRadius; const n = this._outerRadius; let s = Math.PI / 2 * 3; const o = Math.PI / e; const a = n; const h = n; t.push(a, h + -n); for (let l = 0; l < e; l++)t.push(a + Math.cos(s) * n, h + Math.sin(s) * n), s += o, t.push(a + Math.cos(s) * i, h + Math.sin(s) * i), s += o; return t.push(a, h + -n), this.pathIndexes = r(t), this.pathData = t, this; },
  }); t.exports = a;
}, function (t, e, i) {
  const n = i(0); const s = i(9); const r = i(27); const o = i(778); const a = new n({
    Extends: r, Mixins: [o], initialize(t, e, i, n, o, a, h) { void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 128), void 0 === o && (o = 128), r.call(this, t, 'Rectangle', new s(0, 0, n, o)), this.setPosition(e, i), this.setSize(n, o), void 0 !== a && this.setFillStyle(a, h), this.updateDisplayOrigin(), this.updateData(); }, updateData() { const t = []; const e = this.geom; const i = this._tempLine; return e.getLineA(i), t.push(i.x1, i.y1, i.x2, i.y2), e.getLineB(i), t.push(i.x2, i.y2), e.getLineC(i), t.push(i.x2, i.y2), e.getLineD(i), t.push(i.x2, i.y2), this.pathData = t, this; },
  }); t.exports = a;
}, function (t, e) { const i = function (t, e) { return t[0] = e[0], t[1] = e[1], t; }; t.exports = function (t) { let e; const n = []; const s = t.points; for (e = 0; e < s.length; e++)n.push([s[e].x, s[e].y]); const r = []; for (n.length > 0 && r.push(i([0, 0], n[0])), e = 0; e < n.length - 1; e++) { const o = n[e]; const a = n[e + 1]; const h = o[0]; const l = o[1]; const u = a[0]; const c = a[1]; r.push([0.85 * h + 0.15 * u, 0.85 * l + 0.15 * c]), r.push([0.15 * h + 0.85 * u, 0.15 * l + 0.85 * c]); } return n.length > 1 && r.push(i([0, 0], n[n.length - 1])), t.setTo(r); }; }, function (t, e, i) { const n = i(65); const s = i(54); t.exports = function (t) { for (var e = t.points, i = 0, r = 0; r < e.length; r++) { const o = e[r]; const a = e[(r + 1) % e.length]; const h = new s(o.x, o.y, a.x, a.y); i += n(h); } return i; }; }, function (t, e, i) { const n = i(65); const s = i(54); const r = i(283); t.exports = function (t, e, i, o) { void 0 === o && (o = []); const a = t.points; const h = r(t); e || (e = h / i); for (let l = 0; l < e; l++) for (let u = h * (l / e), c = 0, d = 0; d < a.length; d++) { const f = a[d]; const p = a[(d + 1) % a.length]; const g = new s(f.x, f.y, p.x, p.y); const v = n(g); if (!(u < c || u > c + v)) { const y = g.getPoint((u - c) / v); o.push(y); break; }c += v; } return o; }; }, function (t, e, i) { const n = i(9); t.exports = function (t, e) { void 0 === e && (e = new n()); for (var i, s = 1 / 0, r = 1 / 0, o = -s, a = -r, h = 0; h < t.points.length; h++)i = t.points[h], s = Math.min(s, i.x), r = Math.min(r, i.y), o = Math.max(o, i.x), a = Math.max(a, i.y); return e.x = s, e.y = r, e.width = o - s, e.height = a - r, e; }; }, function (t, e, i) {
  const n = i(781); const s = i(0); const r = i(64); const o = i(285); const a = i(151); const h = i(27); const l = i(282); const u = new s({
    Extends: h, Mixins: [n], initialize(t, e, i, n, s, r) { void 0 === e && (e = 0), void 0 === i && (i = 0), h.call(this, t, 'Polygon', new a(n)); const l = o(this.geom); this.setPosition(e, i), this.setSize(l.width, l.height), void 0 !== s && this.setFillStyle(s, r), this.updateDisplayOrigin(), this.updateData(); }, smooth(t) { void 0 === t && (t = 1); for (let e = 0; e < t; e++)l(this.geom); return this.updateData(); }, updateData() { for (var t = [], e = this.geom.points, i = 0; i < e.length; i++)t.push(e[i].x, e[i].y); return t.push(e[0].x, e[0].y), this.pathIndexes = r(t), this.pathData = t, this; },
  }); t.exports = u;
}, function (t, e, i) {
  const n = i(0); const s = i(27); const r = i(54); const o = i(784); const a = new n({
    Extends: s, Mixins: [o], initialize(t, e, i, n, o, a, h, l, u) { void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), void 0 === o && (o = 0), void 0 === a && (a = 128), void 0 === h && (h = 0), s.call(this, t, 'Line', new r(n, o, a, h)); const c = this.geom.right - this.geom.left; const d = this.geom.bottom - this.geom.top; this.lineWidth = 1, this._startWidth = 1, this._endWidth = 1, this.setPosition(e, i), this.setSize(c, d), void 0 !== l && this.setStrokeStyle(1, l, u), this.updateDisplayOrigin(); }, setLineWidth(t, e) { return void 0 === e && (e = t), this._startWidth = t, this._endWidth = e, this.lineWidth = t, this; }, setTo(t, e, i, n) { return this.geom.setTo(t, e, i, n), this; },
  }); t.exports = a;
}, function (t, e, i) {
  const n = i(0); const s = i(787); const r = i(27); const o = new n({
    Extends: r, Mixins: [s], initialize(t, e, i, n, s, o, a, h, l) { void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 48), void 0 === s && (s = 32), void 0 === o && (o = !1), void 0 === a && (a = 15658734), void 0 === h && (h = 10066329), void 0 === l && (l = 13421772), r.call(this, t, 'IsoTriangle', null), this.projection = 4, this.fillTop = a, this.fillLeft = h, this.fillRight = l, this.showTop = !0, this.showLeft = !0, this.showRight = !0, this.isReversed = o, this.isFilled = !0, this.setPosition(e, i), this.setSize(n, s), this.updateDisplayOrigin(); }, setProjection(t) { return this.projection = t, this; }, setReversed(t) { return this.isReversed = t, this; }, setFaces(t, e, i) { return void 0 === t && (t = !0), void 0 === e && (e = !0), void 0 === i && (i = !0), this.showTop = t, this.showLeft = e, this.showRight = i, this; }, setFillStyle(t, e, i) { return this.fillTop = t, this.fillLeft = e, this.fillRight = i, this.isFilled = !0, this; },
  }); t.exports = o;
}, function (t, e, i) {
  const n = i(790); const s = i(0); const r = i(27); const o = new s({
    Extends: r, Mixins: [n], initialize(t, e, i, n, s, o, a, h) { void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 48), void 0 === s && (s = 32), void 0 === o && (o = 15658734), void 0 === a && (a = 10066329), void 0 === h && (h = 13421772), r.call(this, t, 'IsoBox', null), this.projection = 4, this.fillTop = o, this.fillLeft = a, this.fillRight = h, this.showTop = !0, this.showLeft = !0, this.showRight = !0, this.isFilled = !0, this.setPosition(e, i), this.setSize(n, s), this.updateDisplayOrigin(); }, setProjection(t) { return this.projection = t, this; }, setFaces(t, e, i) { return void 0 === t && (t = !0), void 0 === e && (e = !0), void 0 === i && (i = !0), this.showTop = t, this.showLeft = e, this.showRight = i, this; }, setFillStyle(t, e, i) { return this.fillTop = t, this.fillLeft = e, this.fillRight = i, this.isFilled = !0, this; },
  }); t.exports = o;
}, function (t, e, i) {
  const n = i(0); const s = i(27); const r = i(793); const o = new n({
    Extends: s, Mixins: [r], initialize(t, e, i, n, r, o, a, h, l, u, c) { void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 128), void 0 === r && (r = 128), void 0 === o && (o = 32), void 0 === a && (a = 32), s.call(this, t, 'Grid', null), this.cellWidth = o, this.cellHeight = a, this.showCells = !0, this.outlineFillColor = 0, this.outlineFillAlpha = 0, this.showOutline = !0, this.showAltCells = !1, this.altFillColor, this.altFillAlpha, this.setPosition(e, i), this.setSize(n, r), void 0 !== h && this.setFillStyle(h, l), void 0 !== u && this.setOutlineStyle(u, c), this.updateDisplayOrigin(); }, setFillStyle(t, e) { return void 0 === e && (e = 1), void 0 === t ? this.showCells = !1 : (this.fillColor = t, this.fillAlpha = e, this.showCells = !0), this; }, setAltFillStyle(t, e) { return void 0 === e && (e = 1), void 0 === t ? this.showAltCells = !1 : (this.altFillColor = t, this.altFillAlpha = e, this.showAltCells = !0), this; }, setOutlineStyle(t, e) { return void 0 === e && (e = 1), void 0 === t ? this.showOutline = !1 : (this.outlineFillColor = t, this.outlineFillAlpha = e, this.showOutline = !0), this; },
  }); t.exports = o;
}, function (t, e, i) {
  const n = i(0); const s = i(64); const r = i(796); const o = i(90); const a = i(27); const h = new n({
    Extends: a, Mixins: [r], initialize(t, e, i, n, s, r, h) { void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 128), void 0 === s && (s = 128), a.call(this, t, 'Ellipse', new o(n / 2, s / 2, n, s)), this._smoothness = 64, this.setPosition(e, i), this.width = n, this.height = s, void 0 !== r && this.setFillStyle(r, h), this.updateDisplayOrigin(), this.updateData(); }, smoothness: { get() { return this._smoothness; }, set(t) { this._smoothness = t, this.updateData(); } }, setSize(t, e) { return this.geom.setSize(t, e), this.updateData(); }, setSmoothness(t) { return this._smoothness = t, this.updateData(); }, updateData() { for (var t = [], e = this.geom.getPoints(this._smoothness), i = 0; i < e.length; i++)t.push(e[i].x, e[i].y); return t.push(e[0].x, e[0].y), this.pathIndexes = s(t), this.pathData = t, this; },
  }); t.exports = h;
}, function (t, e, i) {
  const n = i(0); const s = i(799); const r = i(64); const o = i(9); const a = i(27); const h = new n({
    Extends: a, Mixins: [s], initialize(t, e, i, n, s, r) { void 0 === e && (e = 0), void 0 === i && (i = 0), a.call(this, t, 'Curve', n), this._smoothness = 32, this._curveBounds = new o(), this.closePath = !1, this.setPosition(e, i), void 0 !== s && this.setFillStyle(s, r), this.updateData(); }, smoothness: { get() { return this._smoothness; }, set(t) { this._smoothness = t, this.updateData(); } }, setSmoothness(t) { return this._smoothness = t, this.updateData(); }, updateData() { const t = this._curveBounds; const e = this._smoothness; this.geom.getBounds(t, e), this.setSize(t.width, t.height), this.updateDisplayOrigin(); for (var i = [], n = this.geom.getPoints(e), s = 0; s < n.length; s++)i.push(n[s].x, n[s].y); return i.push(n[0].x, n[0].y), this.pathIndexes = r(i), this.pathData = i, this; },
  }); t.exports = h;
}, function (t, e, i) {
  const n = i(802); const s = i(0); const r = i(31); const o = i(64); const a = i(71); const h = i(16); const l = i(27); const u = new s({
    Extends: l, Mixins: [n], initialize(t, e, i, n, s, r, o, h, u) { void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 128), void 0 === s && (s = 0), void 0 === r && (r = 360), void 0 === o && (o = !1), l.call(this, t, 'Arc', new a(0, 0, n)), this._startAngle = s, this._endAngle = r, this._anticlockwise = o, this._iterations = 0.01, this.setPosition(e, i), this.setSize(this.geom.radius, this.geom.radius), void 0 !== h && this.setFillStyle(h, u), this.updateDisplayOrigin(), this.updateData(); }, iterations: { get() { return this._iterations; }, set(t) { this._iterations = t, this.updateData(); } }, radius: { get() { return this.geom.radius; }, set(t) { this.geom.radius = t, this.updateData(); } }, startAngle: { get() { return this._startAngle; }, set(t) { this._startAngle = t, this.updateData(); } }, endAngle: { get() { return this._endAngle; }, set(t) { this._endAngle = t, this.updateData(); } }, anticlockwise: { get() { return this._anticlockwise; }, set(t) { this._anticlockwise = t, this.updateData(); } }, setRadius(t) { return this.radius = t, this; }, setIterations(t) { return void 0 === t && (t = 0.01), this.iterations = t, this; }, setStartAngle(t, e) { return this._startAngle = t, void 0 !== e && (this._anticlockwise = e), this.updateData(); }, setEndAngle(t, e) { return this._endAngle = t, void 0 !== e && (this._anticlockwise = e), this.updateData(); }, updateData() { const t = this._iterations; let e = t; const i = this.geom.radius; const n = r(this._startAngle); let s = r(this._endAngle); const a = i / 2; const l = i / 2; s -= n, this._anticlockwise ? s < -h.PI2 ? s = -h.PI2 : s > 0 && (s = -h.PI2 + s % h.PI2) : s > h.PI2 ? s = h.PI2 : s < 0 && (s = h.PI2 + s % h.PI2); for (var u, c = [a + Math.cos(n) * i, l + Math.sin(n) * i]; e < 1;)u = s * e + n, c.push(a + Math.cos(u) * i, l + Math.sin(u) * i), e += t; return u = s + n, c.push(a + Math.cos(u) * i, l + Math.sin(u) * i), c.push(a + Math.cos(n) * i, l + Math.sin(n) * i), this.pathIndexes = o(c), this.pathData = c, this; },
  }); t.exports = u;
}, function (t, e) { t.exports = function (t) { const e = Math.log(t) / 0.6931471805599453; return 1 << Math.ceil(e); }; }, function (t, e) { t.exports = function () { return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (t) => { const e = 16 * Math.random() | 0; return (t === 'x' ? e : 3 & e | 8).toString(16); }); }; }, function (t, e, i) {
  const n = i(0); const s = i(31); const r = i(84); const o = i(4); const a = i(61); const h = i(83); const l = i(3); const u = new n({
    Extends: a, initialize(t, e, i, n, s, r) { a.call(this, t, i, n, s, r), this.path = e, this.rotateToPath = !1, this.pathRotationVerticalAdjust = !1, this.pathRotationOffset = 0, this.pathOffset = new l(i, n), this.pathVector = new l(), this.pathTween, this.pathConfig = null, this._prevDirection = h.PLAYING_FORWARD; }, setPath(t, e) { void 0 === e && (e = this.pathConfig); const i = this.pathTween; return i && i.isPlaying() && i.stop(), this.path = t, e && this.startFollow(e), this; }, setRotateToPath(t, e, i) { return void 0 === e && (e = 0), void 0 === i && (i = !1), this.rotateToPath = t, this.pathRotationOffset = e, this.pathRotationVerticalAdjust = i, this; }, isFollowing() { const t = this.pathTween; return t && t.isPlaying(); }, startFollow(t, e) { void 0 === t && (t = {}), void 0 === e && (e = 0); const i = this.pathTween; i && i.isPlaying() && i.stop(), typeof t === 'number' && (t = { duration: t }), t.from = 0, t.to = 1; const n = r(t, 'positionOnPath', !1); if (this.rotateToPath = r(t, 'rotateToPath', !1), this.pathRotationOffset = o(t, 'rotationOffset', 0), this.pathRotationVerticalAdjust = r(t, 'verticalAdjust', !1), this.pathTween = this.scene.sys.tweens.addCounter(t), this.path.getStartPoint(this.pathOffset), n && (this.x = this.pathOffset.x, this.y = this.pathOffset.y), this.pathOffset.x = this.x - this.pathOffset.x, this.pathOffset.y = this.y - this.pathOffset.y, this._prevDirection = h.PLAYING_FORWARD, this.rotateToPath) { const a = this.path.getPoint(0.1); this.rotation = Math.atan2(a.y - this.y, a.x - this.x) + s(this.pathRotationOffset); } return this.pathConfig = t, this; }, pauseFollow() { const t = this.pathTween; return t && t.isPlaying() && t.pause(), this; }, resumeFollow() { const t = this.pathTween; return t && t.isPaused() && t.resume(), this; }, stopFollow() { const t = this.pathTween; return t && t.isPlaying() && t.stop(), this; }, preUpdate(t, e) { this.anims.update(t, e); const i = this.pathTween; if (i) { const n = i.data[0]; if (n.state !== h.PLAYING_FORWARD && n.state !== h.PLAYING_BACKWARD) return; const r = this.pathVector; this.path.getPoint(i.getValue(), r), r.add(this.pathOffset); const o = this.x; const a = this.y; this.setPosition(r.x, r.y); const l = this.x - o; const u = this.y - a; if (l === 0 && u === 0) return; if (n.state !== this._prevDirection) return void (this._prevDirection = n.state); this.rotateToPath && (this.rotation = Math.atan2(u, l) + s(this.pathRotationOffset), this.pathRotationVerticalAdjust && (this.flipY = this.rotation !== 0 && n.state === h.PLAYING_BACKWARD)); } },
  }); t.exports = u;
}, function (t, e, i) { const n = i(0); const s = i(3); const r = new n({ initialize(t) { this.source = t, this._tempVec = new s(); }, getPoint(t) { const e = this._tempVec; this.source.getRandomPoint(e), t.x = e.x, t.y = e.y; } }); t.exports = r; }, function (t, e) { t.exports = function (t, e) { for (let i = 0; i < e.length; i++) if (t.hasOwnProperty(e[i])) return !0; return !1; }; }, function (t, e) { t.exports = function (t, e) { return Math.random() * (e - t) + t; }; }, function (t, e, i) {
  const n = new (i(0))({
    initialize(t, e, i, n, s) { void 0 === n && (n = !1), void 0 === s && (s = !0), this.source = t, this.points = [], this.quantity = e, this.stepRate = i, this.yoyo = n, this.counter = -1, this.seamless = s, this._length = 0, this._direction = 0, this.updateSource(); }, updateSource() { if (this.points = this.source.getPoints(this.quantity, this.stepRate), this.seamless) { const t = this.points[0]; const e = this.points[this.points.length - 1]; t.x === e.x && t.y === e.y && this.points.pop(); } const i = this._length; return this._length = this.points.length, this._length < i && this.counter > this._length && (this.counter = this._length - 1), this; }, changeSource(t) { return this.source = t, this.updateSource(); }, getPoint(t) { this._direction === 0 ? (this.counter++, this.counter >= this._length && (this.yoyo ? (this._direction = 1, this.counter = this._length - 1) : this.counter = 0)) : (this.counter--, this.counter === -1 && (this.yoyo ? (this._direction = 0, this.counter = 0) : this.counter = this._length - 1)); const e = this.points[this.counter]; e && (t.x = e.x, t.y = e.y); },
  }); t.exports = n;
}, function (t, e, i) { const n = new (i(0))({ initialize(t, e) { this.source = t, this.killOnEnter = e; }, willKill(t) { const e = this.source.contains(t.x, t.y); return e && this.killOnEnter || !e && !this.killOnEnter; } }); t.exports = n; }, function (t, e, i) {
  const n = i(66); const s = i(0); const r = i(14); const o = i(301); const a = i(300); const h = i(822); const l = i(2); const u = i(162); const c = i(298); const d = i(85); const f = i(303); const p = i(297); const g = i(9); const v = i(110); const y = i(3); const m = i(53); const x = new s({
    Mixins: [r.BlendMode, r.Mask, r.ScrollFactor, r.Visible], initialize(t, e) { this.manager = t, this.texture = t.texture, this.frames = [t.defaultFrame], this.defaultFrame = t.defaultFrame, this.configFastMap = ['active', 'blendMode', 'collideBottom', 'collideLeft', 'collideRight', 'collideTop', 'deathCallback', 'deathCallbackScope', 'emitCallback', 'emitCallbackScope', 'follow', 'frequency', 'gravityX', 'gravityY', 'maxParticles', 'name', 'on', 'particleBringToTop', 'particleClass', 'radial', 'timeScale', 'trackVisible', 'visible'], this.configOpMap = ['accelerationX', 'accelerationY', 'angle', 'alpha', 'bounce', 'delay', 'lifespan', 'maxVelocityX', 'maxVelocityY', 'moveToX', 'moveToY', 'quantity', 'rotate', 'scaleX', 'scaleY', 'speedX', 'speedY', 'tint', 'x', 'y'], this.name = '', this.particleClass = f, this.x = new h(e, 'x', 0), this.y = new h(e, 'y', 0), this.radial = !0, this.gravityX = 0, this.gravityY = 0, this.acceleration = !1, this.accelerationX = new h(e, 'accelerationX', 0, !0), this.accelerationY = new h(e, 'accelerationY', 0, !0), this.maxVelocityX = new h(e, 'maxVelocityX', 1e4, !0), this.maxVelocityY = new h(e, 'maxVelocityY', 1e4, !0), this.speedX = new h(e, 'speedX', 0, !0), this.speedY = new h(e, 'speedY', 0, !0), this.moveTo = !1, this.moveToX = new h(e, 'moveToX', 0, !0), this.moveToY = new h(e, 'moveToY', 0, !0), this.bounce = new h(e, 'bounce', 0, !0), this.scaleX = new h(e, 'scaleX', 1), this.scaleY = new h(e, 'scaleY', 1), this.tint = new h(e, 'tint', 4294967295), this.alpha = new h(e, 'alpha', 1), this.lifespan = new h(e, 'lifespan', 1e3), this.angle = new h(e, 'angle', { min: 0, max: 360 }), this.rotate = new h(e, 'rotate', 0), this.emitCallback = null, this.emitCallbackScope = null, this.deathCallback = null, this.deathCallbackScope = null, this.maxParticles = 0, this.quantity = new h(e, 'quantity', 1, !0), this.delay = new h(e, 'delay', 0, !0), this.frequency = 0, this.on = !0, this.particleBringToTop = !0, this.timeScale = 1, this.emitZone = null, this.deathZone = null, this.bounds = null, this.collideLeft = !0, this.collideRight = !0, this.collideTop = !0, this.collideBottom = !0, this.active = !0, this.visible = !0, this.blendMode = n.NORMAL, this.follow = null, this.followOffset = new y(), this.trackVisible = !1, this.currentFrame = 0, this.randomFrame = !0, this.frameQuantity = 1, this.dead = [], this.alive = [], this._counter = 0, this._frameCounter = 0, e && this.fromJSON(e); }, fromJSON(t) { if (!t) return this; let e = 0; let i = ''; for (e = 0; e < this.configFastMap.length; e++)i = this.configFastMap[e], d(t, i) && (this[i] = l(t, i)); for (e = 0; e < this.configOpMap.length; e++)i = this.configOpMap[e], d(t, i) && this[i].loadConfig(t); if (this.acceleration = this.accelerationX.propertyValue !== 0 || this.accelerationY.propertyValue !== 0, this.moveTo = this.moveToX.propertyValue !== 0 || this.moveToY.propertyValue !== 0, d(t, 'speed') && (this.speedX.loadConfig(t, 'speed'), this.speedY = null), (c(t, ['speedX', 'speedY']) || this.moveTo) && (this.radial = !1), d(t, 'scale') && (this.scaleX.loadConfig(t, 'scale'), this.scaleY = null), d(t, 'callbackScope')) { const n = l(t, 'callbackScope', null); this.emitCallbackScope = n, this.deathCallbackScope = n; } return d(t, 'emitZone') && this.setEmitZone(t.emitZone), d(t, 'deathZone') && this.setDeathZone(t.deathZone), d(t, 'bounds') && this.setBounds(t.bounds), d(t, 'followOffset') && this.followOffset.setFromObject(l(t, 'followOffset', 0)), d(t, 'frame') && this.setFrame(t.frame), this; }, toJSON(t) { void 0 === t && (t = {}); let e = 0; let i = ''; for (e = 0; e < this.configFastMap.length; e++)t[i = this.configFastMap[e]] = this[i]; for (e = 0; e < this.configOpMap.length; e++) this[i = this.configOpMap[e]] && (t[i] = this[i].toJSON()); return this.speedY || (delete t.speedX, t.speed = this.speedX.toJSON()), this.scaleY || (delete t.scaleX, t.scale = this.scaleX.toJSON()), t; }, startFollow(t, e, i, n) { return void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = !1), this.follow = t, this.followOffset.set(e, i), this.trackVisible = n, this; }, stopFollow() { return this.follow = null, this.followOffset.set(0, 0), this.trackVisible = !1, this; }, getFrame() { if (this.frames.length === 1) return this.defaultFrame; if (this.randomFrame) return u(this.frames); const t = this.frames[this.currentFrame]; return this._frameCounter++, this._frameCounter === this.frameQuantity && (this._frameCounter = 0, this.currentFrame = m(this.currentFrame + 1, 0, this._frameLength)), t; }, setFrame(t, e, i) { void 0 === e && (e = !0), void 0 === i && (i = 1), this.randomFrame = e, this.frameQuantity = i, this.currentFrame = 0, this._frameCounter = 0; const n = typeof t; if (Array.isArray(t) || n === 'string' || n === 'number') this.manager.setEmitterFrames(t, this); else if (n === 'object') { const s = t; (t = l(s, 'frames', null)) && this.manager.setEmitterFrames(t, this); const r = l(s, 'cycle', !1); this.randomFrame = !r, this.frameQuantity = l(s, 'quantity', i); } return this._frameLength = this.frames.length, this._frameLength === 1 && (this.frameQuantity = 1, this.randomFrame = !1), this; }, setRadial(t) { return void 0 === t && (t = !0), this.radial = t, this; }, setPosition(t, e) { return this.x.onChange(t), this.y.onChange(e), this; }, setBounds(t, e, i, n) { if (typeof t === 'object') { const s = t; t = s.x, e = s.y, i = d(s, 'w') ? s.w : s.width, n = d(s, 'h') ? s.h : s.height; } return this.bounds ? this.bounds.setTo(t, e, i, n) : this.bounds = new g(t, e, i, n), this; }, setSpeedX(t) { return this.speedX.onChange(t), this.radial = !1, this; }, setSpeedY(t) { return this.speedY && (this.speedY.onChange(t), this.radial = !1), this; }, setSpeed(t) { return this.speedX.onChange(t), this.speedY = null, this.radial = !0, this; }, setScaleX(t) { return this.scaleX.onChange(t), this; }, setScaleY(t) { return this.scaleY.onChange(t), this; }, setScale(t) { return this.scaleX.onChange(t), this.scaleY = null, this; }, setGravityX(t) { return this.gravityX = t, this; }, setGravityY(t) { return this.gravityY = t, this; }, setGravity(t, e) { return this.gravityX = t, this.gravityY = e, this; }, setAlpha(t) { return this.alpha.onChange(t), this; }, setEmitterAngle(t) { return this.angle.onChange(t), this; }, setAngle(t) { return this.angle.onChange(t), this; }, setLifespan(t) { return this.lifespan.onChange(t), this; }, setQuantity(t) { return this.quantity.onChange(t), this; }, setFrequency(t, e) { return this.frequency = t, this._counter = 0, e && this.quantity.onChange(e), this; }, setEmitZone(t) { if (void 0 === t) this.emitZone = null; else { const e = l(t, 'type', 'random'); const i = l(t, 'source', null); switch (e) { case 'random': this.emitZone = new p(i); break; case 'edge': var n = l(t, 'quantity', 1); var s = l(t, 'stepRate', 0); var r = l(t, 'yoyo', !1); var o = l(t, 'seamless', !0); this.emitZone = new a(i, n, s, r, o); } } return this; }, setDeathZone(t) { if (void 0 === t) this.deathZone = null; else { const e = l(t, 'type', 'onEnter'); const i = l(t, 'source', null); if (i && typeof i.contains === 'function') { const n = e === 'onEnter'; this.deathZone = new o(i, n); } } return this; }, reserve(t) { for (let e = this.dead, i = 0; i < t; i++)e.push(new this.particleClass(this)); return this; }, getAliveParticleCount() { return this.alive.length; }, getDeadParticleCount() { return this.dead.length; }, getParticleCount() { return this.getAliveParticleCount() + this.getDeadParticleCount(); }, atLimit() { return this.maxParticles > 0 && this.getParticleCount() === this.maxParticles; }, onParticleEmit(t, e) { return void 0 === t ? (this.emitCallback = null, this.emitCallbackScope = null) : typeof t === 'function' && (this.emitCallback = t, e && (this.emitCallbackScope = e)), this; }, onParticleDeath(t, e) { return void 0 === t ? (this.deathCallback = null, this.deathCallbackScope = null) : typeof t === 'function' && (this.deathCallback = t, e && (this.deathCallbackScope = e)), this; }, killAll() { for (let t = this.dead, e = this.alive; e.length > 0;)t.push(e.pop()); return this; }, forEachAlive(t, e) { for (let i = this.alive, n = i.length, s = 0; s < n; ++s)t.call(e, i[s], this); return this; }, forEachDead(t, e) { for (let i = this.dead, n = i.length, s = 0; s < n; ++s)t.call(e, i[s], this); return this; }, start() { return this.on = !0, this._counter = 0, this; }, stop() { return this.on = !1, this; }, pause() { return this.active = !1, this; }, resume() { return this.active = !0, this; }, depthSort() { return v.inplace(this.alive, this.depthSortCallback), this; }, flow(t, e) { return void 0 === e && (e = 1), this.frequency = t, this.quantity.onChange(e), this.start(); }, explode(t, e, i) { return this.frequency = -1, this.emitParticle(t, e, i); }, emitParticleAt(t, e, i) { return this.emitParticle(i, t, e); }, emitParticle(t, e, i) { if (!this.atLimit()) { void 0 === t && (t = this.quantity.onEmit()); for (let n = this.dead, s = 0; s < t; s++) { var r; if ((r = n.length > 0 ? n.pop() : new this.particleClass(this)).fire(e, i), this.particleBringToTop ? this.alive.push(r) : this.alive.unshift(r), this.emitCallback && this.emitCallback.call(this.emitCallbackScope, r, this), this.atLimit()) break; } return r; } }, preUpdate(t, e) { const i = (e *= this.timeScale) / 1e3; this.trackVisible && (this.visible = this.follow.visible); for (var n = this.manager.getProcessors(), s = this.alive, r = s.length, o = 0; o < r; o++) { const a = s[o]; if (a.update(e, i, n)) { const h = s[r - 1]; s[r - 1] = a, s[o] = h, o -= 1, r -= 1; } } const l = s.length - r; if (l > 0) { const u = s.splice(s.length - l, l); const c = this.deathCallback; const d = this.deathCallbackScope; if (c) for (let f = 0; f < u.length; f++)c.call(d, u[f]); this.dead.concat(u), v.inplace(s, this.indexSortCallback); } this.on && (this.frequency === 0 ? this.emitParticle() : this.frequency > 0 && (this._counter -= e, this._counter <= 0 && (this.emitParticle(), this._counter = this.frequency - Math.abs(this._counter)))); }, depthSortCallback(t, e) { return t.y - e.y; }, indexSortCallback(t, e) { return t.index - e.index; },
  }); t.exports = x;
}, function (t, e, i) {
  const n = i(0); const s = i(31); const r = i(52); const o = new n({
    initialize(t) {
      this.emitter = t, this.frame = null, this.index = 0, this.x = 0, this.y = 0, this.velocityX = 0, this.velocityY = 0, this.accelerationX = 0, this.accelerationY = 0, this.maxVelocityX = 1e4, this.maxVelocityY = 1e4, this.bounce = 0, this.scaleX = 1, this.scaleY = 1, this.alpha = 1, this.angle = 0, this.rotation = 0, this.tint = 16777215, this.life = 1e3, this.lifeCurrent = 1e3, this.delayCurrent = 0, this.lifeT = 0, this.data = {
        tint: { min: 16777215, max: 16777215, current: 16777215 }, alpha: { min: 1, max: 1 }, rotate: { min: 0, max: 0 }, scaleX: { min: 1, max: 1 }, scaleY: { min: 1, max: 1 },
      };
    },
    isAlive() { return this.lifeCurrent > 0; },
    fire(t, e) { const i = this.emitter; this.frame = i.getFrame(), i.emitZone && i.emitZone.getPoint(this), void 0 === t ? (i.follow && (this.x += i.follow.x + i.followOffset.x), this.x += i.x.onEmit(this, 'x')) : this.x += t, void 0 === e ? (i.follow && (this.y += i.follow.y + i.followOffset.y), this.y += i.y.onEmit(this, 'y')) : this.y += e, this.life = i.lifespan.onEmit(this, 'lifespan'), this.lifeCurrent = this.life, this.lifeT = 0; const n = i.speedX.onEmit(this, 'speedX'); const o = i.speedY ? i.speedY.onEmit(this, 'speedY') : n; if (i.radial) { const a = s(i.angle.onEmit(this, 'angle')); this.velocityX = Math.cos(a) * Math.abs(n), this.velocityY = Math.sin(a) * Math.abs(o); } else if (i.moveTo) { const h = i.moveToX.onEmit(this, 'moveToX'); const l = i.moveToY ? i.moveToY.onEmit(this, 'moveToY') : h; const u = Math.atan2(l - this.y, h - this.x); const c = r(this.x, this.y, h, l) / (this.life / 1e3); this.velocityX = Math.cos(u) * c, this.velocityY = Math.sin(u) * c; } else this.velocityX = n, this.velocityY = o; i.acceleration && (this.accelerationX = i.accelerationX.onEmit(this, 'accelerationX'), this.accelerationY = i.accelerationY.onEmit(this, 'accelerationY')), this.maxVelocityX = i.maxVelocityX.onEmit(this, 'maxVelocityX'), this.maxVelocityY = i.maxVelocityY.onEmit(this, 'maxVelocityY'), this.delayCurrent = i.delay.onEmit(this, 'delay'), this.scaleX = i.scaleX.onEmit(this, 'scaleX'), this.scaleY = i.scaleY ? i.scaleY.onEmit(this, 'scaleY') : this.scaleX, this.angle = i.rotate.onEmit(this, 'rotate'), this.rotation = s(this.angle), this.bounce = i.bounce.onEmit(this, 'bounce'), this.alpha = i.alpha.onEmit(this, 'alpha'), this.tint = i.tint.onEmit(this, 'tint'), this.index = i.alive.length; },
    computeVelocity(t, e, i, n) { let s = this.velocityX; let r = this.velocityY; const o = this.accelerationX; const a = this.accelerationY; const h = this.maxVelocityX; const l = this.maxVelocityY; s += t.gravityX * i, r += t.gravityY * i, o && (s += o * i), a && (r += a * i), s > h ? s = h : s < -h && (s = -h), r > l ? r = l : r < -l && (r = -l), this.velocityX = s, this.velocityY = r; for (let u = 0; u < n.length; u++)n[u].update(this, e, i); },
    checkBounds(t) { const e = t.bounds; const i = -this.bounce; this.x < e.x && t.collideLeft ? (this.x = e.x, this.velocityX *= i) : this.x > e.right && t.collideRight && (this.x = e.right, this.velocityX *= i), this.y < e.y && t.collideTop ? (this.y = e.y, this.velocityY *= i) : this.y > e.bottom && t.collideBottom && (this.y = e.bottom, this.velocityY *= i); },
    update(t, e, i) { if (this.delayCurrent > 0) return this.delayCurrent -= t, !1; const n = this.emitter; const r = 1 - this.lifeCurrent / this.life; return this.lifeT = r, this.computeVelocity(n, t, e, i), this.x += this.velocityX * e, this.y += this.velocityY * e, n.bounds && this.checkBounds(n), n.deathZone && n.deathZone.willKill(this) ? (this.lifeCurrent = 0, !0) : (this.scaleX = n.scaleX.onUpdate(this, 'scaleX', r, this.scaleX), n.scaleY ? this.scaleY = n.scaleY.onUpdate(this, 'scaleY', r, this.scaleY) : this.scaleY = this.scaleX, this.angle = n.rotate.onUpdate(this, 'rotate', r, this.angle), this.rotation = s(this.angle), this.alpha = n.alpha.onUpdate(this, 'alpha', r, this.alpha), this.tint = n.tint.onUpdate(this, 'tint', r, this.tint), this.lifeCurrent -= t, this.lifeCurrent <= 0); },
  }); t.exports = o;
}, function (t, e, i) {
  const n = i(0); const s = i(2); const r = new n({
    initialize(t, e, i, n, r) { if (typeof t === 'object') { const o = t; t = s(o, 'x', 0), e = s(o, 'y', 0), i = s(o, 'power', 0), n = s(o, 'epsilon', 100), r = s(o, 'gravity', 50); } else void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 100), void 0 === r && (r = 50); this.x = t, this.y = e, this.active = !0, this._gravity = r, this._power = 0, this._epsilon = 0, this.power = i, this.epsilon = n; }, update(t, e) { const i = this.x - t.x; const n = this.y - t.y; let s = i * i + n * n; if (s !== 0) { const r = Math.sqrt(s); s < this._epsilon && (s = this._epsilon); const o = this._power * e / (s * r) * 100; t.velocityX += i * o, t.velocityY += n * o; } }, epsilon: { get() { return Math.sqrt(this._epsilon); }, set(t) { this._epsilon = t * t; } }, power: { get() { return this._power / this._gravity; }, set(t) { this._power = t * this._gravity; } }, gravity: { get() { return this._gravity; }, set(t) { const e = this.power; this._gravity = t, this.power = e; } },
  }); t.exports = r;
}, function (t, e, i) { const n = i(157); const s = i(22); t.exports = function (t, e, i, r, o, a, h) { const l = e.commandBuffer; const u = l.length; const c = a || t.currentContext; if (u !== 0 && s(t, c, e, r, o)) { let d = 1; let f = 1; let p = 0; let g = 0; let v = 1; let y = 0; let m = 0; let x = 0; c.save(), c.beginPath(); for (let w = 0; w < u; ++w) switch (l[w]) { case n.ARC: c.arc(l[w + 1], l[w + 2], l[w + 3], l[w + 4], l[w + 5], l[w + 6]), w += 7; break; case n.LINE_STYLE: v = l[w + 1], p = l[w + 2], d = l[w + 3], y = (16711680 & p) >>> 16, m = (65280 & p) >>> 8, x = 255 & p, c.strokeStyle = `rgba(${y},${m},${x},${d})`, c.lineWidth = v, w += 3; break; case n.FILL_STYLE: g = l[w + 1], f = l[w + 2], y = (16711680 & g) >>> 16, m = (65280 & g) >>> 8, x = 255 & g, c.fillStyle = `rgba(${y},${m},${x},${f})`, w += 2; break; case n.BEGIN_PATH: c.beginPath(); break; case n.CLOSE_PATH: c.closePath(); break; case n.FILL_PATH: h || c.fill(); break; case n.STROKE_PATH: h || c.stroke(); break; case n.FILL_RECT: h ? c.rect(l[w + 1], l[w + 2], l[w + 3], l[w + 4]) : c.fillRect(l[w + 1], l[w + 2], l[w + 3], l[w + 4]), w += 4; break; case n.FILL_TRIANGLE: c.beginPath(), c.moveTo(l[w + 1], l[w + 2]), c.lineTo(l[w + 3], l[w + 4]), c.lineTo(l[w + 5], l[w + 6]), c.closePath(), h || c.fill(), w += 6; break; case n.STROKE_TRIANGLE: c.beginPath(), c.moveTo(l[w + 1], l[w + 2]), c.lineTo(l[w + 3], l[w + 4]), c.lineTo(l[w + 5], l[w + 6]), c.closePath(), h || c.stroke(), w += 6; break; case n.LINE_TO: c.lineTo(l[w + 1], l[w + 2]), w += 2; break; case n.MOVE_TO: c.moveTo(l[w + 1], l[w + 2]), w += 2; break; case n.LINE_FX_TO: c.lineTo(l[w + 1], l[w + 2]), w += 5; break; case n.MOVE_FX_TO: c.moveTo(l[w + 1], l[w + 2]), w += 5; break; case n.SAVE: c.save(); break; case n.RESTORE: c.restore(); break; case n.TRANSLATE: c.translate(l[w + 1], l[w + 2]), w += 2; break; case n.SCALE: c.scale(l[w + 1], l[w + 2]), w += 2; break; case n.ROTATE: c.rotate(l[w + 1]), w += 1; break; case n.GRADIENT_FILL_STYLE: w += 5; break; case n.GRADIENT_LINE_STYLE: w += 6; break; case n.SET_TEXTURE: w += 2; }c.restore(); } }; }, function (t, e) { t.exports = function (t) { const e = t.width / 2; const i = t.height / 2; const n = Math.pow(e - i, 2) / Math.pow(e + i, 2); return Math.PI * (e + i) * (1 + 3 * n / (10 + Math.sqrt(4 - 3 * n))); }; }, function (t, e, i) { const n = i(306); const s = i(156); const r = i(93); const o = i(16); t.exports = function (t, e, i, a) { void 0 === a && (a = []), e || (e = n(t) / i); for (let h = 0; h < e; h++) { const l = r(h / e, 0, o.PI2); a.push(s(t, l)); } return a; }; }, function (t, e, i) { const n = i(156); const s = i(93); const r = i(16); const o = i(6); t.exports = function (t, e, i) { void 0 === i && (i = new o()); const a = s(e, 0, r.PI2); return n(t, a, i); }; }, function (t, e, i) { const n = i(9); t.exports = function (t, e, i) { void 0 === i && (i = new n()); const s = Math.min(t.x, e.x); const r = Math.min(t.y, e.y); const o = Math.max(t.right, e.right) - s; const a = Math.max(t.bottom, e.bottom) - r; return i.setTo(s, r, o, a); }; }, function (t, e) {
  function i(t, e) { return parseInt(t.getAttribute(e), 10); }t.exports = function (t, e, n, s) {
    void 0 === e && (e = 0), void 0 === n && (n = 0); const r = {}; const o = t.getElementsByTagName('info')[0]; const a = t.getElementsByTagName('common')[0]; r.font = o.getAttribute('face'), r.size = i(o, 'size'), r.lineHeight = i(a, 'lineHeight') + n, r.chars = {}; const h = t.getElementsByTagName('char'); const l = void 0 !== s && s.trimmed; if (l) var u = s.height; let c = s.width; for (var d = 0; d < h.length; d++) {
      const f = h[d]; const p = i(f, 'id'); const g = i(f, 'x'); const v = i(f, 'y'); const y = i(f, 'width'); const m = i(f, 'height'); l && (g < c && (c = g), v < u && (u = v)), r.chars[p] = {
        x: g, y: v, width: y, height: m, centerX: Math.floor(y / 2), centerY: Math.floor(m / 2), xOffset: i(f, 'xoffset'), yOffset: i(f, 'yoffset'), xAdvance: i(f, 'xadvance') + e, data: {}, kerning: {},
      };
    } if (l && u !== 0 && c !== 0) for (const x in r.chars) { const w = r.chars[x]; w.x -= s.x, w.y -= s.y; } const b = t.getElementsByTagName('kerning'); for (d = 0; d < b.length; d++) { const T = b[d]; const S = i(T, 'first'); const _ = i(T, 'second'); const A = i(T, 'amount'); r.chars[_].kerning[S] = A; } return r;
  };
}, function (t, e, i) { const n = i(12); t.exports = function (t, e) { const i = n(e, 'anims', null); if (i === null) return t; if (typeof i === 'string')t.anims.play(i); else if (typeof i === 'object') { const s = t.anims; const r = n(i, 'key', void 0); const o = n(i, 'startFrame', void 0); const a = n(i, 'delay', 0); const h = n(i, 'repeat', 0); const l = n(i, 'repeatDelay', 0); const u = n(i, 'yoyo', !1); const c = n(i, 'play', !1); const d = n(i, 'delayedPlay', 0); s.setDelay(a), s.setRepeat(h), s.setRepeatDelay(l), s.setYoyo(u), c ? s.play(r, o) : d > 0 ? s.delayedPlay(d, r, o) : s.load(r); } return t; }; }, function (t, e, i) { const n = i(4); const s = i(122); const r = function (t, e, i) { for (var n = [], s = 0; s < t.length; s++) for (let r = 0; r < e.length; r++) for (let o = 0; o < i; o++)n.push({ a: t[s], b: e[r] }); return n; }; t.exports = function (t, e, i) { const o = n(i, 'max', 0); const a = n(i, 'qty', 1); const h = n(i, 'random', !1); const l = n(i, 'randomB', !1); let u = n(i, 'repeat', 0); const c = n(i, 'yoyo', !1); let d = []; if (l && s(e), u === -1) if (o === 0)u = 0; else { let f = t.length * e.length * a; c && (f *= 2), u = Math.ceil(o / f); } for (let p = 0; p <= u; p++) { const g = r(t, e, a); h && s(g), d = d.concat(g), c && (g.reverse(), d = d.concat(g)); } return o && d.splice(o), d; }; }, function (t, e) { var i = function (t, e, r, o, a) { for (r = r || 0, o = o || t.length - 1, a = a || s; o > r;) { if (o - r > 600) { const h = o - r + 1; const l = e - r + 1; const u = Math.log(h); const c = 0.5 * Math.exp(2 * u / 3); const d = 0.5 * Math.sqrt(u * c * (h - c) / h) * (l - h / 2 < 0 ? -1 : 1); const f = Math.max(r, Math.floor(e - l * c / h + d)); const p = Math.min(o, Math.floor(e + (h - l) * c / h + d)); i(t, e, f, p, a); } const g = t[e]; let v = r; let y = o; for (n(t, r, e), a(t[o], g) > 0 && n(t, r, o); v < y;) { for (n(t, v, y), v++, y--; a(t[v], g) < 0;)v++; for (;a(t[y], g) > 0;)y--; }a(t[r], g) === 0 ? n(t, r, y) : n(t, ++y, o), y <= e && (r = y + 1), e <= y && (o = y - 1); } }; function n(t, e, i) { const n = t[e]; t[e] = t[i], t[i] = n; } function s(t, e) { return t < e ? -1 : t > e ? 1 : 0; }t.exports = i; }, function (t, e) { t.exports = function (t) { return t > 0 ? Math.ceil(t) : Math.floor(t); }; }, function (t, e) { t.exports = function (t) { for (var e = t.length, i = t[0].length, n = new Array(i), s = 0; s < i; s++) { n[s] = new Array(e); for (let r = e - 1; r > -1; r--)n[s][r] = t[r][s]; } return n; }; }, function (t, e, i) {
  t.exports = {
    AtlasXML: i(886), Canvas: i(885), Image: i(884), JSONArray: i(883), JSONHash: i(882), SpriteSheet: i(881), SpriteSheetFromAtlas: i(880), UnityYAML: i(879),
  };
}, function (t, e, i) {
  const n = i(24); const s = i(0); const r = i(117); const o = i(94); const a = new s({
    initialize(t, e, i, n) { const s = t.manager.game; this.renderer = s.renderer, this.texture = t, this.source = e, this.image = e, this.compressionAlgorithm = null, this.resolution = 1, this.width = i || e.naturalWidth || e.width || 0, this.height = n || e.naturalHeight || e.height || 0, this.scaleMode = o.DEFAULT, this.isCanvas = e instanceof HTMLCanvasElement, this.isRenderTexture = e.type === 'RenderTexture', this.isPowerOf2 = r(this.width, this.height), this.glTexture = null, this.init(s); }, init(t) { this.renderer && (this.renderer.gl ? this.isCanvas ? this.glTexture = this.renderer.canvasToTexture(this.image) : this.isRenderTexture ? (this.image = this.source.canvas, this.glTexture = this.renderer.createTextureFromSource(null, this.width, this.height, this.scaleMode)) : this.glTexture = this.renderer.createTextureFromSource(this.image, this.width, this.height, this.scaleMode) : this.isRenderTexture && (this.image = this.source.canvas)), t.config.antialias || this.setFilter(1); }, setFilter(t) { this.renderer.gl && this.renderer.setTextureFilter(this.glTexture, t); }, update() { this.renderer.gl && this.isCanvas && (this.glTexture = this.renderer.canvasToTexture(this.image, this.glTexture)); }, destroy() { this.glTexture && this.renderer.deleteTexture(this.glTexture), this.isCanvas && n.remove(this.image), this.renderer = null, this.texture = null, this.source = null, this.image = null, this.glTexture = null; },
  }); t.exports = a;
}, function (t, e, i) {
  const n = i(24); const s = i(887); const r = i(0); const o = i(37); const a = i(26); const h = i(11); const l = i(357); const u = i(4); const c = i(316); const d = i(165); const f = new r({
    Extends: h, initialize(t) { h.call(this), this.game = t, this.name = 'TextureManager', this.list = {}, this._tempCanvas = n.create2D(this, 1, 1), this._tempContext = this._tempCanvas.getContext('2d'), this._pending = 0, t.events.once('boot', this.boot, this); }, boot() { this._pending = 2, this.on('onload', this.updatePending, this), this.on('onerror', this.updatePending, this), this.addBase64('__DEFAULT', this.game.config.defaultImage), this.addBase64('__MISSING', this.game.config.missingImage), this.game.events.once('destroy', this.destroy, this); }, updatePending() { this._pending--, this._pending === 0 && (this.off('onload'), this.off('onerror'), this.game.events.emit('texturesready')); }, checkKey(t) { return !this.exists(t) || (console.error(`Texture key already in use: ${t}`), !1); }, remove(t) { if (typeof t === 'string') { if (!this.exists(t)) return console.warn(`No texture found matching key: ${t}`), this; t = this.get(t); } return this.list.hasOwnProperty(t.key) && (delete this.list[t.key], t.destroy(), this.emit('removetexture', t.key)), this; }, addBase64(t, e) { if (this.checkKey(t)) { const i = this; const n = new Image(); n.onerror = function () { i.emit('onerror', t); }, n.onload = function () { const e = i.create(t, n); c.Image(e, 0), i.emit('addtexture', t, e), i.emit('onload', t, e); }, n.src = e; } return this; }, getBase64(t, e, i, s) { void 0 === i && (i = 'image/png'), void 0 === s && (s = 0.92); let r = ''; const o = this.getFrame(t, e); if (o) { const a = o.canvasData; const h = n.create2D(this, a.width, a.height); h.getContext('2d').drawImage(o.source.image, a.x, a.y, a.width, a.height, 0, 0, a.width, a.height), r = h.toDataURL(i, s), n.remove(h); } return r; }, addImage(t, e, i) { let n = null; return this.checkKey(t) && (n = this.create(t, e), c.Image(n, 0), i && n.setDataSource(i), this.emit('addtexture', t, n)), n; }, addRenderTexture(t, e) { let i = null; return this.checkKey(t) && ((i = this.create(t, e)).add('__BASE', 0, 0, 0, e.width, e.height), this.emit('addtexture', t, i)), i; }, generate(t, e) { if (this.checkKey(t)) { const i = n.create(this, 1, 1); return e.canvas = i, l(e), this.addCanvas(t, i); } return null; }, createCanvas(t, e, i) { if (void 0 === e && (e = 256), void 0 === i && (i = 256), this.checkKey(t)) { const s = n.create(this, e, i, a.CANVAS, !0); return this.addCanvas(t, s); } return null; }, addCanvas(t, e, i) { void 0 === i && (i = !1); let n = null; return i ? n = new s(this, t, e, e.width, e.height) : this.checkKey(t) && (n = new s(this, t, e, e.width, e.height), this.list[t] = n, this.emit('addtexture', t, n)), n; }, addAtlas(t, e, i, n) { return Array.isArray(i.textures) || Array.isArray(i.frames) ? this.addAtlasJSONArray(t, e, i, n) : this.addAtlasJSONHash(t, e, i, n); }, addAtlasJSONArray(t, e, i, n) { let s = null; if (this.checkKey(t)) { if (s = this.create(t, e), Array.isArray(i)) for (let r = i.length === 1, o = 0; o < s.source.length; o++) { const a = r ? i[0] : i[o]; c.JSONArray(s, o, a); } else c.JSONArray(s, 0, i); n && s.setDataSource(n), this.emit('addtexture', t, s); } return s; }, addAtlasJSONHash(t, e, i, n) { let s = null; if (this.checkKey(t)) { if (s = this.create(t, e), Array.isArray(i)) for (let r = 0; r < i.length; r++)c.JSONHash(s, r, i[r]); else c.JSONHash(s, 0, i); n && s.setDataSource(n), this.emit('addtexture', t, s); } return s; }, addAtlasXML(t, e, i, n) { let s = null; return this.checkKey(t) && (s = this.create(t, e), c.AtlasXML(s, 0, i), n && s.setDataSource(n), this.emit('addtexture', t, s)), s; }, addUnityAtlas(t, e, i, n) { let s = null; return this.checkKey(t) && (s = this.create(t, e), c.UnityYAML(s, 0, i), n && s.setDataSource(n), this.emit('addtexture', t, s)), s; }, addSpriteSheet(t, e, i) { let n = null; if (this.checkKey(t)) { const s = (n = this.create(t, e)).source[0].width; const r = n.source[0].height; c.SpriteSheet(n, 0, 0, 0, s, r, i), this.emit('addtexture', t, n); } return n; }, addSpriteSheetFromAtlas(t, e) { if (!this.checkKey(t)) return null; const i = u(e, 'atlas', null); const n = u(e, 'frame', null); if (i && n) { const s = this.get(i).get(n); if (s) { const r = this.create(t, s.source.image); return s.trimmed ? c.SpriteSheetFromAtlas(r, s, e) : c.SpriteSheet(r, 0, s.cutX, s.cutY, s.cutWidth, s.cutHeight, e), this.emit('addtexture', t, r), r; } } }, create(t, e, i, n) { let s = null; return this.checkKey(t) && (s = new d(this, t, e, i, n), this.list[t] = s), s; }, exists(t) { return this.list.hasOwnProperty(t); }, get(t) { return void 0 === t && (t = '__DEFAULT'), this.list[t] ? this.list[t] : this.list.__MISSING; }, cloneFrame(t, e) { if (this.list[t]) return this.list[t].get(e).clone(); }, getFrame(t, e) { if (this.list[t]) return this.list[t].get(e); }, getTextureKeys() { const t = []; for (const e in this.list)e !== '__DEFAULT' && e !== '__MISSING' && t.push(e); return t; }, getPixel(t, e, i, n) { const s = this.getFrame(i, n); if (s) { t -= s.x, e -= s.y; const r = s.data.cut; if (t += r.x, e += r.y, t >= r.x && t < r.r && e >= r.y && e < r.b) { const a = this._tempContext; a.clearRect(0, 0, 1, 1), a.drawImage(s.source.image, t, e, 1, 1, 0, 0, 1, 1); const h = a.getImageData(0, 0, 1, 1); return new o(h.data[0], h.data[1], h.data[2], h.data[3]); } } return null; }, getPixelAlpha(t, e, i, n) { const s = this.getFrame(i, n); if (s) { t -= s.x, e -= s.y; const r = s.data.cut; if (t += r.x, e += r.y, t >= r.x && t < r.r && e >= r.y && e < r.b) { const o = this._tempContext; return o.clearRect(0, 0, 1, 1), o.drawImage(s.source.image, t, e, 1, 1, 0, 0, 1, 1), o.getImageData(0, 0, 1, 1).data[3]; } } return null; }, setTexture(t, e, i) { return this.list[e] && (t.texture = this.list[e], t.frame = t.texture.get(i)), t; }, renameTexture(t, e) { const i = this.get(t); return !(!i || t === e) && (i.key = e, this.list[e] = i, delete this.list[t], !0); }, each(t, e) { for (var i = [null], n = 1; n < arguments.length; n++)i.push(arguments[n]); for (const s in this.list)i[0] = this.list[s], t.apply(e, i); }, destroy() { for (const t in this.list) this.list[t].destroy(); this.list = {}, this.game = null, n.remove(this._tempCanvas); },
  }); t.exports = f;
}, function (t, e, i) {
  const n = i(114); const s = new (i(0))({
    Extends: n, initialize(t, e, i) { void 0 === i && (i = {}), this.audioBuffer = t.game.cache.audio.get(e), this.audioBuffer ? (this.source = null, this.loopSource = null, this.muteNode = t.context.createGain(), this.volumeNode = t.context.createGain(), this.playTime = 0, this.startTime = 0, this.loopTime = 0, this.rateUpdates = [], this.hasEnded = !1, this.hasLooped = !1, this.muteNode.connect(this.volumeNode), this.volumeNode.connect(t.destination), this.duration = this.audioBuffer.duration, this.totalDuration = this.audioBuffer.duration, n.call(this, t, e, i)) : console.warn(`Audio cache entry missing: ${e}`); }, play(t, e) { return !!n.prototype.play.call(this, t, e) && (this.stopAndRemoveBufferSource(), this.createAndStartBufferSource(), this.emit('play', this), !0); }, pause() { return !(this.manager.context.currentTime < this.startTime) && (!!n.prototype.pause.call(this) && (this.currentConfig.seek = this.getCurrentTime(), this.stopAndRemoveBufferSource(), this.emit('pause', this), !0)); }, resume() { return !(this.manager.context.currentTime < this.startTime) && (!!n.prototype.resume.call(this) && (this.createAndStartBufferSource(), this.emit('resume', this), !0)); }, stop() { return !!n.prototype.stop.call(this) && (this.stopAndRemoveBufferSource(), this.emit('stop', this), !0); }, createAndStartBufferSource() { const t = this.currentConfig.seek; const e = this.currentConfig.delay; const i = this.manager.context.currentTime + e; const n = (this.currentMarker ? this.currentMarker.start : 0) + t; const s = this.duration - t; this.playTime = i - t, this.startTime = i, this.source = this.createBufferSource(), this.applyConfig(), this.source.start(Math.max(0, i), Math.max(0, n), Math.max(0, s)), this.resetConfig(); }, createAndStartLoopBufferSource() { const t = this.getLoopTime(); const e = this.currentMarker ? this.currentMarker.start : 0; const i = this.duration; this.loopTime = t, this.loopSource = this.createBufferSource(), this.loopSource.playbackRate.setValueAtTime(this.totalRate, 0), this.loopSource.start(Math.max(0, t), Math.max(0, e), Math.max(0, i)); }, createBufferSource() { const t = this; const e = this.manager.context.createBufferSource(); return e.buffer = this.audioBuffer, e.connect(this.muteNode), e.onended = function (e) { e.target === t.source && (t.currentConfig.loop ? t.hasLooped = !0 : t.hasEnded = !0); }, e; }, stopAndRemoveBufferSource() { this.source && (this.source.stop(), this.source.disconnect(), this.source = null), this.playTime = 0, this.startTime = 0, this.stopAndRemoveLoopBufferSource(); }, stopAndRemoveLoopBufferSource() { this.loopSource && (this.loopSource.stop(), this.loopSource.disconnect(), this.loopSource = null), this.loopTime = 0; }, applyConfig() { this.rateUpdates.length = 0, this.rateUpdates.push({ time: 0, rate: 1 }), n.prototype.applyConfig.call(this); }, update(t, e) { this.hasEnded ? (this.hasEnded = !1, n.prototype.stop.call(this), this.stopAndRemoveBufferSource(), this.emit('ended', this)) : this.hasLooped && (this.hasLooped = !1, this.source = this.loopSource, this.loopSource = null, this.playTime = this.startTime = this.loopTime, this.rateUpdates.length = 0, this.rateUpdates.push({ time: 0, rate: this.totalRate }), this.createAndStartLoopBufferSource(), this.emit('looped', this)); }, destroy() { n.prototype.destroy.call(this), this.audioBuffer = null, this.stopAndRemoveBufferSource(), this.muteNode.disconnect(), this.muteNode = null, this.volumeNode.disconnect(), this.volumeNode = null, this.rateUpdates.length = 0, this.rateUpdates = null; }, calculateRate() { n.prototype.calculateRate.call(this); const t = this.manager.context.currentTime; this.source && typeof this.totalRate === 'number' && this.source.playbackRate.setValueAtTime(this.totalRate, t), this.isPlaying && (this.rateUpdates.push({ time: Math.max(this.startTime, t) - this.playTime, rate: this.totalRate }), this.loopSource && (this.stopAndRemoveLoopBufferSource(), this.createAndStartLoopBufferSource())); }, getCurrentTime() { for (var t = 0, e = 0; e < this.rateUpdates.length; e++) { t += ((e < this.rateUpdates.length - 1 ? this.rateUpdates[e + 1].time : this.manager.context.currentTime - this.playTime) - this.rateUpdates[e].time) * this.rateUpdates[e].rate; } return t; }, getLoopTime() { for (var t = 0, e = 0; e < this.rateUpdates.length - 1; e++)t += (this.rateUpdates[e + 1].time - this.rateUpdates[e].time) * this.rateUpdates[e].rate; const i = this.rateUpdates[this.rateUpdates.length - 1]; return this.playTime + i.time + (this.duration - t) / i.rate; }, rate: { get() { return this.currentConfig.rate; }, set(t) { this.currentConfig.rate = t, this.calculateRate(), this.emit('rate', this, t); } }, setRate(t) { return this.rate = t, this; }, detune: { get() { return this.currentConfig.detune; }, set(t) { this.currentConfig.detune = t, this.calculateRate(), this.emit('detune', this, t); } }, setDetune(t) { return this.detune = t, this; }, mute: { get() { return this.muteNode.gain.value === 0; }, set(t) { this.currentConfig.mute = t, this.muteNode.gain.setValueAtTime(t ? 0 : 1, 0), this.emit('mute', this, t); } }, setMute(t) { return this.mute = t, this; }, volume: { get() { return this.volumeNode.gain.value; }, set(t) { this.currentConfig.volume = t, this.volumeNode.gain.setValueAtTime(t, 0), this.emit('volume', this, t); } }, setVolume(t) { return this.volume = t, this; }, seek: { get() { return this.isPlaying ? this.manager.context.currentTime < this.startTime ? this.startTime - this.playTime : this.getCurrentTime() : this.isPaused ? this.currentConfig.seek : 0; }, set(t) { this.manager.context.currentTime < this.startTime || (this.isPlaying || this.isPaused) && (t = Math.min(Math.max(0, t), this.duration), this.currentConfig.seek = t, this.isPlaying && (this.stopAndRemoveBufferSource(), this.createAndStartBufferSource()), this.emit('seek', this, t)); } }, setSeek(t) { return this.seek = t, this; }, loop: { get() { return this.currentConfig.loop; }, set(t) { this.currentConfig.loop = t, this.isPlaying && (this.stopAndRemoveLoopBufferSource(), t && this.createAndStartLoopBufferSource()), this.emit('loop', this, t); } }, setLoop(t) { return this.loop = t, this; },
  }); t.exports = s;
}, function (t, e, i) {
  const n = i(115); const s = i(0); const r = i(319); const o = new s({
    Extends: n, initialize(t) { this.context = this.createAudioContext(t), this.masterMuteNode = this.context.createGain(), this.masterVolumeNode = this.context.createGain(), this.masterMuteNode.connect(this.masterVolumeNode), this.masterVolumeNode.connect(this.context.destination), this.destination = this.masterMuteNode, this.locked = this.context.state === 'suspended' && ('ontouchstart' in window || 'onclick' in window), n.call(this, t), this.locked && this.unlock(); }, createAudioContext(t) { const e = t.config.audio; return e && e.context ? (e.context.resume(), e.context) : new AudioContext(); }, add(t, e) { const i = new r(this, t, e); return this.sounds.push(i), i; }, unlock() { const t = this; var e = function () { t.context.resume().then(() => { document.body.removeEventListener('touchstart', e), document.body.removeEventListener('touchend', e), document.body.removeEventListener('click', e), t.unlocked = !0; }); }; document.body && (document.body.addEventListener('touchstart', e, !1), document.body.addEventListener('touchend', e, !1), document.body.addEventListener('click', e, !1)); }, onBlur() { this.context.suspend(); }, onFocus() { this.context.resume(); }, destroy() { if (this.destination = null, this.masterVolumeNode.disconnect(), this.masterVolumeNode = null, this.masterMuteNode.disconnect(), this.masterMuteNode = null, this.game.config.audio && this.game.config.audio.context) this.context.suspend(); else { const t = this; this.context.close().then(() => { t.context = null; }); }n.prototype.destroy.call(this); }, setMute(t) { return this.mute = t, this; }, mute: { get() { return this.masterMuteNode.gain.value === 0; }, set(t) { this.masterMuteNode.gain.setValueAtTime(t ? 0 : 1, 0), this.emit('mute', this, t); } }, setVolume(t) { return this.volume = t, this; }, volume: { get() { return this.masterVolumeNode.gain.value; }, set(t) { this.masterVolumeNode.gain.setValueAtTime(t, 0), this.emit('volume', this, t); } },
  }); t.exports = o;
}, function (t, e, i) {
  const n = i(114); const s = i(0); const r = i(11); const o = i(20); const a = new s({
    Extends: r,
    initialize(t, e, i) {
      void 0 === i && (i = {}), r.call(this), this.manager = t, this.key = e, this.isPlaying = !1, this.isPaused = !1, this.totalRate = 1, this.duration = 0, this.totalDuration = 0, this.config = o({
        mute: !1, volume: 1, rate: 1, detune: 0, seek: 0, loop: !1, delay: 0,
      }, i), this.currentConfig = this.config, this.mute = !1, this.volume = 1, this.rate = 1, this.detune = 0, this.seek = 0, this.loop = !1, this.markers = {}, this.currentMarker = null, this.pendingRemove = !1;
    },
    addMarker(t) { return !1; },
    updateMarker(t) { return !1; },
    removeMarker(t) { return null; },
    play(t, e) { return !1; },
    pause() { return !1; },
    resume() { return !1; },
    stop() { return !1; },
    destroy() { this.manager.remove(this), n.prototype.destroy.call(this); },
  }); t.exports = a;
}, function (t, e, i) {
  const n = i(115); const s = i(0); const r = i(11); const o = i(321); const a = i(1); const h = new s({
    Extends: r, initialize(t) { r.call(this), this.game = t, this.sounds = [], this.mute = !1, this.volume = 1, this.rate = 1, this.detune = 0, this.pauseOnBlur = !0, this.locked = !1; }, add(t, e) { const i = new o(this, t, e); return this.sounds.push(i), i; }, addAudioSprite(t, e) { const i = this.add(t, e); return i.spritemap = {}, i; }, play(t, e) { return !1; }, playAudioSprite(t, e, i) { return !1; }, remove(t) { return n.prototype.remove.call(this, t); }, removeByKey(t) { return n.prototype.removeByKey.call(this, t); }, pauseAll: a, resumeAll: a, stopAll: a, update: a, setRate: a, setDetune: a, setMute: a, setVolume: a, forEachActiveSound(t, e) { n.prototype.forEachActiveSound.call(this, t, e); }, destroy() { n.prototype.destroy.call(this); },
  }); t.exports = h;
}, function (t, e, i) {
  const n = i(114); const s = new (i(0))({
    Extends: n, initialize(t, e, i) { void 0 === i && (i = {}), this.tags = t.game.cache.audio.get(e), this.tags ? (this.audio = null, this.startTime = 0, this.previousTime = 0, this.duration = this.tags[0].duration, this.totalDuration = this.tags[0].duration, n.call(this, t, e, i)) : console.warn(`Audio cache entry missing: ${e}`); }, play(t, e) { return !this.manager.isLocked(this, 'play', [t, e]) && (!!n.prototype.play.call(this, t, e) && (!!this.pickAndPlayAudioTag() && (this.emit('play', this), !0))); }, pause() { return !this.manager.isLocked(this, 'pause') && (!(this.startTime > 0) && (!!n.prototype.pause.call(this) && (this.currentConfig.seek = this.audio.currentTime - (this.currentMarker ? this.currentMarker.start : 0), this.stopAndReleaseAudioTag(), this.emit('pause', this), !0))); }, resume() { return !this.manager.isLocked(this, 'resume') && (!(this.startTime > 0) && (!!n.prototype.resume.call(this) && (!!this.pickAndPlayAudioTag() && (this.emit('resume', this), !0)))); }, stop() { return !this.manager.isLocked(this, 'stop') && (!!n.prototype.stop.call(this) && (this.stopAndReleaseAudioTag(), this.emit('stop', this), !0)); }, pickAndPlayAudioTag() { if (!this.pickAudioTag()) return this.reset(), !1; const t = this.currentConfig.seek; const e = this.currentConfig.delay; const i = (this.currentMarker ? this.currentMarker.start : 0) + t; return this.previousTime = i, this.audio.currentTime = i, this.applyConfig(), e === 0 ? (this.startTime = 0, this.audio.paused && this.playCatchPromise()) : (this.startTime = window.performance.now() + 1e3 * e, this.audio.paused || this.audio.pause()), this.resetConfig(), !0; }, pickAudioTag() { if (this.audio) return !0; for (let t = 0; t < this.tags.length; t++) { const e = this.tags[t]; if (e.dataset.used === 'false') return e.dataset.used = 'true', this.audio = e, !0; } if (!this.manager.override) return !1; const i = []; this.manager.forEachActiveSound(function (t) { t.key === this.key && t.audio && i.push(t); }, this), i.sort((t, e) => (t.loop === e.loop ? e.seek / e.duration - t.seek / t.duration : t.loop ? 1 : -1)); const n = i[0]; return this.audio = n.audio, n.reset(), n.audio = null, n.startTime = 0, n.previousTime = 0, !0; }, playCatchPromise() { const t = this.audio.play(); t && t.catch((t) => { console.warn(t); }); }, stopAndReleaseAudioTag() { this.audio.pause(), this.audio.dataset.used = 'false', this.audio = null, this.startTime = 0, this.previousTime = 0; }, reset() { n.prototype.stop.call(this); }, onBlur() { this.isPlaying = !1, this.isPaused = !0, this.currentConfig.seek = this.audio.currentTime - (this.currentMarker ? this.currentMarker.start : 0), this.currentConfig.delay = Math.max(0, (this.startTime - window.performance.now()) / 1e3), this.stopAndReleaseAudioTag(); }, onFocus() { this.isPlaying = !0, this.isPaused = !1, this.pickAndPlayAudioTag(); }, update(t, e) { if (this.isPlaying) if (this.startTime > 0) this.startTime < t - this.manager.audioPlayDelay && (this.audio.currentTime += Math.max(0, t - this.startTime) / 1e3, this.startTime = 0, this.previousTime = this.audio.currentTime, this.playCatchPromise()); else { const i = this.currentMarker ? this.currentMarker.start : 0; const n = i + this.duration; let s = this.audio.currentTime; if (this.currentConfig.loop)s >= n - this.manager.loopEndOffset ? (this.audio.currentTime = i + Math.max(0, s - n), s = this.audio.currentTime) : s < i && (this.audio.currentTime += i, s = this.audio.currentTime), s < this.previousTime && this.emit('looped', this); else if (s >= n) return this.reset(), this.stopAndReleaseAudioTag(), void this.emit('ended', this); this.previousTime = s; } }, destroy() { n.prototype.destroy.call(this), this.tags = null, this.audio && this.stopAndReleaseAudioTag(); }, updateMute() { this.audio && (this.audio.muted = this.currentConfig.mute || this.manager.mute); }, updateVolume() { this.audio && (this.audio.volume = this.currentConfig.volume * this.manager.volume); }, calculateRate() { n.prototype.calculateRate.call(this), this.audio && (this.audio.playbackRate = this.totalRate); }, mute: { get() { return this.currentConfig.mute; }, set(t) { this.currentConfig.mute = t, this.manager.isLocked(this, 'mute', t) || this.emit('mute', this, t); } }, setMute(t) { return this.mute = t, this; }, volume: { get() { return this.currentConfig.volume; }, set(t) { this.currentConfig.volume = t, this.manager.isLocked(this, 'volume', t) || this.emit('volume', this, t); } }, setVolume(t) { return this.volume = t, this; }, rate: { get() { return this.currentConfig.rate; }, set(t) { this.currentConfig.rate = t, this.manager.isLocked(this, 'rate', t) || (this.calculateRate(), this.emit('rate', this, t)); } }, setRate(t) { return this.rate = t, this; }, detune: { get() { return this.currentConfig.detune; }, set(t) { this.currentConfig.detune = t, this.manager.isLocked(this, 'detune', t) || (this.calculateRate(), this.emit('detune', this, t)); } }, setDetune(t) { return this.detune = t, this; }, seek: { get() { return this.isPlaying ? this.audio.currentTime - (this.currentMarker ? this.currentMarker.start : 0) : this.isPaused ? this.currentConfig.seek : 0; }, set(t) { this.manager.isLocked(this, 'seek', t) || this.startTime > 0 || (this.isPlaying || this.isPaused) && (t = Math.min(Math.max(0, t), this.duration), this.isPlaying ? (this.previousTime = t, this.audio.currentTime = t) : this.isPaused && (this.currentConfig.seek = t), this.emit('seek', this, t)); } }, setSeek(t) { return this.seek = t, this; }, loop: { get() { return this.currentConfig.loop; }, set(t) { this.currentConfig.loop = t, this.manager.isLocked(this, 'loop', t) || (this.audio && (this.audio.loop = t), this.emit('loop', this, t)); } }, setLoop(t) { return this.loop = t, this; },
  }); t.exports = s;
}, function (t, e, i) {
  const n = i(115); const s = i(0); const r = i(323); const o = new s({
    Extends: n, initialize(t) { this.override = !0, this.audioPlayDelay = 0.1, this.loopEndOffset = 0.05, this.onBlurPausedSounds = [], this.locked = 'ontouchstart' in window, this.lockedActionsQueue = this.locked ? [] : null, this._mute = !1, this._volume = 1, n.call(this, t); }, add(t, e) { const i = new r(this, t, e); return this.sounds.push(i), i; }, unlock() { this.locked = !1; const t = this; if (this.game.cache.audio.entries.each((e, i) => { for (let n = 0; n < i.length; n++) if (i[n].dataset.locked === 'true') return t.locked = !0, !1; return !0; }), this.locked) { let e = !1; const i = function () { e = !0; }; var n = function () { if (e)e = !1; else { document.body.removeEventListener('touchmove', i), document.body.removeEventListener('touchend', n); const s = []; if (t.game.cache.audio.entries.each((t, e) => { for (let i = 0; i < e.length; i++) { const n = e[i]; n.dataset.locked === 'true' && s.push(n); } return !0; }), s.length !== 0) { const r = s[s.length - 1]; r.oncanplaythrough = function () { r.oncanplaythrough = null, s.forEach((t) => { t.dataset.locked = 'false'; }), t.unlocked = !0; }, s.forEach((t) => { t.load(); }); } } }; this.once('unlocked', function () { for (this.forEachActiveSound((t) => { t.currentMarker === null && t.duration === 0 && (t.duration = t.tags[0].duration), t.totalDuration = t.tags[0].duration; }); this.lockedActionsQueue.length;) { const t = this.lockedActionsQueue.shift(); t.sound[t.prop].apply ? t.sound[t.prop].apply(t.sound, t.value || []) : t.sound[t.prop] = t.value; } }, this), document.body.addEventListener('touchmove', i, !1), document.body.addEventListener('touchend', n, !1); } }, onBlur() { this.forEachActiveSound(function (t) { t.isPlaying && (this.onBlurPausedSounds.push(t), t.onBlur()); }); }, onFocus() { this.onBlurPausedSounds.forEach((t) => { t.onFocus(); }), this.onBlurPausedSounds.length = 0; }, destroy() { n.prototype.destroy.call(this), this.onBlurPausedSounds.length = 0, this.onBlurPausedSounds = null; }, isLocked(t, e, i) { return t.tags[0].dataset.locked === 'true' && (this.lockedActionsQueue.push({ sound: t, prop: e, value: i }), !0); }, setMute(t) { return this.mute = t, this; }, mute: { get() { return this._mute; }, set(t) { this._mute = t, this.forEachActiveSound((t) => { t.updateMute(); }), this.emit('mute', this, t); } }, setVolume(t) { return this.volume = t, this; }, volume: { get() { return this._volume; }, set(t) { this._volume = t, this.forEachActiveSound((t) => { t.updateVolume(); }), this.emit('volume', this, t); } },
  }); t.exports = o;
}, function (t, e, i) { const n = i(324); const s = i(322); const r = i(320); const o = { create(t) { const e = t.config.audio; const i = t.device.audio; return e && e.noAudio || !i.webAudio && !i.audioData ? new s(t) : !i.webAudio || e && e.disableWebAudio ? new n(t) : new r(t); } }; t.exports = o; }, function (t, e, i) {
  const n = i(116); const s = i(4); const r = i(96); const o = i(888); const a = {
    create(t) {
      return typeof t === 'string' ? t = { key: t } : void 0 === t && (t = {}), {
        status: n.PENDING, key: s(t, 'key', ''), active: s(t, 'active', !1), visible: s(t, 'visible', !0), isBooted: !1, isTransition: !1, transitionFrom: null, transitionDuration: 0, transitionAllowInput: !0, data: {}, pack: s(t, 'pack', !1), cameras: s(t, 'cameras', null), map: s(t, 'map', r(o, s(t, 'mapAdd', {}))), physics: s(t, 'physics', {}), loader: s(t, 'loader', {}), plugins: s(t, 'plugins', !1), input: s(t, 'input', {}),
      };
    },
  }; t.exports = a;
}, function (t, e) { t.exports = function (t) { return t && t[0].toUpperCase() + t.slice(1); }; }, function (t, e, i) { const n = i(0); const s = i(166); const r = new n({ initialize(t) { this.sys = new s(this, t), this.game, this.anims, this.cache, this.registry, this.sound, this.textures, this.events, this.cameras, this.add, this.make, this.scene, this.children, this.lights, this.data, this.input, this.load, this.time, this.tweens, this.physics, this.impact, this.matter; }, update() {} }); t.exports = r; }, function (t, e, i) {
  const n = i(0); const s = i(116); const r = i(4); const o = i(1); const a = i(328); const h = i(166); const l = new n({
    initialize(t, e) {
      if (this.game = t, this.keys = {}, this.scenes = [], this._pending = [], this._start = [], this._queue = [], this._data = {}, this.isProcessing = !1, this.isBooted = !1, this.customViewports = 0, e) {
        Array.isArray(e) || (e = [e]); for (let i = 0; i < e.length; i++) {
          this._pending.push({
            key: 'default', scene: e[i], autoStart: i === 0, data: {},
          });
        }
      }t.events.once('ready', this.bootQueue, this);
    },
    bootQueue() { if (!this.isBooted) { let t; let e; let i; let n; for (t = 0; t < this._pending.length; t++) { var s; i = (e = this._pending[t]).key, (n = e.scene) instanceof a ? s = this.createSceneFromInstance(i, n) : typeof n === 'object' ? s = this.createSceneFromObject(i, n) : typeof n === 'function' && (s = this.createSceneFromFunction(i, n)), i = s.sys.settings.key, this.keys[i] = s, this.scenes.push(s), this._data[i] && (s.sys.settings.data = this._data[i].data, this._data[i].autoStart && (e.autoStart = !0)), (e.autoStart || s.sys.settings.active) && this._start.push(i); } for (this._pending.length = 0, this._data = {}, this.isBooted = !0, t = 0; t < this._start.length; t++)e = this._start[t], this.start(e); this._start.length = 0; } },
    processQueue() { const t = this._pending.length; const e = this._queue.length; if (t !== 0 || e !== 0) { let i; let n; if (t) { for (i = 0; i < t; i++)n = this._pending[i], this.add(n.key, n.scene, n.autoStart, n.data); for (i = 0; i < this._start.length; i++)n = this._start[i], this.start(n); return this._start.length = 0, void (this._pending.length = 0); } for (i = 0; i < this._queue.length; i++) this[(n = this._queue[i]).op](n.keyA, n.keyB); this._queue.length = 0; } },
    add(t, e, i, n) {
      return void 0 === i && (i = !1), void 0 === n && (n = {}), this.isProcessing || !this.isBooted ? (this._pending.push({
        key: t, scene: e, autoStart: i, data: n,
      }), this.isBooted || (this._data[t] = { data: n }), null) : (t = this.getKey(t, e), e instanceof a ? s = this.createSceneFromInstance(t, e) : typeof e === 'object' ? (e.key = t, s = this.createSceneFromObject(t, e)) : typeof e === 'function' && (s = this.createSceneFromFunction(t, e)), s.sys.settings.data = n, t = s.sys.settings.key, this.keys[t] = s, this.scenes.push(s), (i || s.sys.settings.active) && (this._pending.length ? this._start.push(t) : this.start(t)), s); let s;
    },
    remove(t) { if (this.isProcessing) this._queue.push({ op: 'remove', keyA: t, keyB: null }); else { const e = this.getScene(t); if (!e || e.sys.isTransitioning()) return this; let i = this.scenes.indexOf(e); const n = e.sys.settings.key; i > -1 && (delete this.keys[n], this.scenes.splice(i, 1), this._start.indexOf(n) > -1 && (i = this._start.indexOf(n), this._start.splice(i, 1)), e.sys.destroy()); } return this; },
    bootScene(t) { let e; const i = t.sys; const n = i.settings; t.init && (t.init.call(t, n.data), n.status = s.INIT, n.isTransition && i.events.emit('transitioninit', n.transitionFrom, n.transitionDuration)), i.load && (e = i.load).reset(), e && t.preload ? (t.preload.call(t), e.list.size === 0 ? this.create(t) : (n.status = s.LOADING, e.once('complete', this.loadComplete, this), e.start())) : this.create(t); },
    loadComplete(t) { const e = t.scene; this.game.sound.onBlurPausedSounds && this.game.sound.unlock(), this.create(e); },
    payloadComplete(t) { this.bootScene(t.scene); },
    update(t, e) { this.processQueue(), this.isProcessing = !0; for (let i = this.scenes.length - 1; i >= 0; i--) { const n = this.scenes[i].sys; n.settings.status > s.START && n.settings.status <= s.RUNNING && n.step(t, e); } },
    resize(t, e) { for (let i = 0; i < this.scenes.length; i++) { this.scenes[i].sys.resize(t, e); } },
    render(t) { for (let e = 0; e < this.scenes.length; e++) { const i = this.scenes[e].sys; i.settings.visible && i.settings.status >= s.LOADING && i.settings.status < s.SLEEPING && i.render(t); } this.isProcessing = !1; },
    create(t) { const e = t.sys; const i = e.settings; t.create && (i.status = s.CREATING, t.create.call(t, i.data), i.isTransition && e.events.emit('transitionstart', i.transitionFrom, i.transitionDuration)), t.update && (e.sceneUpdate = t.update), i.status = s.RUNNING; },
    createSceneFromFunction(t, e) { const i = new e(); if (i instanceof a) { const n = i.sys.settings.key; if (n !== '' && (t = n), this.keys.hasOwnProperty(t)) throw new Error(`Cannot add a Scene with duplicate key: ${t}`); return this.createSceneFromInstance(t, i); } return i.sys = new h(i), i.sys.settings.key = t, i.sys.init(this.game), i; },
    createSceneFromInstance(t, e) { const i = e.sys.settings.key; return i !== '' ? t = i : e.sys.settings.key = t, e.sys.init(this.game), e; },
    createSceneFromObject(t, e) { const i = new a(e); const n = i.sys.settings.key; n !== '' ? t = n : i.sys.settings.key = t, i.sys.init(this.game); for (let s = ['init', 'preload', 'create', 'update', 'render'], o = 0; o < s.length; o++) { const h = r(e, s[o], null); h && (i[s[o]] = h); } if (e.hasOwnProperty('extend')) for (const l in e.extend) { const u = e.extend[l]; l === 'data' && i.hasOwnProperty('data') && typeof u === 'object' ? i.data.merge(u) : l !== 'sys' && (i[l] = u); } return i; },
    getKey(t, e) { if (t || (t = 'default'), typeof e === 'function') return t; if (e instanceof a ? t = e.sys.settings.key : typeof e === 'object' && e.hasOwnProperty('key') && (t = e.key), this.keys.hasOwnProperty(t)) throw new Error(`Cannot add a Scene with duplicate key: ${t}`); return t; },
    getScene(t) { if (typeof t === 'string') { if (this.keys[t]) return this.keys[t]; } else for (let e = 0; e < this.scenes.length; e++) if (t === this.scenes[e]) return t; return null; },
    isActive(t) { const e = this.getScene(t); return e ? e.sys.isActive() : null; },
    isVisible(t) { const e = this.getScene(t); return e ? e.sys.isVisible() : null; },
    isSleeping(t) { const e = this.getScene(t); return e ? e.sys.isSleeping() : null; },
    pause(t, e) { const i = this.getScene(t); return i && i.sys.pause(e), this; },
    resume(t, e) { const i = this.getScene(t); return i && i.sys.resume(e), this; },
    sleep(t, e) { const i = this.getScene(t); return i && !i.sys.isTransitioning() && i.sys.sleep(e), this; },
    wake(t, e) { const i = this.getScene(t); return i && i.sys.wake(e), this; },
    run(t, e) { const i = this.getScene(t); if (!i) { for (let n = 0; n < this._pending.length; n++) if (this._pending[n].key === t) { this.queueOp('start', t, e); break; } return this; }i.sys.isSleeping() ? i.sys.wake(e) : i.sys.isBooted && !i.sys.isActive() ? i.sys.resume(e) : this.start(t, e); },
    start(t, e) { if (!this.isBooted) return this._data[t] = { autoStart: !0, data: e }, this; const i = this.getScene(t); if (i) { let n; if (i.sys.isActive() || i.sys.isPaused())i.sys.shutdown(), i.sys.start(e); else if (i.sys.start(e), i.sys.load && (n = i.sys.load), n && i.sys.settings.hasOwnProperty('pack') && (n.reset(), n.addPack({ payload: i.sys.settings.pack }))) return i.sys.settings.status = s.LOADING, n.once('complete', this.payloadComplete, this), n.start(), this; this.bootScene(i); } return this; },
    stop(t) { const e = this.getScene(t); return e && !e.sys.isTransitioning() && e.sys.shutdown(), this; },
    switch(t, e) { const i = this.getScene(t); const n = this.getScene(e); return i && n && i !== n && (this.sleep(t), this.isSleeping(e) ? this.wake(e) : this.start(e)), this; },
    getAt(t) { return this.scenes[t]; },
    getIndex(t) { const e = this.getScene(t); return this.scenes.indexOf(e); },
    bringToTop(t) { if (this.isProcessing) this._queue.push({ op: 'bringToTop', keyA: t, keyB: null }); else { const e = this.getIndex(t); if (e !== -1 && e < this.scenes.length) { const i = this.getScene(t); this.scenes.splice(e, 1), this.scenes.push(i); } } return this; },
    sendToBack(t) { if (this.isProcessing) this._queue.push({ op: 'sendToBack', keyA: t, keyB: null }); else { const e = this.getIndex(t); if (e !== -1 && e > 0) { const i = this.getScene(t); this.scenes.splice(e, 1), this.scenes.unshift(i); } } return this; },
    moveDown(t) { if (this.isProcessing) this._queue.push({ op: 'moveDown', keyA: t, keyB: null }); else { const e = this.getIndex(t); if (e > 0) { const i = e - 1; const n = this.getScene(t); const s = this.getAt(i); this.scenes[e] = s, this.scenes[i] = n; } } return this; },
    moveUp(t) { if (this.isProcessing) this._queue.push({ op: 'moveUp', keyA: t, keyB: null }); else { const e = this.getIndex(t); if (e < this.scenes.length - 1) { const i = e + 1; const n = this.getScene(t); const s = this.getAt(i); this.scenes[e] = s, this.scenes[i] = n; } } return this; },
    moveAbove(t, e) { if (t === e) return this; if (this.isProcessing) this._queue.push({ op: 'moveAbove', keyA: t, keyB: e }); else { const i = this.getIndex(t); const n = this.getIndex(e); if (i !== -1 && n !== -1) { const s = this.getAt(n); this.scenes.splice(n, 1), this.scenes.splice(i + 1, 0, s); } } return this; },
    moveBelow(t, e) { if (t === e) return this; if (this.isProcessing) this._queue.push({ op: 'moveBelow', keyA: t, keyB: e }); else { const i = this.getIndex(t); const n = this.getIndex(e); if (i !== -1 && n !== -1) { const s = this.getAt(n); this.scenes.splice(n, 1), i === 0 ? this.scenes.unshift(s) : this.scenes.splice(i, 0, s); } } return this; },
    queueOp(t, e, i) { return this._queue.push({ op: t, keyA: e, keyB: i }), this; },
    swapPosition(t, e) { if (t === e) return this; if (this.isProcessing) this._queue.push({ op: 'swapPosition', keyA: t, keyB: e }); else { const i = this.getIndex(t); const n = this.getIndex(e); if (i !== n && i !== -1 && n !== -1) { const s = this.getAt(i); this.scenes[i] = this.scenes[n], this.scenes[n] = s; } } return this; },
    dump() { for (var t = [], e = ['pending', 'init', 'start', 'loading', 'creating', 'running', 'paused', 'sleeping', 'shutdown', 'destroyed'], i = 0; i < this.scenes.length; i++) { const n = this.scenes[i].sys; let r = !n.settings.visible || n.settings.status !== s.RUNNING && n.settings.status !== s.PAUSED ? '[-] ' : '[*] '; r += `${n.settings.key} (${e[n.settings.status]})`, t.push(r); }console.log(t.join('\n')); },
    destroy() { for (let t = 0; t < this.scenes.length; t++) { this.scenes[t].sys.destroy(); } this.update = o, this.scenes = [], this._pending = [], this._start = [], this._queue = [], this.game = null; },
  }); t.exports = l;
}, function (t, e, i) { const n = i(91); t.exports = function (t, e, i, s) { let r; if (void 0 === s && (s = t), !Array.isArray(e)) return (r = t.indexOf(e)) !== -1 ? (n(t, r), i && i.call(s, e), e) : null; for (let o = e.length - 1; o >= 0;) { const a = e[o]; (r = t.indexOf(a)) !== -1 ? (n(t, r), i && i.call(s, a)) : e.pop(), o--; } return e; }; }, function (t, e, i) {
  const n = i(0); const s = i(11); const r = i(7); const o = i(13); const a = i(5); const h = i(2); const l = i(15); const u = i(330); const c = new n({
    Extends: s,
    initialize(t) { s.call(this), this.game = t, this.plugins = [], this.scenePlugins = [], this._pendingGlobal = [], this._pendingScene = [], t.isBooted ? this.boot() : t.events.once('boot', this.boot, this); },
    boot() { let t; let e; let i; let n; let s; let r; let o; const a = this.game.config; let l = a.installGlobalPlugins; for (l = l.concat(this._pendingGlobal), t = 0; t < l.length; t++)e = l[t], i = h(e, 'key', null), n = h(e, 'plugin', null), s = h(e, 'start', !1), r = h(e, 'mapping', null), o = h(e, 'data', null), i && n && this.install(i, n, s, r, o); for (l = (l = a.installScenePlugins).concat(this._pendingScene), t = 0; t < l.length; t++)e = l[t], i = h(e, 'key', null), n = h(e, 'plugin', null), r = h(e, 'mapping', null), i && n && this.installScenePlugin(i, n, r); this._pendingGlobal = [], this._pendingScene = [], this.game.events.once('destroy', this.destroy, this); },
    addToScene(t, e, i) { let n; let s; let r; const o = this.game; const a = t.scene; const h = t.settings.map; const u = t.settings.isBooted; for (n = 0; n < e.length; n++)o[s = e[n]] ? (t[s] = o[s], h.hasOwnProperty(s) && (a[h[s]] = t[s])) : s === 'game' && h.hasOwnProperty(s) && (a[h[s]] = o); for (let c = 0; c < i.length; c++) for (r = i[c], n = 0; n < r.length; n++) if (s = r[n], l.hasCore(s)) { const d = l.getCore(s); const f = new d.plugin(a, this); t[d.mapping] = f, d.custom ? a[d.mapping] = f : h.hasOwnProperty(d.mapping) && (a[h[d.mapping]] = f), u && f.boot(); } for (r = this.plugins, n = 0; n < r.length; n++) { const p = r[n]; p.mapping && (a[p.mapping] = p.plugin); } },
    getDefaultScenePlugins() { let t = this.game.config.defaultPlugins; return t = t.concat(this.scenePlugins); },
    installScenePlugin(t, e, i, n) { if (typeof e === 'function') { if (l.hasCore(t))console.warn(`Scene Plugin key in use: ${t}`); else if (l.register(t, e, i, !0), this.scenePlugins.push(t), n) { const s = new e(n, this); n.sys[t] = s, i && i !== '' && (n[i] = s), s.boot(); } } else console.warn(`Invalid Scene Plugin: ${t}`); },
    install(t, e, i, n, s) {
      if (void 0 === i && (i = !1), void 0 === n && (n = null), void 0 === s && (s = null), typeof e === 'function') {
        if (l.hasCustom(t))console.warn(`Plugin key in use: ${t}`); else if (n !== null && (i = !0), this.game.isBooted) { if (l.registerCustom(t, e, n, s), i) return this.start(t); } else {
          this._pendingGlobal.push({
            key: t, plugin: e, start: i, mapping: n, data: s,
          });
        }
      } else console.warn(`Invalid Plugin: ${t}`);
    },
    getIndex(t) { for (let e = this.plugins, i = 0; i < e.length; i++) { if (e[i].key === t) return i; } return -1; },
    getEntry(t) { const e = this.getIndex(t); if (e !== -1) return this.plugins[e]; },
    isActive(t) { const e = this.getEntry(t); return e && e.active; },
    start(t, e) { void 0 === e && (e = t); let i = this.getEntry(e); return i && !i.active ? (i.active = !0, i.plugin.start()) : i || (i = this.createEntry(t, e)), i ? i.plugin : null; },
    createEntry(t, e) {
      let i = l.getCustom(t); if (i) {
        const n = new i.plugin(this); i = {
          key: e, plugin: n, active: !0, mapping: i.mapping, data: i.data,
        }, this.plugins.push(i), n.init(i.data), n.start();
      } return i;
    },
    stop(t) { const e = this.getEntry(t); return e && e.active && (e.active = !1, e.plugin.stop()), this; },
    get(t, e) { void 0 === e && (e = !0); let i = this.getEntry(t); if (i) return i.plugin; const n = this.getClass(t); return n && e ? (i = this.createEntry(t, t)) ? i.plugin : null : n || null; },
    getClass(t) { return l.getCustomClass(t); },
    removeGlobalPlugin(t) { const e = this.getEntry(t); e && u(this.plugins, e), l.removeCustom(t); },
    removeScenePlugin(t) { u(this.scenePlugins, t), l.remove(t); },
    registerGameObject(t, e, i) { return e && a.register(t, e), i && o.register(t, i), this; },
    registerFileType(t, e, i) { r.register(t, e), i && i.sys.load && (i.sys.load[t] = e); },
    destroy() { for (let t = 0; t < this.plugins.length; t++) this.plugins[t].plugin.destroy(); l.destroyCustomPlugins(), this.game.noReturn && l.destroyCorePlugins(), this.game = null, this.plugins = [], this.scenePlugins = []; },
  }); t.exports = c;
}, function (t, e, i) { const n = i(3); t.exports = function (t, e, i, s, r, o, a, h) { void 0 === h && (h = new n()); const l = Math.sin(r); const u = Math.cos(r); const c = u * o; const d = l * o; const f = -l * a; const p = u * a; const g = 1 / (c * p + f * -d); return h.x = p * g * t + -f * g * e + (s * f - i * p) * g, h.y = c * g * e + -d * g * t + (-s * c + i * d) * g, h; }; }, function (t, e, i) {
  const n = i(0); const s = i(1); const r = new n({
    initialize(t) { this.manager = t, this.capture = !0, this.enabled = !1, this.target, this.onTouchStart = s, this.onTouchMove = s, this.onTouchEnd = s, this.onTouchCancel = s, t.events.once('boot', this.boot, this); }, boot() { const t = this.manager.config; this.enabled = t.inputTouch, this.target = t.inputTouchEventTarget, this.capture = t.inputTouchCapture, this.target || (this.target = this.manager.game.canvas), this.enabled && this.target && this.startListeners(); }, startListeners() { const t = this; this.onTouchStart = function (e) { !e.defaultPrevented && t.enabled && t.manager && (t.manager.queueTouchStart(e), t.capture && e.preventDefault()); }, this.onTouchMove = function (e) { !e.defaultPrevented && t.enabled && t.manager && (t.manager.queueTouchMove(e), t.capture && e.preventDefault()); }, this.onTouchEnd = function (e) { !e.defaultPrevented && t.enabled && t.manager && (t.manager.queueTouchEnd(e), t.capture && e.preventDefault()); }, this.onTouchCancel = function (e) { !e.defaultPrevented && t.enabled && t.manager && (t.manager.queueTouchCancel(e), t.capture && e.preventDefault()); }; const e = this.target; if (e) { const i = { passive: !0 }; const n = { passive: !1 }; this.capture ? (e.addEventListener('touchstart', this.onTouchStart, n), e.addEventListener('touchmove', this.onTouchMove, n), e.addEventListener('touchend', this.onTouchEnd, n), e.addEventListener('touchcancel', this.onTouchCancel, n)) : (e.addEventListener('touchstart', this.onTouchStart, i), e.addEventListener('touchmove', this.onTouchMove, i), e.addEventListener('touchend', this.onTouchEnd, i)), this.enabled = !0; } }, stopListeners() { const t = this.target; t.removeEventListener('touchstart', this.onTouchStart), t.removeEventListener('touchmove', this.onTouchMove), t.removeEventListener('touchend', this.onTouchEnd), t.removeEventListener('touchcancel', this.onTouchCancel); }, destroy() { this.stopListeners(), this.target = null, this.enabled = !1, this.manager = null; },
  }); t.exports = r;
}, function (t, e, i) { const n = i(181); t.exports = function (t, e, i) { return e + (i - e) * n(t, 0, 1); }; }, function (t, e, i) {
  const n = i(0); const s = i(52); const r = i(334); const o = i(3); const a = new n({
    initialize(t, e) { this.manager = t, this.id = e, this.event, this.camera = null, this.buttons = 0, this.position = new o(), this.prevPosition = new o(), this.worldX = 0, this.worldY = 0, this.downX = 0, this.downY = 0, this.downTime = 0, this.upX = 0, this.upY = 0, this.upTime = 0, this.primaryDown = !1, this.dragState = 0, this.isDown = !1, this.dirty = !1, this.justDown = !1, this.justUp = !1, this.justMoved = !1, this.wasTouch = !1, this.wasCanceled = !1, this.movementX = 0, this.movementY = 0, this.identifier = 0, this.pointerId = null, this.active = e === 0; }, positionToCamera(t, e) { return t.getWorldPoint(this.x, this.y, e); }, reset() { this.dirty = !1, this.justDown = !1, this.justUp = !1, this.justMoved = !1, this.movementX = 0, this.movementY = 0; }, up(t, e) { t.buttons && (this.buttons = t.buttons), this.event = t, this.manager.transformPointer(this, t.pageX, t.pageY), t.button === 0 && (this.primaryDown = !1, this.upX = this.x, this.upY = this.y, this.upTime = e), this.justUp = !0, this.isDown = !1, this.dirty = !0, this.wasTouch = !1; }, down(t, e) { t.buttons && (this.buttons = t.buttons), this.event = t, this.manager.transformPointer(this, t.pageX, t.pageY), t.button === 0 && (this.primaryDown = !0, this.downX = this.x, this.downY = this.y, this.downTime = e), this.justDown = !0, this.isDown = !0, this.dirty = !0, this.wasTouch = !1; }, move(t) { t.buttons && (this.buttons = t.buttons), this.event = t, this.manager.transformPointer(this, t.pageX, t.pageY), this.manager.mouse.locked && (this.movementX += t.movementX || t.mozMovementX || t.webkitMovementX || 0, this.movementY += t.movementY || t.mozMovementY || t.webkitMovementY || 0), this.justMoved = !0, this.dirty = !0, this.wasTouch = !1; }, touchstart(t, e) { t.pointerId && (this.pointerId = t.pointerId), this.identifier = t.identifier, this.target = t.target, this.active = !0, this.buttons = 1, this.event = t, this.manager.transformPointer(this, t.pageX, t.pageY), this.primaryDown = !0, this.downX = this.x, this.downY = this.y, this.downTime = e, this.justDown = !0, this.isDown = !0, this.dirty = !0, this.wasTouch = !0, this.wasCanceled = !1; }, touchmove(t) { this.event = t, this.manager.transformPointer(this, t.pageX, t.pageY), this.justMoved = !0, this.dirty = !0, this.wasTouch = !0; }, touchend(t, e) { this.buttons = 0, this.event = t, this.manager.transformPointer(this, t.pageX, t.pageY), this.primaryDown = !1, this.upX = this.x, this.upY = this.y, this.upTime = e, this.justUp = !0, this.isDown = !1, this.dirty = !0, this.wasTouch = !0, this.wasCanceled = !1, this.active = !1; }, touchcancel(t) { this.buttons = 0, this.event = t, this.primaryDown = !1, this.justUp = !1, this.isDown = !1, this.dirty = !0, this.wasTouch = !0, this.wasCanceled = !0, this.active = !1; }, noButtonDown() { return this.buttons === 0; }, leftButtonDown() { return 1 & this.buttons; }, rightButtonDown() { return 2 & this.buttons; }, middleButtonDown() { return 4 & this.buttons; }, backButtonDown() { return 8 & this.buttons; }, forwardButtonDown() { return 16 & this.buttons; }, getDistance() { return s(this.downX, this.downY, this.x, this.y); }, getInterpolatedPosition(t, e) { void 0 === t && (t = 10), void 0 === e && (e = []); for (let i = this.prevPosition.x, n = this.prevPosition.y, s = this.position.x, o = this.position.y, a = 0; a < t; a++) { const h = 1 / t * a; e[a] = { x: r(h, i, s), y: r(h, n, o) }; } return e; }, destroy() { this.camera = null, this.manager = null, this.position = null; }, x: { get() { return this.position.x; }, set(t) { this.position.x = t; } }, y: { get() { return this.position.y; }, set(t) { this.position.y = t; } },
  }); t.exports = a;
}, function (t, e, i) {
  const n = i(0); const s = i(168); const r = new n({
    initialize(t) { this.manager = t, this.capture = !0, this.enabled = !1, this.target, this.locked = !1, t.events.once('boot', this.boot, this); }, boot() { const t = this.manager.config; this.enabled = t.inputMouse, this.target = t.inputMouseEventTarget, this.capture = t.inputMouseCapture, this.target || (this.target = this.manager.game.canvas), t.disableContextMenu && this.disableContextMenu(), this.enabled && this.startListeners(); }, disableContextMenu() { return document.body.addEventListener('contextmenu', (t) => (t.preventDefault(), !1)), this; }, requestPointerLock() { if (s.pointerLock) { const t = this.target; t.requestPointerLock = t.requestPointerLock || t.mozRequestPointerLock || t.webkitRequestPointerLock, t.requestPointerLock(); } }, releasePointerLock() { s.pointerLock && (document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock, document.exitPointerLock()); }, startListeners() { const t = this; const e = function (e) { !e.defaultPrevented && t.enabled && t.manager && (t.manager.queueMouseMove(e), t.capture && e.preventDefault()); }; const i = function (e) { !e.defaultPrevented && t.enabled && t.manager && (t.manager.queueMouseDown(e), t.capture && e.preventDefault()); }; const n = function (e) { !e.defaultPrevented && t.enabled && t.manager && (t.manager.queueMouseUp(e), t.capture && e.preventDefault()); }; this.onMouseMove = e, this.onMouseDown = i, this.onMouseUp = n; const r = this.target; const o = { passive: !0 }; const a = { passive: !1 }; if (r.addEventListener('mousemove', e, this.capture ? a : o), r.addEventListener('mousedown', i, this.capture ? a : o), r.addEventListener('mouseup', n, this.capture ? a : o), s.pointerLock) { const h = function (e) { const i = t.target; t.locked = document.pointerLockElement === i || document.mozPointerLockElement === i || document.webkitPointerLockElement === i, t.manager.queue.push(e); }; this.pointerLockChange = h, document.addEventListener('pointerlockchange', h, !0), document.addEventListener('mozpointerlockchange', h, !0), document.addEventListener('webkitpointerlockchange', h, !0); } }, stopListeners() { const t = this.target; t.removeEventListener('mousemove', this.onMouseMove), t.removeEventListener('mousedown', this.onMouseDown), t.removeEventListener('mouseup', this.onMouseUp), s.pointerLock && (document.removeEventListener('pointerlockchange', this.pointerLockChange, !0), document.removeEventListener('mozpointerlockchange', this.pointerLockChange, !0), document.removeEventListener('webkitpointerlockchange', this.pointerLockChange, !0)); }, destroy() { this.stopListeners(), this.target = null, this.manager = null; },
  }); t.exports = r;
}, function (t, e) {
  t.exports = {
    MOUSE_DOWN: 0, MOUSE_MOVE: 1, MOUSE_UP: 2, TOUCH_START: 3, TOUCH_MOVE: 4, TOUCH_END: 5, TOUCH_CANCEL: 7, POINTER_LOCK_CHANGE: 6,
  };
}, function (t, e, i) {
  const n = i(0); const s = i(337); const r = i(11); const o = i(336); const a = i(335); const h = i(9); const l = i(333); const u = i(38); const c = i(332); const d = new n({
    initialize(t, e) {
      this.game = t, this.canvas, this.config = e, this.enabled = !0, this.events = new r(), this.queue = [], this.domCallbacks = {
        up: [], down: [], move: [], upOnce: [], downOnce: [], moveOnce: [],
      }, this._hasUpCallback = !1, this._hasDownCallback = !1, this._hasMoveCallback = !1, this._customCursor = '', this._setCursor = 0, this.defaultCursor = '', this.mouse = e.inputMouse ? new o(this) : null, this.touch = e.inputTouch ? new l(this) : null, this.pointers = [], this.pointersTotal = e.inputActivePointers, e.inputTouch && this.pointersTotal === 1 && (this.pointersTotal = 2); for (let i = 0; i <= this.pointersTotal; i++) this.pointers.push(new a(this, i)); this.mousePointer = e.inputMouse ? this.pointers[0] : null, this.activePointer = this.pointers[0], this.dirty = !1, this.scale = { x: 1, y: 1 }, this.globalTopOnly = !0, this.ignoreEvents = !1, this.bounds = new h(), this._tempPoint = { x: 0, y: 0 }, this._tempHitTest = [], this._tempMatrix = new u(), this._tempMatrix2 = new u(), t.events.once('boot', this.boot, this);
    },
    boot() { this.canvas = this.game.canvas, this.updateBounds(), this.events.emit('boot'), this.game.events.on('prestep', this.update, this), this.game.events.on('poststep', this.postUpdate, this), this.game.events.once('destroy', this.destroy, this); },
    updateBounds() { const t = this.bounds; const e = this.canvas.getBoundingClientRect(); t.x = e.left + window.pageXOffset - document.documentElement.clientLeft, t.y = e.top + window.pageYOffset - document.documentElement.clientTop, t.width = e.width, t.height = e.height; },
    resize() { this.updateBounds(); const t = this.game.config.width; const e = this.game.config.height; const i = this.bounds.width; const n = this.bounds.height; this.scale.x = t / i, this.scale.y = e / n; },
    update(t) { let e; this._setCursor = 0, this.events.emit('update'), this.ignoreEvents = !1, this.dirty = !1; const i = this.queue.length; const n = this.pointers; for (e = 0; e < this.pointersTotal; e++)n[e].reset(); if (this.enabled && i !== 0) { this.dirty = !0, this.updateBounds(), this.scale.x = this.game.config.width / this.bounds.width, this.scale.y = this.game.config.height / this.bounds.height; const r = this.queue.splice(0, i); const o = this.mousePointer; for (e = 0; e < i; e += 2) { const a = r[e]; const h = r[e + 1]; switch (a) { case s.MOUSE_DOWN: o.down(h, t); break; case s.MOUSE_MOVE: o.move(h, t); break; case s.MOUSE_UP: o.up(h, t); break; case s.TOUCH_START: this.startPointer(h, t); break; case s.TOUCH_MOVE: this.updatePointer(h, t); break; case s.TOUCH_END: this.stopPointer(h, t); break; case s.TOUCH_CANCEL: this.cancelPointer(h, t); break; case s.POINTER_LOCK_CHANGE: this.events.emit('pointerlockchange', h, this.mouse.locked); } } } },
    postUpdate() { this._setCursor === 1 ? this.canvas.style.cursor = this._customCursor : this._setCursor === 2 && (this.canvas.style.cursor = this.defaultCursor); },
    setDefaultCursor(t) { this.defaultCursor = t, this.canvas.style.cursor !== t && (this.canvas.style.cursor = t); },
    setCursor(t) { t.cursor && (this._setCursor = 1, this._customCursor = t.cursor); },
    resetCursor(t) { t.cursor && (this._setCursor = 2); },
    startPointer(t, e) { for (let i = this.pointers, n = 0; n < t.changedTouches.length; n++) for (let s = t.changedTouches[n], r = 1; r < this.pointersTotal; r++) { const o = i[r]; if (!o.active) { o.touchstart(s, e), this.activePointer = o; break; } } },
    updatePointer(t, e) { for (let i = this.pointers, n = 0; n < t.changedTouches.length; n++) for (let s = t.changedTouches[n], r = 1; r < this.pointersTotal; r++) { const o = i[r]; if (o.active && o.identifier === s.identifier) { o.touchmove(s, e), this.activePointer = o; break; } } },
    stopPointer(t, e) { for (let i = this.pointers, n = 0; n < t.changedTouches.length; n++) for (let s = t.changedTouches[n], r = 1; r < this.pointersTotal; r++) { const o = i[r]; if (o.active && o.identifier === s.identifier) { o.touchend(s, e); break; } } },
    cancelPointer(t, e) { for (let i = this.pointers, n = 0; n < t.changedTouches.length; n++) for (let s = t.changedTouches[n], r = 1; r < this.pointersTotal; r++) { const o = i[r]; if (o.active && o.identifier === s.identifier) { o.touchend(s, e); break; } } },
    addPointer(t) { void 0 === t && (t = 1); const e = []; this.pointersTotal + t > 10 && (t = 10 - this.pointersTotal); for (let i = 0; i < t; i++) { const n = this.pointers.length; const s = new a(this, n); this.pointers.push(s), this.pointersTotal++, e.push(s); } return e; },
    processDomCallbacks(t, e, i) { let n = 0; for (n = 0; n < t.length; n++)t[n](i); for (n = 0; n < e.length; n++)e[n](i); return t = [], e.length > 0; },
    queueTouchStart(t) { if (this.queue.push(s.TOUCH_START, t), this._hasDownCallback) { const e = this.domCallbacks; this._hasDownCallback = this.processDomCallbacks(e.downOnce, e.down, t); } },
    queueTouchMove(t) { if (this.queue.push(s.TOUCH_MOVE, t), this._hasMoveCallback) { const e = this.domCallbacks; this._hasMoveCallback = this.processDomCallbacks(e.moveOnce, e.move, t); } },
    queueTouchEnd(t) { if (this.queue.push(s.TOUCH_END, t), this._hasUpCallback) { const e = this.domCallbacks; this._hasUpCallback = this.processDomCallbacks(e.upOnce, e.up, t); } },
    queueTouchCancel(t) { this.queue.push(s.TOUCH_CANCEL, t); },
    queueMouseDown(t) { if (this.queue.push(s.MOUSE_DOWN, t), this._hasDownCallback) { const e = this.domCallbacks; this._hasDownCallback = this.processDomCallbacks(e.downOnce, e.down, t); } },
    queueMouseMove(t) { if (this.queue.push(s.MOUSE_MOVE, t), this._hasMoveCallback) { const e = this.domCallbacks; this._hasMoveCallback = this.processDomCallbacks(e.moveOnce, e.move, t); } },
    queueMouseUp(t) { if (this.queue.push(s.MOUSE_UP, t), this._hasUpCallback) { const e = this.domCallbacks; this._hasUpCallback = this.processDomCallbacks(e.upOnce, e.up, t); } },
    addUpCallback(t, e) { return void 0 === e && (e = !0), e ? this.domCallbacks.upOnce.push(t) : this.domCallbacks.up.push(t), this._hasUpCallback = !0, this; },
    addDownCallback(t, e) { return void 0 === e && (e = !0), e ? this.domCallbacks.downOnce.push(t) : this.domCallbacks.down.push(t), this._hasDownCallback = !0, this; },
    addMoveCallback(t, e) { return void 0 === e && (e = !1), e ? this.domCallbacks.moveOnce.push(t) : this.domCallbacks.move.push(t), this._hasMoveCallback = !0, this; },
    inputCandidate(t, e) { const i = t.input; if (!i || !i.enabled || !t.willRender(e)) return !1; let n = !0; let s = t.parentContainer; if (s) do { if (!s.willRender(e)) { n = !1; break; }s = s.parentContainer; } while (s);return n; },
    hitTest(t, e, i, n) { void 0 === n && (n = this._tempHitTest); const s = this._tempPoint; const r = i.scrollX; const o = i.scrollY; n.length = 0; let a = t.x; let h = t.y; i.resolution !== 1 && (a += i._x, h += i._y), i.getWorldPoint(a, h, s), t.worldX = s.x, t.worldY = s.y; for (let l = { x: 0, y: 0 }, u = this._tempMatrix, d = this._tempMatrix2, f = 0; f < e.length; f++) { const p = e[f]; if (this.inputCandidate(p, i)) { const g = s.x + r * p.scrollFactorX - r; const v = s.y + o * p.scrollFactorY - o; p.parentContainer ? (p.getWorldTransformMatrix(u, d), u.applyInverse(g, v, l)) : c(g, v, p.x, p.y, p.rotation, p.scaleX, p.scaleY, l), this.pointWithinHitArea(p, l.x, l.y) && n.push(p); } } return n; },
    pointWithinHitArea(t, e, i) { e += t.displayOriginX, i += t.displayOriginY; const n = t.input; return !(!n || !n.hitAreaCallback(n.hitArea, e, i, t)) && (n.localX = e, n.localY = i, !0); },
    pointWithinInteractiveObject(t, e, i) { return !!t.hitArea && (e += t.gameObject.displayOriginX, i += t.gameObject.displayOriginY, t.localX = e, t.localY = i, t.hitAreaCallback(t.hitArea, e, i, t)); },
    transformPointer(t, e, i) { t.prevPosition.x = t.x, t.prevPosition.y = t.y, t.x = (e - this.bounds.left) * this.scale.x, t.y = (i - this.bounds.top) * this.scale.y; },
    transformX(t) { return (t - this.bounds.left) * this.scale.x; },
    transformY(t) { return (t - this.bounds.top) * this.scale.y; },
    getOffsetX() { return this.bounds.left; },
    getOffsetY() { return this.bounds.top; },
    getScaleX() { return this.game.config.width / this.bounds.width; },
    getScaleY() { return this.game.config.height / this.bounds.height; },
    destroy() { this.events.removeAllListeners(), this.mouse && this.mouse.destroy(), this.touch && this.touch.destroy(); for (let t = 0; t < this.pointers.length; t++) this.pointers[t].destroy(); this.domCallbacks = {}, this.pointers = [], this.queue = [], this._tempHitTest = [], this._tempMatrix.destroy(), this.canvas = null, this.game = null; },
  }); t.exports = d;
}, function (t, e, i) { let n; let s; let r; const o = i(24); const a = { supportInverseAlpha: !1, supportNewBlendModes: !1 }; t.exports = (void 0 !== document && (a.supportNewBlendModes = (n = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAABAQMAAADD8p2OAAAAA1BMVEX/', s = 'AAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg==', (r = new Image()).onload = function () { const t = new Image(); t.onload = function () { const e = o.create(t, 6, 1).getContext('2d'); if (e.globalCompositeOperation = 'multiply', e.drawImage(r, 0, 0), e.drawImage(t, 2, 0), !e.getImageData(2, 0, 1, 1)) return !1; const i = e.getImageData(2, 0, 1, 1).data; o.remove(t), a.supportNewBlendModes = i[0] === 255 && i[1] === 0 && i[2] === 0; }, t.src = `${n}/wCKxvRF${s}`; }, r.src = `${n}AP804Oa6${s}`, !1), a.supportInverseAlpha = (function () { const t = o.create(this, 2, 1).getContext('2d'); t.fillStyle = 'rgba(10, 20, 30, 0.5)', t.fillRect(0, 0, 1, 1); const e = t.getImageData(0, 0, 1, 1); if (e === null) return !1; t.putImageData(e, 1, 0); const i = t.getImageData(1, 0, 1, 1); return i.data[0] === e.data[0] && i.data[1] === e.data[1] && i.data[2] === e.data[2] && i.data[3] === e.data[3]; }())), a); }, function (t, e, i) {
  t.exports = {
    os: i(92), browser: i(118), features: i(168), input: i(902), audio: i(901), video: i(900), fullscreen: i(899), canvasFeatures: i(339),
  };
}, function (t, e, i) {
  const n = i(0); const s = i(1); const r = new n({
    initialize() { this.isRunning = !1, this.callback = s, this.tick = 0, this.isSetTimeOut = !1, this.timeOutID = null, this.lastTime = 0; const t = this; this.step = function e(i) { t.lastTime = t.tick, t.tick = i, t.timeOutID = window.requestAnimationFrame(e), t.callback(i); }, this.stepTimeout = function e() { const i = Date.now(); const n = Math.max(16 + t.lastTime - i, 0); t.lastTime = t.tick, t.tick = i, t.timeOutID = window.setTimeout(e, n), t.callback(i); }; }, start(t, e) { this.isRunning || (this.callback = t, this.isSetTimeOut = e, this.isRunning = !0, this.timeOutID = e ? window.setTimeout(this.stepTimeout, 0) : window.requestAnimationFrame(this.step)); }, stop() { this.isRunning = !1, this.isSetTimeOut ? clearTimeout(this.timeOutID) : window.cancelAnimationFrame(this.timeOutID); }, destroy() { this.stop(), this.callback = s; },
  }); t.exports = r;
}, function (t, e) { t.exports = function (t) { t.parentNode && t.parentNode.removeChild(t); }; }, function (t, e) { t.exports = function (t) { let e = ''; try { window.DOMParser ? e = (new DOMParser()).parseFromString(t, 'text/xml') : (e = new ActiveXObject('Microsoft.XMLDOM')).loadXML(t); } catch (t) { e = null; } return e && e.documentElement && !e.getElementsByTagName('parsererror').length ? e : null; }; }, function (t, e, i) { const n = i(92); t.exports = function (t) { if (document.readyState !== 'complete' && document.readyState !== 'interactive') { var e = function () { document.removeEventListener('deviceready', e, !0), document.removeEventListener('DOMContentLoaded', e, !0), window.removeEventListener('load', e, !0), t(); }; document.body ? n.cordova && !n.cocoonJS ? document.addEventListener('deviceready', e, !1) : (document.addEventListener('DOMContentLoaded', e, !0), window.addEventListener('load', e, !0)) : window.setTimeout(e, 20); } else t(); }; }, function (t, e) { t.exports = function (t, e, i) { return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? t + 6 * (e - t) * i : i < 0.5 ? e : i < 2 / 3 ? t + (e - t) * (2 / 3 - i) * 6 : t; }; }, function (t, e) { t.exports = function (t) { const e = t.toString(16); return e.length === 1 ? `0${e}` : e; }; }, function (t, e, i) { const n = i(37); n.ColorToRGBA = i(915), n.ComponentToHex = i(346), n.GetColor = i(177), n.GetColor32 = i(376), n.HexStringToColor = i(377), n.HSLToColor = i(914), n.HSVColorWheel = i(913), n.HSVToRGB = i(176), n.HueToComponent = i(345), n.IntegerToColor = i(374), n.IntegerToRGB = i(373), n.Interpolate = i(912), n.ObjectToColor = i(372), n.RandomRGB = i(911), n.RGBStringToColor = i(371), n.RGBToHSV = i(375), n.RGBToString = i(910), n.ValueToColor = i(178), t.exports = n; }, function (t, e) { t.exports = { setCrisp(t) { return ['optimizeSpeed', 'crisp-edges', '-moz-crisp-edges', '-webkit-optimize-contrast', 'optimize-contrast', 'pixelated'].forEach((e) => { t.style['image-rendering'] = e; }), t.style.msInterpolationMode = 'nearest-neighbor', t; }, setBicubic(t) { return t.style['image-rendering'] = 'auto', t.style.msInterpolationMode = 'bicubic', t; } }; }, function (t, e, i) {
  const n = i(171); const s = i(0); const r = i(70); const o = i(3); const a = new s({
    Extends: r, initialize(t) { void 0 === t && (t = []), r.call(this, 'SplineCurve'), this.points = [], this.addPoints(t); }, addPoints(t) { for (let e = 0; e < t.length; e++) { const i = new o(); typeof t[e] === 'number' ? (i.x = t[e], i.y = t[e + 1], e++) : Array.isArray(t[e]) ? (i.x = t[e][0], i.y = t[e][1]) : (i.x = t[e].x, i.y = t[e].y), this.points.push(i); } return this; }, addPoint(t, e) { const i = new o(t, e); return this.points.push(i), i; }, getStartPoint(t) { return void 0 === t && (t = new o()), t.copy(this.points[0]); }, getResolution(t) { return t * this.points.length; }, getPoint(t, e) { void 0 === e && (e = new o()); const i = this.points; const s = (i.length - 1) * t; const r = Math.floor(s); const a = s - r; const h = i[r === 0 ? r : r - 1]; const l = i[r]; const u = i[r > i.length - 2 ? i.length - 1 : r + 1]; const c = i[r > i.length - 3 ? i.length - 1 : r + 2]; return e.set(n(a, h.x, l.x, u.x, c.x), n(a, h.y, l.y, u.y, c.y)); }, toJSON() { for (var t = [], e = 0; e < this.points.length; e++)t.push(this.points[e].x), t.push(this.points[e].y); return { type: this.type, points: t }; },
  }); a.fromJSON = function (t) { return new a(t.points); }, t.exports = a;
}, function (t, e) { t.exports = function (t, e, i, n) { return (function (t, e) { const i = 1 - t; return i * i * e; }(t, e)) + (function (t, e) { return 2 * (1 - t) * t * e; }(t, i)) + (function (t, e) { return t * t * e; }(t, n)); }; }, function (t, e, i) {
  const n = i(0); const s = i(70); const r = i(350); const o = i(3); const a = new n({
    Extends: s, initialize(t, e, i) { s.call(this, 'QuadraticBezier'), Array.isArray(t) && (i = new o(t[4], t[5]), e = new o(t[2], t[3]), t = new o(t[0], t[1])), this.p0 = t, this.p1 = e, this.p2 = i; }, getStartPoint(t) { return void 0 === t && (t = new o()), t.copy(this.p0); }, getResolution(t) { return t; }, getPoint(t, e) { void 0 === e && (e = new o()); const i = this.p0; const n = this.p1; const s = this.p2; return e.set(r(t, i.x, n.x, s.x), r(t, i.y, n.y, s.y)); }, draw(t, e) { void 0 === e && (e = 32); const i = this.getPoints(e); t.beginPath(), t.moveTo(this.p0.x, this.p0.y); for (let n = 1; n < i.length; n++)t.lineTo(i[n].x, i[n].y); return t.strokePath(), t; }, toJSON() { return { type: this.type, points: [this.p0.x, this.p0.y, this.p1.x, this.p1.y, this.p2.x, this.p2.y] }; },
  }); a.fromJSON = function (t) { const e = t.points; const i = new o(e[0], e[1]); const n = new o(e[2], e[3]); const s = new o(e[4], e[5]); return new a(i, n, s); }, t.exports = a;
}, function (t, e, i) {
  const n = i(0); const s = i(70); const r = i(173); const o = i(9); const a = i(3); const h = new a(); const l = new n({
    Extends: s, initialize(t, e) { s.call(this, 'LineCurve'), Array.isArray(t) && (e = new a(t[2], t[3]), t = new a(t[0], t[1])), this.p0 = t, this.p1 = e; }, getBounds(t) { return void 0 === t && (t = new o()), r([this.p0, this.p1], t); }, getStartPoint(t) { return void 0 === t && (t = new a()), t.copy(this.p0); }, getResolution(t) { return void 0 === t && (t = 1), t; }, getPoint(t, e) { return void 0 === e && (e = new a()), t === 1 ? e.copy(this.p1) : (e.copy(this.p1).subtract(this.p0).scale(t).add(this.p0), e); }, getPointAt(t, e) { return this.getPoint(t, e); }, getTangent() { return h.copy(this.p1).subtract(this.p0).normalize(); }, draw(t) { return t.lineBetween(this.p0.x, this.p0.y, this.p1.x, this.p1.y), t; }, toJSON() { return { type: this.type, points: [this.p0.x, this.p0.y, this.p1.x, this.p1.y] }; },
  }); l.fromJSON = function (t) { const e = t.points; const i = new a(e[0], e[1]); const n = new a(e[2], e[3]); return new l(i, n); }, t.exports = l;
}, function (t, e, i) {
  const n = i(0); const s = i(70); const r = i(31); const o = i(4); const a = i(172); const h = i(3); const l = new n({
    Extends: s,
    initialize(t, e, i, n, a, l, u, c) { if (typeof t === 'object') { const d = t; t = o(d, 'x', 0), e = o(d, 'y', 0), i = o(d, 'xRadius', 0), n = o(d, 'yRadius', i), a = o(d, 'startAngle', 0), l = o(d, 'endAngle', 360), u = o(d, 'clockwise', !1), c = o(d, 'rotation', 0); } else void 0 === n && (n = i), void 0 === a && (a = 0), void 0 === l && (l = 360), void 0 === u && (u = !1), void 0 === c && (c = 0); s.call(this, 'EllipseCurve'), this.p0 = new h(t, e), this._xRadius = i, this._yRadius = n, this._startAngle = r(a), this._endAngle = r(l), this._clockwise = u, this._rotation = r(c); },
    getStartPoint(t) { return void 0 === t && (t = new h()), this.getPoint(0, t); },
    getResolution(t) { return 2 * t; },
    getPoint(t, e) { void 0 === e && (e = new h()); for (var i = 2 * Math.PI, n = this._endAngle - this._startAngle, s = Math.abs(n) < Number.EPSILON; n < 0;)n += i; for (;n > i;)n -= i; n < Number.EPSILON && (n = s ? 0 : i), this._clockwise && !s && (n === i ? n = -i : n -= i); const r = this._startAngle + t * n; let o = this.p0.x + this._xRadius * Math.cos(r); let a = this.p0.y + this._yRadius * Math.sin(r); if (this._rotation !== 0) { const l = Math.cos(this._rotation); const u = Math.sin(this._rotation); const c = o - this.p0.x; const d = a - this.p0.y; o = c * l - d * u + this.p0.x, a = c * u + d * l + this.p0.y; } return e.set(o, a); },
    setXRadius(t) { return this.xRadius = t, this; },
    setYRadius(t) { return this.yRadius = t, this; },
    setWidth(t) { return this.xRadius = 2 * t, this; },
    setHeight(t) { return this.yRadius = 2 * t, this; },
    setStartAngle(t) { return this.startAngle = t, this; },
    setEndAngle(t) { return this.endAngle = t, this; },
    setClockwise(t) { return this.clockwise = t, this; },
    setRotation(t) { return this.rotation = t, this; },
    x: { get() { return this.p0.x; }, set(t) { this.p0.x = t; } },
    y: { get() { return this.p0.y; }, set(t) { this.p0.y = t; } },
    xRadius: { get() { return this._xRadius; }, set(t) { this._xRadius = t; } },
    yRadius: { get() { return this._yRadius; }, set(t) { this._yRadius = t; } },
    startAngle: { get() { return a(this._startAngle); }, set(t) { this._startAngle = r(t); } },
    endAngle: { get() { return a(this._endAngle); }, set(t) { this._endAngle = r(t); } },
    clockwise: { get() { return this._clockwise; }, set(t) { this._clockwise = t; } },
    angle: { get() { return a(this._rotation); }, set(t) { this._rotation = r(t); } },
    rotation: { get() { return this._rotation; }, set(t) { this._rotation = t; } },
    toJSON() {
      return {
        type: this.type, x: this.p0.x, y: this.p0.y, xRadius: this._xRadius, yRadius: this._yRadius, startAngle: a(this._startAngle), endAngle: a(this._endAngle), clockwise: this._clockwise, rotation: a(this._rotation),
      };
    },
  }); l.fromJSON = function (t) { return new l(t); }, t.exports = l;
}, function (t, e) { t.exports = function (t, e, i, n, s) { return (function (t, e) { const i = 1 - t; return i * i * i * e; }(t, e)) + (function (t, e) { const i = 1 - t; return 3 * i * i * t * e; }(t, i)) + (function (t, e) { return 3 * (1 - t) * t * t * e; }(t, n)) + (function (t, e) { return t * t * t * e; }(t, s)); }; }, function (t, e, i) {
  const n = i(0); const s = i(354); const r = i(70); const o = i(3); const a = new n({
    Extends: r, initialize(t, e, i, n) { r.call(this, 'CubicBezierCurve'), Array.isArray(t) && (n = new o(t[6], t[7]), i = new o(t[4], t[5]), e = new o(t[2], t[3]), t = new o(t[0], t[1])), this.p0 = t, this.p1 = e, this.p2 = i, this.p3 = n; }, getStartPoint(t) { return void 0 === t && (t = new o()), t.copy(this.p0); }, getResolution(t) { return t; }, getPoint(t, e) { void 0 === e && (e = new o()); const i = this.p0; const n = this.p1; const r = this.p2; const a = this.p3; return e.set(s(t, i.x, n.x, r.x, a.x), s(t, i.y, n.y, r.y, a.y)); }, draw(t, e) { void 0 === e && (e = 32); const i = this.getPoints(e); t.beginPath(), t.moveTo(this.p0.x, this.p0.y); for (let n = 1; n < i.length; n++)t.lineTo(i[n].x, i[n].y); return t.strokePath(), t; }, toJSON() { return { type: this.type, points: [this.p0.x, this.p0.y, this.p1.x, this.p1.y, this.p2.x, this.p2.y, this.p3.x, this.p3.y] }; },
  }); a.fromJSON = function (t) { const e = t.points; const i = new o(e[0], e[1]); const n = new o(e[2], e[3]); const s = new o(e[4], e[5]); const r = new o(e[6], e[7]); return new a(i, n, s, r); }, t.exports = a;
}, function (t, e) {
  t.exports = {
    0: '#000', 1: '#9D9D9D', 2: '#FFF', 3: '#BE2633', 4: '#E06F8B', 5: '#493C2B', 6: '#A46422', 7: '#EB8931', 8: '#F7E26B', 9: '#2F484E', A: '#44891A', B: '#A3CE27', C: '#1B2632', D: '#005784', E: '#31A2F2', F: '#B2DCEF',
  };
}, function (t, e, i) { const n = i(356); const s = i(24); const r = i(4); t.exports = function (t) { const e = r(t, 'data', []); let i = r(t, 'canvas', null); const o = r(t, 'palette', n); const a = r(t, 'pixelWidth', 1); const h = r(t, 'pixelHeight', a); let l = r(t, 'resizeCanvas', !0); let u = r(t, 'clearCanvas', !0); const c = r(t, 'preRender', null); const d = r(t, 'postRender', null); const f = Math.floor(Math.abs(e[0].length * a)); const p = Math.floor(Math.abs(e.length * h)); i || (i = s.create2D(this, f, p), l = !1, u = !1), l && (i.width = f, i.height = p); const g = i.getContext('2d'); u && g.clearRect(0, 0, f, p), c && c(i, g); for (let v = 0; v < e.length; v++) for (let y = e[v], m = 0; m < y.length; m++) { const x = y[m]; x !== '.' && x !== ' ' && (g.fillStyle = o[x], g.fillRect(m * a, v * h, a, h)); } return d && d(i, g), i; }; }, function (t, e, i) { t.exports = i(952); }, function (t, e, i) { t.exports = { In: i(955), Out: i(954), InOut: i(953) }; }, function (t, e, i) { t.exports = { In: i(958), Out: i(957), InOut: i(956) }; }, function (t, e, i) { t.exports = { In: i(961), Out: i(960), InOut: i(959) }; }, function (t, e, i) { t.exports = { In: i(964), Out: i(963), InOut: i(962) }; }, function (t, e, i) { t.exports = i(965); }, function (t, e, i) { t.exports = { In: i(968), Out: i(967), InOut: i(966) }; }, function (t, e, i) { t.exports = { In: i(971), Out: i(970), InOut: i(969) }; }, function (t, e, i) { t.exports = { In: i(974), Out: i(973), InOut: i(972) }; }, function (t, e, i) { t.exports = { In: i(977), Out: i(976), InOut: i(975) }; }, function (t, e, i) { t.exports = { In: i(980), Out: i(979), InOut: i(978) }; }, function (t, e, i) { t.exports = { In: i(983), Out: i(982), InOut: i(981) }; }, function (t, e, i) {
  t.exports = {
    Fade: i(986), Flash: i(985), Pan: i(984), Shake: i(951), Zoom: i(950),
  };
}, function (t, e, i) {
  const n = i(37); t.exports = function (t) {
    const e = new n(); const
      i = /^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d+(?:\.\d+)?))?\s*\)$/.exec(t.toLowerCase()); if (i) { const s = parseInt(i[1], 10); const r = parseInt(i[2], 10); const o = parseInt(i[3], 10); const a = void 0 !== i[4] ? parseFloat(i[4]) : 1; e.setTo(s, r, o, 255 * a); } return e;
  };
}, function (t, e, i) { const n = i(37); t.exports = function (t) { return new n(t.r, t.g, t.b, t.a); }; }, function (t, e) {
  t.exports = function (t) {
    return t > 16777215 ? {
      a: t >>> 24, r: t >> 16 & 255, g: t >> 8 & 255, b: 255 & t,
    } : {
      a: 255, r: t >> 16 & 255, g: t >> 8 & 255, b: 255 & t,
    };
  };
}, function (t, e, i) { const n = i(37); const s = i(373); t.exports = function (t) { const e = s(t); return new n(e.r, e.g, e.b, e.a); }; }, function (t, e) { t.exports = function (t, e, i, n) { void 0 === n && (n = { h: 0, s: 0, v: 0 }), t /= 255, e /= 255, i /= 255; const s = Math.min(t, e, i); const r = Math.max(t, e, i); const o = r - s; let a = 0; const h = r === 0 ? 0 : o / r; const l = r; return r !== s && (r === t ? a = (e - i) / o + (e < i ? 6 : 0) : r === e ? a = (i - t) / o + 2 : r === i && (a = (t - e) / o + 4), a /= 6), n.hasOwnProperty('_h') ? (n._h = a, n._s = h, n._v = l) : (n.h = a, n.s = h, n.v = l), n; }; }, function (t, e) { t.exports = function (t, e, i, n) { return n << 24 | t << 16 | e << 8 | i; }; }, function (t, e, i) { const n = i(37); t.exports = function (t) { const e = new n(); t = t.replace(/^(?:#|0x)?([a-f\d])([a-f\d])([a-f\d])$/i, (t, e, i, n) => e + e + i + i + n + n); const i = /^(?:#|0x)?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(t); if (i) { const s = parseInt(i[1], 16); const r = parseInt(i[2], 16); const o = parseInt(i[3], 16); e.setTo(s, r, o); } return e; }; }, function (t, e, i) {
  const n = i(121); const s = i(24); const r = i(175); const o = i(23); const a = i(0); const h = i(14); const l = i(370); const u = i(119); const c = i(9); const d = i(3); const f = new a({
    Extends: n, Mixins: [h.Flip, h.Tint], initialize(t, e, i, s) { n.call(this, t, e, i, s), this.inputEnabled = !0, this.fadeEffect = new l.Fade(this), this.flashEffect = new l.Flash(this), this.shakeEffect = new l.Shake(this), this.panEffect = new l.Pan(this), this.zoomEffect = new l.Zoom(this), this.lerp = new d(1, 1), this.followOffset = new d(), this.deadzone = null, this._follow = null, this.renderToTexture = !1, this.canvas = null, this.context = null, this.glTexture = null, this.framebuffer = null, this.pipeline = null; }, setRenderToTexture(t) { const e = this.scene.sys.game.renderer; return e.gl ? (this.glTexture = e.createTextureFromSource(null, this.width, this.height, 0), this.framebuffer = e.createFramebuffer(this.width, this.height, this.glTexture, !1)) : (this.canvas = s.create2D(this, this.width, this.height), this.context = this.canvas.getContext('2d')), this.renderToTexture = !0, t && this.setPipeline(t), this; }, setPipeline(t) { if (typeof t === 'string') { const e = this.scene.sys.game.renderer; e.gl && e.hasPipeline(t) && (this.pipeline = e.getPipeline(t)); } else this.pipeline = t; return this; }, clearRenderToTexture() { const t = this.scene.sys.game.renderer; return t.gl ? (this.framebuffer && t.deleteFramebuffer(this.framebuffer), this.glTexture && t.deleteTexture(this.glTexture), this.framebuffer = null, this.glTexture = null, this.pipeline = null) : (s.remove(this), this.canvas = null, this.context = null), this.renderToTexture = !1, this; }, setDeadzone(t, e) { if (void 0 === t) this.deadzone = null; else { if (this.deadzone ? (this.deadzone.width = t, this.deadzone.height = e) : this.deadzone = new c(0, 0, t, e), this._follow) { const i = this.width / 2; const n = this.height / 2; const s = this._follow.x - this.followOffset.x; const o = this._follow.y - this.followOffset.y; this.midPoint.set(s, o), this.scrollX = s - i, this.scrollY = o - n; }r(this.deadzone, this.midPoint.x, this.midPoint.y); } return this; }, fadeIn(t, e, i, n, s, r) { return this.fadeEffect.start(!1, t, e, i, n, !0, s, r); }, fadeOut(t, e, i, n, s, r) { return this.fadeEffect.start(!0, t, e, i, n, !0, s, r); }, fadeFrom(t, e, i, n, s, r, o) { return this.fadeEffect.start(!1, t, e, i, n, s, r, o); }, fade(t, e, i, n, s, r, o) { return this.fadeEffect.start(!0, t, e, i, n, s, r, o); }, flash(t, e, i, n, s, r, o) { return this.flashEffect.start(t, e, i, n, s, r, o); }, shake(t, e, i, n, s) { return this.shakeEffect.start(t, e, i, n, s); }, pan(t, e, i, n, s, r, o) { return this.panEffect.start(t, e, i, n, s, r, o); }, zoomTo(t, e, i, n, s, r) { return this.zoomEffect.start(t, e, i, n, s, r); }, preRender(t, e) { const i = this.width; const n = this.height; const s = 0.5 * i; const o = 0.5 * n; const a = this.zoom * t; const h = this.matrix; let l = i * this.originX; let c = n * this.originY; const d = this._follow; const f = this.deadzone; let p = this.scrollX; let g = this.scrollY; if (f && r(f, this.midPoint.x, this.midPoint.y), d) { const v = d.x - this.followOffset.x; const y = d.y - this.followOffset.y; f ? (v < f.x ? p = u(p, p - (f.x - v), this.lerp.x) : v > f.right && (p = u(p, p + (v - f.right), this.lerp.x)), y < f.y ? g = u(g, g - (f.y - y), this.lerp.y) : y > f.bottom && (g = u(g, g + (y - f.bottom), this.lerp.y))) : (p = u(p, v - l, this.lerp.x), g = u(g, y - c, this.lerp.y)); } this.useBounds && (p = this.clampX(p), g = this.clampY(g)), this.roundPixels && (l = Math.round(l), c = Math.round(c)), this.scrollX = p, this.scrollY = g; const m = p + s; const x = g + o; this.midPoint.set(m, x); const w = i / a; const b = n / a; this.worldView.setTo(m - w / 2, x - b / 2, w, b), h.loadIdentity(), h.scale(e, e), h.translate(this.x + l, this.y + c), h.rotate(this.rotation), h.scale(a, a), h.translate(-l, -c), this.shakeEffect.preRender(); }, setLerp(t, e) { return void 0 === t && (t = 1), void 0 === e && (e = t), this.lerp.set(t, e), this; }, setFollowOffset(t, e) { return void 0 === t && (t = 0), void 0 === e && (e = 0), this.followOffset.set(t, e), this; }, startFollow(t, e, i, n, s, r) { void 0 === e && (e = !1), void 0 === i && (i = 1), void 0 === n && (n = i), void 0 === s && (s = 0), void 0 === r && (r = s), this._follow = t, this.roundPixels = e, i = o(i, 0, 1), n = o(n, 0, 1), this.lerp.set(i, n), this.followOffset.set(s, r); const a = this.width / 2; const h = this.height / 2; const l = t.x - s; const u = t.y - r; return this.midPoint.set(l, u), this.scrollX = l - a, this.scrollY = u - h, this; }, stopFollow() { return this._follow = null, this; }, resetFX() { return this.panEffect.reset(), this.shakeEffect.reset(), this.flashEffect.reset(), this.fadeEffect.reset(), this; }, update(t, e) { this.visible && (this.panEffect.update(t, e), this.zoomEffect.update(t, e), this.shakeEffect.update(t, e), this.flashEffect.update(t, e), this.fadeEffect.update(t, e)); }, destroy() { this.clearRenderToTexture(), this.resetFX(), n.prototype.destroy.call(this), this._follow = null, this.deadzone = null; },
  }); t.exports = f;
}, function (t, e, i) { const n = i(380); const s = new (i(0))({ initialize(t) { this.game = t, this.binary = new n(), this.bitmapFont = new n(), this.json = new n(), this.physics = new n(), this.shader = new n(), this.audio = new n(), this.text = new n(), this.html = new n(), this.obj = new n(), this.tilemap = new n(), this.xml = new n(), this.custom = {}, this.game.events.once('destroy', this.destroy, this); }, addCustom(t) { return this.custom.hasOwnProperty(t) || (this.custom[t] = new n()), this.custom[t]; }, destroy() { for (let t = ['binary', 'bitmapFont', 'json', 'physics', 'shader', 'audio', 'text', 'html', 'obj', 'tilemap', 'xml'], e = 0; e < t.length; e++) this[t[e]].destroy(), this[t[e]] = null; for (const i in this.custom) this.custom[i].destroy(); this.custom = null, this.game = null; } }); t.exports = s; }, function (t, e, i) {
  const n = i(0); const s = i(180); const r = i(11); const o = new n({
    initialize() { this.entries = new s(), this.events = new r(); }, add(t, e) { return this.entries.set(t, e), this.events.emit('add', this, t, e), this; }, has(t) { return this.entries.has(t); }, exists(t) { return this.entries.has(t); }, get(t) { return this.entries.get(t); }, remove(t) { const e = this.get(t); return e && (this.entries.delete(t), this.events.emit('remove', this, t, e.data)), this; }, destroy() { this.entries.clear(), this.events.removeAllListeners(), this.entries = null, this.events = null; },
  }); t.exports = o;
}, function (t, e, i) {
  const n = i(384); const s = i(0); const r = i(180); const o = i(11); const a = i(4); const h = i(179); const l = new s({
    Extends: o, initialize(t) { o.call(this), this.game = t, this.textureManager = null, this.globalTimeScale = 1, this.anims = new r(), this.paused = !1, this.name = 'AnimationManager', t.events.once('boot', this.boot, this); }, boot() { this.textureManager = this.game.textures, this.game.events.once('destroy', this.destroy, this); }, add(t, e) { if (!this.anims.has(t)) return e.key = t, this.anims.set(t, e), this.emit('add', t, e), this; console.warn('Animation with key', t, 'already exists'); }, create(t) { const e = t.key; if (e && !this.anims.has(e)) { const i = new n(this, e, t); return this.anims.set(e, i), this.emit('add', e, i), i; }console.warn(`Invalid Animation Key, or Key already in use: ${e}`); }, fromJSON(t, e) { void 0 === e && (e = !1), e && this.anims.clear(), typeof t === 'string' && (t = JSON.parse(t)); const i = []; if (t.hasOwnProperty('anims') && Array.isArray(t.anims)) { for (let n = 0; n < t.anims.length; n++)i.push(this.create(t.anims[n])); t.hasOwnProperty('globalTimeScale') && (this.globalTimeScale = t.globalTimeScale); } else t.hasOwnProperty('key') && t.type === 'frame' && i.push(this.create(t)); return i; }, generateFrameNames(t, e) { const i = a(e, 'prefix', ''); const n = a(e, 'start', 0); let s = a(e, 'end', 0); const r = a(e, 'suffix', ''); const o = a(e, 'zeroPad', 0); const l = a(e, 'outputArray', []); let u = a(e, 'frames', !1); const c = this.textureManager.get(t); if (!c) return l; let d; let f; const p = n < s ? 1 : -1; if (s += p, e) if (Array.isArray(u)) for (d = 0; d < u.length; d++)f = i + h(u[d], o, '0', 1) + r, c.has(f) && l.push({ key: t, frame: f }); else for (d = n; d !== s; d += p)f = i + h(d, o, '0', 1) + r, c.has(f) && l.push({ key: t, frame: f }); else for (u = c.getFrameNames(), d = 0; d < u.length; d++)l.push({ key: t, frame: u[d] }); return l; }, generateFrameNumbers(t, e) { let i; const n = a(e, 'start', 0); let s = a(e, 'end', -1); const r = a(e, 'first', !1); const o = a(e, 'outputArray', []); const h = a(e, 'frames', !1); const l = this.textureManager.get(t); if (!l) return o; if (r && l.has(r) && o.push({ key: t, frame: r }), Array.isArray(h)) for (i = 0; i < h.length; i++)l.has(h[i]) && o.push({ key: t, frame: h[i] }); else for (s === -1 && (s = l.frameTotal), i = n; i <= s; i++)l.has(i) && o.push({ key: t, frame: i }); return o; }, get(t) { return this.anims.get(t); }, load(t, e, i) { const n = this.get(e); return n && n.load(t, i), t; }, pauseAll() { return this.paused || (this.paused = !0, this.emit('pauseall')), this; }, play(t, e) { if (Array.isArray(e) || (e = [e]), this.get(t)) { for (let i = 0; i < e.length; i++)e[i].anims.play(t); return this; } }, remove(t) { const e = this.get(t); return e && (this.emit('remove', t, e), this.anims.delete(t)), e; }, resumeAll() { return this.paused && (this.paused = !1, this.emit('resumeall')), this; }, staggerPlay(t, e, i) { if (void 0 === i && (i = 0), Array.isArray(e) || (e = [e]), this.get(t)) { for (let n = 0; n < e.length; n++)e[n].anims.delayedPlay(i * n, t); return this; } }, toJSON(t) { if (void 0 !== t && t !== '') return this.anims.get(t).toJSON(); const e = { anims: [], globalTimeScale: this.globalTimeScale }; return this.anims.each((t, i) => { e.anims.push(i.toJSON()); }), e; }, destroy() { this.anims.clear(), this.textureManager = null, this.game = null; },
  }); t.exports = l;
}, function (t, e, i) { const n = new (i(0))({ initialize(t, e, i, n) { this.textureKey = t, this.textureFrame = e, this.index = i, this.frame = n, this.isFirst = !1, this.isLast = !1, this.prevFrame = null, this.nextFrame = null, this.duration = 0, this.progress = 0; }, toJSON() { return { key: this.textureKey, frame: this.textureFrame, duration: this.duration }; }, destroy() { this.frame = void 0; } }); t.exports = n; }, function (t, e) { t.exports = function (t, e, i) { if (!e.length) return NaN; if (e.length === 1) return e[0]; let n; let s; let r = 1; if (i) { if (t < e[0][i]) return e[0]; for (;e[r][i] < t;)r++; } else for (;e[r] < t;)r++; return r > e.length && (r = e.length), i ? (n = e[r - 1][i], (s = e[r][i]) - t <= t - n ? e[r] : e[r - 1]) : (n = e[r - 1], (s = e[r]) - t <= t - n ? s : n); }; }, function (t, e, i) {
  const n = i(23); const s = i(0); const r = i(383); const o = i(382); const a = i(4); const h = new s({
    initialize(t, e, i) { this.manager = t, this.key = e, this.type = 'frame', this.frames = this.getFrames(t.textureManager, a(i, 'frames', []), a(i, 'defaultTextureKey', null)), this.frameRate = a(i, 'frameRate', null), this.duration = a(i, 'duration', null), this.duration === null && this.frameRate === null ? (this.frameRate = 24, this.duration = this.frameRate / this.frames.length * 1e3) : this.duration && this.frameRate === null ? this.frameRate = this.frames.length / (this.duration / 1e3) : this.duration = this.frames.length / this.frameRate * 1e3, this.msPerFrame = 1e3 / this.frameRate, this.skipMissedFrames = a(i, 'skipMissedFrames', !0), this.delay = a(i, 'delay', 0), this.repeat = a(i, 'repeat', 0), this.repeatDelay = a(i, 'repeatDelay', 0), this.yoyo = a(i, 'yoyo', !1), this.showOnStart = a(i, 'showOnStart', !1), this.hideOnComplete = a(i, 'hideOnComplete', !1), this.paused = !1, this.manager.on('pauseall', this.pause, this), this.manager.on('resumeall', this.resume, this); },
    addFrame(t) { return this.addFrameAt(this.frames.length, t); },
    addFrameAt(t, e) { const i = this.getFrames(this.manager.textureManager, e); if (i.length > 0) { if (t === 0) this.frames = i.concat(this.frames); else if (t === this.frames.length) this.frames = this.frames.concat(i); else { const n = this.frames.slice(0, t); const s = this.frames.slice(t); this.frames = n.concat(i, s); } this.updateFrameSequence(); } return this; },
    checkFrame(t) { return t >= 0 && t < this.frames.length; },
    completeAnimation(t) { this.hideOnComplete && (t.parent.visible = !1), t.stop(); },
    getFirstTick(t, e) { void 0 === e && (e = !0), t.accumulator = 0, t.nextTick = t.msPerFrame + t.currentFrame.duration, e && (t.nextTick += t._delay); },
    getFrameAt(t) { return this.frames[t]; },
    getFrames(t, e, i) { let n; let s; let r; let h; const l = []; let u = 1; if (typeof e === 'string') { h = e; const c = t.get(h).getFrameNames(); e = [], c.forEach((t, i) => { e.push({ key: h, frame: i }); }); } if (!Array.isArray(e) || e.length === 0) return l; for (r = 0; r < e.length; r++) { const d = e[r]; const f = a(d, 'key', i); if (f) { const p = a(d, 'frame', 0); const g = t.getFrame(f, p); (s = new o(f, p, u, g)).duration = a(d, 'duration', 0), s.isFirst = !n, n && (n.nextFrame = s, s.prevFrame = n), l.push(s), n = s, u++; } } if (l.length > 0) { s.isLast = !0, s.nextFrame = l[0], l[0].prevFrame = s; const v = 1 / (l.length - 1); for (r = 0; r < l.length; r++)l[r].progress = r * v; } return l; },
    getNextTick(t) { t.accumulator -= t.nextTick, t.nextTick = t.msPerFrame + t.currentFrame.duration; },
    load(t, e) { e >= this.frames.length && (e = 0), t.currentAnim !== this && (t.currentAnim = this, t.frameRate = this.frameRate, t.duration = this.duration, t.msPerFrame = this.msPerFrame, t.skipMissedFrames = this.skipMissedFrames, t._delay = this.delay, t._repeat = this.repeat, t._repeatDelay = this.repeatDelay, t._yoyo = this.yoyo); let i = this.frames[e]; e !== 0 || t.forward || (i = this.getLastFrame()), t.updateFrame(i); },
    getFrameByProgress(t) { return t = n(t, 0, 1), r(t, this.frames, 'progress'); },
    nextFrame(t) { const e = t.currentFrame; e.isLast ? t._yoyo ? this.handleYoyoFrame(t, !1) : t.repeatCounter > 0 ? t._reverse && t.forward ? t.forward = !1 : this.repeatAnimation(t) : this.completeAnimation(t) : this.updateAndGetNextTick(t, e.nextFrame); },
    handleYoyoFrame(t, e) { if (e || (e = !1), t._reverse === !e && t.repeatCounter > 0) return t.forward = e, void this.repeatAnimation(t); if (t._reverse === e || t.repeatCounter !== 0) { t.forward = e; const i = e ? t.currentFrame.nextFrame : t.currentFrame.prevFrame; this.updateAndGetNextTick(t, i); } else this.completeAnimation(t); },
    getLastFrame() { return this.frames[this.frames.length - 1]; },
    previousFrame(t) { const e = t.currentFrame; e.isFirst ? t._yoyo ? this.handleYoyoFrame(t, !0) : t.repeatCounter > 0 ? t._reverse && !t.forward ? (t.currentFrame = this.getLastFrame(), this.repeatAnimation(t)) : (t.forward = !0, this.repeatAnimation(t)) : this.completeAnimation(t) : this.updateAndGetNextTick(t, e.prevFrame); },
    updateAndGetNextTick(t, e) { t.updateFrame(e), this.getNextTick(t); },
    removeFrame(t) { const e = this.frames.indexOf(t); return e !== -1 && this.removeFrameAt(e), this; },
    removeFrameAt(t) { return this.frames.splice(t, 1), this.updateFrameSequence(), this; },
    repeatAnimation(t) { if (t._pendingStop === 2) return this.completeAnimation(t); t._repeatDelay > 0 && !1 === t.pendingRepeat ? (t.pendingRepeat = !0, t.accumulator -= t.nextTick, t.nextTick += t._repeatDelay) : (t.repeatCounter--, t.updateFrame(t.currentFrame[t.forward ? 'nextFrame' : 'prevFrame']), t.isPlaying && (this.getNextTick(t), t.pendingRepeat = !1, t.parent.emit('animationrepeat', this, t.currentFrame, t.repeatCounter, t.parent))); },
    setFrame(t) { t.forward ? this.nextFrame(t) : this.previousFrame(t); },
    toJSON() {
      const t = {
        key: this.key, type: this.type, frames: [], frameRate: this.frameRate, duration: this.duration, skipMissedFrames: this.skipMissedFrames, delay: this.delay, repeat: this.repeat, repeatDelay: this.repeatDelay, yoyo: this.yoyo, showOnStart: this.showOnStart, hideOnComplete: this.hideOnComplete,
      }; return this.frames.forEach((e) => { t.frames.push(e.toJSON()); }), t;
    },
    updateFrameSequence() { for (let t = this.frames.length, e = 1 / (t - 1), i = 0; i < t; i++) { const n = this.frames[i]; n.index = i + 1, n.isFirst = !1, n.isLast = !1, n.progress = i * e, i === 0 ? (n.isFirst = !0, n.isLast = t === 1, n.prevFrame = this.frames[t - 1], n.nextFrame = this.frames[i + 1]) : i === t - 1 ? (n.isLast = !0, n.prevFrame = this.frames[t - 2], n.nextFrame = this.frames[0]) : t > 1 && (n.prevFrame = this.frames[i - 1], n.nextFrame = this.frames[i + 1]); } return this; },
    pause() { return this.paused = !0, this; },
    resume() { return this.paused = !1, this; },
    destroy() { this.manager.off('pauseall', this.pause, this), this.manager.off('resumeall', this.resume, this), this.manager.remove(this.key); for (let t = 0; t < this.frames.length; t++) this.frames[t].destroy(); this.frames = [], this.manager = null; },
  }); t.exports = h;
}, function (t, e) { t.exports = function (t, e, i) { void 0 === e && (e = 1), void 0 === i && (i = []); let n = Math.round(t.x1); let s = Math.round(t.y1); const r = Math.round(t.x2); const o = Math.round(t.y2); const a = Math.abs(r - n); const h = Math.abs(o - s); const l = n < r ? 1 : -1; const u = s < o ? 1 : -1; let c = a - h; i.push({ x: n, y: s }); for (let d = 1; n !== r || s !== o;) { const f = c << 1; f > -h && (c -= h, n += l), f < a && (c += a, s += u), d % e == 0 && i.push({ x: n, y: s }), d++; } return i; }; }, function (t, e) { t.exports = function (t, e) { void 0 === e && (e = 1); for (var i = null, n = 0; n < e; n++)i = t.pop(), t.unshift(i); return i; }; }, function (t, e) { t.exports = function (t, e) { void 0 === e && (e = 1); for (var i = null, n = 0; n < e; n++)i = t.shift(), t.push(i); return i; }; }, function (t, e, i) { const n = i(124); const s = i(6); t.exports = function (t, e, i, r) { if (void 0 === r && (r = []), !e && !i) return r; e ? i = Math.round(n(t) / e) : e = n(t) / i; for (let o = t.x, a = t.y, h = 0, l = 0; l < i; l++) switch (r.push(new s(o, a)), h) { case 0: (o += e) >= t.right && (h = 1, a += o - t.right, o = t.right); break; case 1: (a += e) >= t.bottom && (h = 2, o -= a - t.bottom, a = t.bottom); break; case 2: (o -= e) <= t.left && (h = 3, a -= t.left - o, o = t.left); break; case 3: (a -= e) <= t.top && (h = 0, a = t.top); } return r; }; }, function (t, e) { const i = { _visible: !0, visible: { get() { return this._visible; }, set(t) { t ? (this._visible = !0, this.renderFlags |= 1) : (this._visible = !1, this.renderFlags &= -2); } }, setVisible(t) { return this.visible = t, this; } }; t.exports = i; }, function (t, e, i) {
  const n = i(16); const s = i(38); const r = i(199); const o = i(198); const a = {
    _scaleX: 1, _scaleY: 1, _rotation: 0, x: 0, y: 0, z: 0, w: 0, scaleX: { get() { return this._scaleX; }, set(t) { this._scaleX = t, this._scaleX === 0 ? this.renderFlags &= -5 : this.renderFlags |= 4; } }, scaleY: { get() { return this._scaleY; }, set(t) { this._scaleY = t, this._scaleY === 0 ? this.renderFlags &= -5 : this.renderFlags |= 4; } }, angle: { get() { return o(this._rotation * n.RAD_TO_DEG); }, set(t) { this.rotation = o(t) * n.DEG_TO_RAD; } }, rotation: { get() { return this._rotation; }, set(t) { this._rotation = r(t); } }, setPosition(t, e, i, n) { return void 0 === t && (t = 0), void 0 === e && (e = t), void 0 === i && (i = 0), void 0 === n && (n = 0), this.x = t, this.y = e, this.z = i, this.w = n, this; }, setRandomPosition(t, e, i, n) { return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = this.scene.sys.game.config.width), void 0 === n && (n = this.scene.sys.game.config.height), this.x = t + Math.random() * i, this.y = e + Math.random() * n, this; }, setRotation(t) { return void 0 === t && (t = 0), this.rotation = t, this; }, setAngle(t) { return void 0 === t && (t = 0), this.angle = t, this; }, setScale(t, e) { return void 0 === t && (t = 1), void 0 === e && (e = t), this.scaleX = t, this.scaleY = e, this; }, setX(t) { return void 0 === t && (t = 0), this.x = t, this; }, setY(t) { return void 0 === t && (t = 0), this.y = t, this; }, setZ(t) { return void 0 === t && (t = 0), this.z = t, this; }, setW(t) { return void 0 === t && (t = 0), this.w = t, this; }, getLocalTransformMatrix(t) { return void 0 === t && (t = new s()), t.applyITRS(this.x, this.y, this._rotation, this._scaleX, this._scaleY); }, getWorldTransformMatrix(t, e) { void 0 === t && (t = new s()), void 0 === e && (e = new s()); let i = this.parentContainer; if (!i) return this.getLocalTransformMatrix(t); for (t.applyITRS(this.x, this.y, this._rotation, this._scaleX, this._scaleY); i;)e.applyITRS(i.x, i.y, i._rotation, i._scaleX, i._scaleY), e.multiply(t, t), i = i.parentContainer; return t; },
  }; t.exports = a;
}, function (t, e) {
  t.exports = function (t) {
    const e = {
      name: t.name, type: t.type, x: t.x, y: t.y, depth: t.depth, scale: { x: t.scaleX, y: t.scaleY }, origin: { x: t.originX, y: t.originY }, flipX: t.flipX, flipY: t.flipY, rotation: t.rotation, alpha: t.alpha, visible: t.visible, scaleMode: t.scaleMode, blendMode: t.blendMode, textureKey: '', frameKey: '', data: {},
    }; return t.texture && (e.textureKey = t.texture.key, e.frameKey = t.frame.name), e;
  };
}, function (t, e) { const i = { scrollFactorX: 1, scrollFactorY: 1, setScrollFactor(t, e) { return void 0 === e && (e = t), this.scrollFactorX = t, this.scrollFactorY = e, this; } }; t.exports = i; }, function (t, e, i) {
  const n = new (i(0))({
    initialize(t, e) { this.geometryMask = e; }, setShape(t) { this.geometryMask = t; }, preRenderWebGL(t, e, i) { const n = t.gl; const s = this.geometryMask; t.flush(), n.enable(n.STENCIL_TEST), n.clear(n.STENCIL_BUFFER_BIT), n.colorMask(!1, !1, !1, !1), n.stencilFunc(n.NOTEQUAL, 1, 1), n.stencilOp(n.REPLACE, n.REPLACE, n.REPLACE), s.renderWebGL(t, s, 0, i), t.flush(), n.colorMask(!0, !0, !0, !0), n.stencilFunc(n.EQUAL, 1, 1), n.stencilOp(n.KEEP, n.KEEP, n.KEEP); }, postRenderWebGL(t) { const e = t.gl; t.flush(), e.disable(e.STENCIL_TEST); }, preRenderCanvas(t, e, i) { const n = this.geometryMask; t.currentContext.save(), n.renderCanvas(t, n, 0, i, null, null, !0), t.currentContext.clip(); }, postRenderCanvas(t) { t.currentContext.restore(); }, destroy() { this.geometryMask = null; },
  }); t.exports = n;
}, function (t, e, i) {
  const n = new (i(0))({
    initialize(t, e) { const i = t.sys.game.renderer; if (this.renderer = i, this.bitmapMask = e, this.maskTexture = null, this.mainTexture = null, this.dirty = !0, this.mainFramebuffer = null, this.maskFramebuffer = null, this.invertAlpha = !1, i && i.gl) { const n = i.width; const s = i.height; const r = (n & n - 1) == 0 && (s & s - 1) == 0; const o = i.gl; const a = r ? o.REPEAT : o.CLAMP_TO_EDGE; const h = o.LINEAR; this.mainTexture = i.createTexture2D(0, h, h, a, a, o.RGBA, null, n, s), this.maskTexture = i.createTexture2D(0, h, h, a, a, o.RGBA, null, n, s), this.mainFramebuffer = i.createFramebuffer(n, s, this.mainTexture, !1), this.maskFramebuffer = i.createFramebuffer(n, s, this.maskTexture, !1), i.onContextRestored(function (t) { const e = t.width; const i = t.height; const n = (e & e - 1) == 0 && (i & i - 1) == 0; const s = t.gl; const r = n ? s.REPEAT : s.CLAMP_TO_EDGE; const o = s.LINEAR; this.mainTexture = t.createTexture2D(0, o, o, r, r, s.RGBA, null, e, i), this.maskTexture = t.createTexture2D(0, o, o, r, r, s.RGBA, null, e, i), this.mainFramebuffer = t.createFramebuffer(e, i, this.mainTexture, !1), this.maskFramebuffer = t.createFramebuffer(e, i, this.maskTexture, !1); }, this); } }, setBitmap(t) { this.bitmapMask = t; }, preRenderWebGL(t, e, i) { t.pipelines.BitmapMaskPipeline.beginMask(this, e, i); }, postRenderWebGL(t) { t.pipelines.BitmapMaskPipeline.endMask(this); }, preRenderCanvas() {}, postRenderCanvas() {}, destroy() { this.bitmapMask = null; const t = this.renderer; t && t.gl && (t.deleteTexture(this.mainTexture), t.deleteTexture(this.maskTexture), t.deleteFramebuffer(this.mainFramebuffer), t.deleteFramebuffer(this.maskFramebuffer)), this.mainTexture = null, this.maskTexture = null, this.mainFramebuffer = null, this.maskFramebuffer = null, this.renderer = null; },
  }); t.exports = n;
}, function (t, e, i) {
  const n = i(394); const s = i(393); const r = {
    mask: null, setMask(t) { return this.mask = t, this; }, clearMask(t) { return void 0 === t && (t = !1), t && this.mask && this.mask.destroy(), this.mask = null, this; }, createBitmapMask(t) { return void 0 === t && this.texture && (t = this), new n(this.scene, t); }, createGeometryMask(t) { return void 0 === t && this.type === 'Graphics' && (t = this), new s(this.scene, t); },
  }; t.exports = r;
}, function (t, e) { t.exports = function (t, e, i, n) { const s = Math.cos(n); const r = Math.sin(n); const o = t.x - e; const a = t.y - i; return t.x = o * s - a * r + e, t.y = o * r + a * s + i, t; }; }, function (t, e, i) { const n = i(6); t.exports = function (t, e, i) { return void 0 === i && (i = new n()), i.x = t.x1 + (t.x2 - t.x1) * e, i.y = t.y1 + (t.y2 - t.y1) * e, i; }; }, function (t, e, i) { const n = i(190); const s = i(124); t.exports = function (t, e, i, r) { void 0 === r && (r = []), e || (e = s(t) / i); for (let o = 0; o < e; o++) { const a = o / e; r.push(n(t, a)); } return r; }; }, function (t, e) { const i = { _depth: 0, depth: { get() { return this._depth; }, set(t) { this.scene.sys.queueDepthSort(), this._depth = t; } }, setDepth(t) { return void 0 === t && (t = 0), this.depth = t, this; } }; t.exports = i; }, function (t, e, i) { const n = i(66); const s = { _blendMode: n.NORMAL, blendMode: { get() { return this._blendMode; }, set(t) { typeof t === 'string' && (t = n[t]), (t |= 0) >= -1 && (this._blendMode = t); } }, setBlendMode(t) { return this.blendMode = t, this; } }; t.exports = s; }, function (t, e, i) {
  const n = i(23); const s = {
    _alpha: 1, _alphaTL: 1, _alphaTR: 1, _alphaBL: 1, _alphaBR: 1, clearAlpha() { return this.setAlpha(1); }, setAlpha(t, e, i, s) { return void 0 === t && (t = 1), void 0 === e ? this.alpha = t : (this._alphaTL = n(t, 0, 1), this._alphaTR = n(e, 0, 1), this._alphaBL = n(i, 0, 1), this._alphaBR = n(s, 0, 1)), this; }, alpha: { get() { return this._alpha; }, set(t) { const e = n(t, 0, 1); this._alpha = e, this._alphaTL = e, this._alphaTR = e, this._alphaBL = e, this._alphaBR = e, e === 0 ? this.renderFlags &= -3 : this.renderFlags |= 2; } }, alphaTopLeft: { get() { return this._alphaTL; }, set(t) { const e = n(t, 0, 1); this._alphaTL = e, e !== 0 && (this.renderFlags |= 2); } }, alphaTopRight: { get() { return this._alphaTR; }, set(t) { const e = n(t, 0, 1); this._alphaTR = e, e !== 0 && (this.renderFlags |= 2); } }, alphaBottomLeft: { get() { return this._alphaBL; }, set(t) { const e = n(t, 0, 1); this._alphaBL = e, e !== 0 && (this.renderFlags |= 2); } }, alphaBottomRight: { get() { return this._alphaBR; }, set(t) { const e = n(t, 0, 1); this._alphaBR = e, e !== 0 && (this.renderFlags |= 2); } },
  }; t.exports = s;
}, function (t, e) { t.exports = function (t) { return Math.PI * t.radius * 2; }; }, function (t, e, i) { const n = i(402); const s = i(192); const r = i(93); const o = i(16); t.exports = function (t, e, i, a) { void 0 === a && (a = []), e || (e = n(t) / i); for (let h = 0; h < e; h++) { const l = r(h / e, 0, o.PI2); a.push(s(t, l)); } return a; }; }, function (t, e, i) {
  const n = new (i(0))({
    initialize(t) { void 0 === t && (t = [(Date.now() * Math.random()).toString()]), this.c = 1, this.s0 = 0, this.s1 = 0, this.s2 = 0, this.n = 0, this.signs = [-1, 1], t && this.init(t); }, rnd() { const t = 2091639 * this.s0 + 2.3283064365386963e-10 * this.c; return this.c = 0 | t, this.s0 = this.s1, this.s1 = this.s2, this.s2 = t - this.c, this.s2; }, hash(t) { let e; let i = this.n; t = t.toString(); for (let n = 0; n < t.length; n++)e = 0.02519603282416938 * (i += t.charCodeAt(n)), e -= i = e >>> 0, i = (e *= i) >>> 0, i += 4294967296 * (e -= i); return this.n = i, 2.3283064365386963e-10 * (i >>> 0); }, init(t) { typeof t === 'string' ? this.state(t) : this.sow(t); }, sow(t) { if (this.n = 4022871197, this.s0 = this.hash(' '), this.s1 = this.hash(' '), this.s2 = this.hash(' '), this.c = 1, t) for (let e = 0; e < t.length && t[e] != null; e++) { const i = t[e]; this.s0 -= this.hash(i), this.s0 += ~~(this.s0 < 0), this.s1 -= this.hash(i), this.s1 += ~~(this.s1 < 0), this.s2 -= this.hash(i), this.s2 += ~~(this.s2 < 0); } }, integer() { return 4294967296 * this.rnd(); }, frac() { return this.rnd() + 1.1102230246251565e-16 * (2097152 * this.rnd() | 0); }, real() { return this.integer() + this.frac(); }, integerInRange(t, e) { return Math.floor(this.realInRange(0, e - t + 1) + t); }, between(t, e) { return Math.floor(this.realInRange(0, e - t + 1) + t); }, realInRange(t, e) { return this.frac() * (e - t) + t; }, normal() { return 1 - 2 * this.frac(); }, uuid() { let t = ''; let e = ''; for (e = t = ''; t++ < 36; e += ~t % 5 | 3 * t & 4 ? (15 ^ t ? 8 ^ this.frac() * (20 ^ t ? 16 : 4) : 4).toString(16) : '-');return e; }, pick(t) { return t[this.integerInRange(0, t.length - 1)]; }, sign() { return this.pick(this.signs); }, weightedPick(t) { return t[~~(Math.pow(this.frac(), 2) * (t.length - 1) + 0.5)]; }, timestamp(t, e) { return this.realInRange(t || 9466848e5, e || 1577862e6); }, angle() { return this.integerInRange(-180, 180); }, rotation() { return this.realInRange(-3.1415926, 3.1415926); }, state(t) { return typeof t === 'string' && t.match(/^!rnd/) && (t = t.split(','), this.c = parseFloat(t[1]), this.s0 = parseFloat(t[2]), this.s1 = parseFloat(t[3]), this.s2 = parseFloat(t[4])), ['!rnd', this.c, this.s0, this.s1, this.s2].join(','); }, shuffle(t) { for (let e = t.length - 1, i = e; i > 0; i--) { const n = Math.floor(this.frac() * (e + 1)); const s = t[n]; t[n] = t[i], t[i] = s; } return t; },
  }); t.exports = n;
}, function (t, e, i) { const n = i(192); const s = i(93); const r = i(16); const o = i(6); t.exports = function (t, e, i) { void 0 === i && (i = new o()); const a = s(e, 0, r.PI2); return n(t, a, i); }; }, function (t, e, i) { const n = i(44); const s = i(42); const r = i(43); const o = i(41); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), r(t, n(e) + i), o(t, s(e) - a), t; }; }, function (t, e, i) { const n = i(46); const s = i(42); const r = i(45); const o = i(41); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), r(t, n(e) - i), o(t, s(e) - a), t; }; }, function (t, e, i) { const n = i(75); const s = i(42); const r = i(74); const o = i(41); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), r(t, n(e) + i), o(t, s(e) - a), t; }; }, function (t, e, i) { const n = i(72); const s = i(44); const r = i(73); const o = i(43); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), o(t, s(e) + i), r(t, n(e) + a), t; }; }, function (t, e, i) { const n = i(72); const s = i(46); const r = i(73); const o = i(45); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), o(t, s(e) - i), r(t, n(e) + a), t; }; }, function (t, e, i) { const n = i(74); const s = i(73); t.exports = function (t, e, i) { return n(t, e), s(t, i); }; }, function (t, e, i) { const n = i(411); const s = i(75); const r = i(72); t.exports = function (t, e, i, o) { return void 0 === i && (i = 0), void 0 === o && (o = 0), n(t, s(e) + i, r(e) + o), t; }; }, function (t, e, i) { const n = i(48); const s = i(44); const r = i(47); const o = i(43); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), o(t, s(e) + i), r(t, n(e) + a), t; }; }, function (t, e, i) { const n = i(48); const s = i(46); const r = i(47); const o = i(45); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), o(t, s(e) - i), r(t, n(e) + a), t; }; }, function (t, e, i) { const n = i(48); const s = i(75); const r = i(47); const o = i(74); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), o(t, s(e) + i), r(t, n(e) + a), t; }; }, function (t, e, i) { const n = i(193); const s = []; s[n.BOTTOM_CENTER] = i(415), s[n.BOTTOM_LEFT] = i(414), s[n.BOTTOM_RIGHT] = i(413), s[n.CENTER] = i(412), s[n.LEFT_CENTER] = i(410), s[n.RIGHT_CENTER] = i(409), s[n.TOP_CENTER] = i(408), s[n.TOP_LEFT] = i(407), s[n.TOP_RIGHT] = i(406); t.exports = function (t, e, i, n, r) { return s[i](t, e, n, r); }; }, function (t, e, i) {
  t.exports = {
    Angle: i(1050), Call: i(1049), GetFirst: i(1048), GetLast: i(1047), GridAlign: i(1046), IncAlpha: i(1035), IncX: i(1034), IncXY: i(1033), IncY: i(1032), PlaceOnCircle: i(1031), PlaceOnEllipse: i(1030), PlaceOnLine: i(1029), PlaceOnRectangle: i(1028), PlaceOnTriangle: i(1027), PlayAnimation: i(1026), PropertyValueInc: i(32), PropertyValueSet: i(25), RandomCircle: i(1025), RandomEllipse: i(1024), RandomLine: i(1023), RandomRectangle: i(1022), RandomTriangle: i(1021), Rotate: i(1020), RotateAround: i(1019), RotateAroundDistance: i(1018), ScaleX: i(1017), ScaleXY: i(1016), ScaleY: i(1015), SetAlpha: i(1014), SetBlendMode: i(1013), SetDepth: i(1012), SetHitArea: i(1011), SetOrigin: i(1010), SetRotation: i(1009), SetScale: i(1008), SetScaleX: i(1007), SetScaleY: i(1006), SetTint: i(1005), SetVisible: i(1004), SetX: i(1003), SetXY: i(1002), SetY: i(1001), ShiftPosition: i(1e3), Shuffle: i(999), SmootherStep: i(998), SmoothStep: i(997), Spread: i(996), ToggleVisible: i(995), WrapInRectangle: i(994),
  };
}, function (t, e) {
  const i = {}; t.exports = i, i.create = function (t, e) {
    const n = t.bodyA; const s = t.bodyB; const r = {
      id: i.id(n, s), bodyA: n, bodyB: s, activeContacts: [], separation: 0, isActive: !0, confirmedActive: !0, isSensor: n.isSensor || s.isSensor, timeCreated: e, timeUpdated: e, collision: null, inverseMass: 0, friction: 0, frictionStatic: 0, restitution: 0, slop: 0,
    }; return i.update(r, t, e), r;
  }, i.update = function (t, e, n) { if (t.collision = e, e.collided) { const s = e.supports; const r = t.activeContacts; const o = e.parentA; const a = e.parentB; t.inverseMass = o.inverseMass + a.inverseMass, t.friction = Math.min(o.friction, a.friction), t.frictionStatic = Math.max(o.frictionStatic, a.frictionStatic), t.restitution = Math.max(o.restitution, a.restitution), t.slop = Math.max(o.slop, a.slop); for (let h = 0; h < s.length; h++)r[h] = s[h].contact; const l = s.length; l < r.length && (r.length = l), t.separation = e.depth, i.setActive(t, !0, n); } else !0 === t.isActive && i.setActive(t, !1, n); }, i.setActive = function (t, e, i) { e ? (t.isActive = !0, t.timeUpdated = i) : (t.isActive = !1, t.activeContacts.length = 0); }, i.id = function (t, e) { return t.id < e.id ? `A${t.id}B${e.id}` : `A${e.id}B${t.id}`; };
}, function (t, e, i) {
  t.exports = {
    Bounce: i(1103), Collision: i(1102), Force: i(1101), Friction: i(1100), Gravity: i(1099), Mass: i(1098), Static: i(1097), Sensor: i(1096), SetBody: i(1095), Sleep: i(1093), Transform: i(1092), Velocity: i(1091),
  };
}, function (t, e, i) {
  const n = i(0); const s = i(895); const r = i(196); let o = 10; const a = new n({
    Extends: r, initialize(t) { o = t.maxLights, t.fragShader = s.replace('%LIGHT_COUNT%', o.toString()), r.call(this, t), this.defaultNormalMap; }, boot() { this.defaultNormalMap = this.game.textures.getFrame('__DEFAULT'); }, onBind(t) { r.prototype.onBind.call(this); const e = this.renderer; const i = this.program; return this.mvpUpdate(), e.setInt1(i, 'uNormSampler', 1), e.setFloat2(i, 'uResolution', this.width, this.height), t && this.setNormalMap(t), this; }, onRender(t, e) { this.active = !1; const i = t.sys.lights; if (!i || i.lights.length <= 0 || !i.active) return this; const n = i.cull(e); const s = Math.min(n.length, o); if (s === 0) return this; this.active = !0; let r; const a = this.renderer; const h = this.program; const l = e.matrix; const u = { x: 0, y: 0 }; const c = a.height; for (r = 0; r < o; ++r)a.setFloat1(h, `uLights[${r}].radius`, 0); for (a.setFloat4(h, 'uCamera', e.x, e.y, e.rotation, e.zoom), a.setFloat3(h, 'uAmbientLightColor', i.ambientColor.r, i.ambientColor.g, i.ambientColor.b), r = 0; r < s; ++r) { const d = n[r]; const f = `uLights[${r}].`; l.transformPoint(d.x, d.y, u), a.setFloat2(h, `${f}position`, u.x - e.scrollX * d.scrollFactorX * e.zoom, c - (u.y - e.scrollY * d.scrollFactorY * e.zoom)), a.setFloat3(h, `${f}color`, d.r, d.g, d.b), a.setFloat1(h, `${f}intensity`, d.intensity), a.setFloat1(h, `${f}radius`, d.radius); } return this; }, batchTexture(t, e, i, n, s, r, o, a, h, l, u, c, d, f, p, g, v, y, m, x, w, b, T, S, _, A, C, M, P, E) { let k; if (this.active) if (this.renderer.setPipeline(this), t.displayTexture ? k = t.displayTexture.dataSource[t.displayFrame.sourceIndex] : t.texture ? k = t.texture.dataSource[t.frame.sourceIndex] : t.tileset && (k = t.tileset.image.dataSource[0]), k) { this.setTexture2D(k.glTexture, 1); const L = this._tempMatrix1; const F = this._tempMatrix2; const R = this._tempMatrix3; let O = y / i + C; let D = m / n + M; let B = (y + x) / i + C; let I = (m + w) / n + M; let Y = o; let X = a; let z = -g; let N = -v; if (t.isCropped) { const U = t._crop; Y = U.width, X = U.height, o = U.width, a = U.height; let V = y = U.x; let G = m = U.y; c && (V = x - U.x - U.width), d && !e.isRenderTexture && (G = w - U.y - U.height), O = V / i + C, D = G / n + M, B = (V + U.width) / i + C, I = (G + U.height) / n + M, z = -g + y, N = -v + m; }d ^= e.isRenderTexture ? 1 : 0, c && (Y *= -1, z += o), d && (X *= -1, N += a); const W = z + Y; const H = N + X; F.applyITRS(s, r, u, h, l), L.copyFrom(P.matrix), E ? (L.multiplyWithOffset(E, -P.scrollX * f, -P.scrollY * p), F.e = s, F.f = r, L.multiply(F, R)) : (F.e -= P.scrollX * f, F.f -= P.scrollY * p, L.multiply(F, R)); let j = R.getX(z, N); let q = R.getY(z, N); let K = R.getX(z, H); let J = R.getY(z, H); let Z = R.getX(W, H); let Q = R.getY(W, H); let $ = R.getX(W, N); let tt = R.getY(W, N); P.roundPixels && (j |= 0, q |= 0, K |= 0, J |= 0, Z |= 0, Q |= 0, $ |= 0, tt |= 0), this.setTexture2D(e, 0), this.batchQuad(j, q, K, J, Z, Q, $, tt, O, D, B, I, b, T, S, _, A); } else console.warn('Normal map missing or invalid'); }, setNormalMap(t) { let e; this.active && t && (t.texture && (e = t.texture.dataSource[t.frame.sourceIndex]), e || (e = this.defaultNormalMap), this.setTexture2D(e.glTexture, 1), this.renderer.setPipeline(t.defaultPipeline)); }, batchSprite(t, e, i) { if (this.active) { const n = t.texture.dataSource[t.frame.sourceIndex]; n && (this.renderer.setPipeline(this), this.setTexture2D(n.glTexture, 1), r.prototype.batchSprite.call(this, t, e, i)); } },
  }); a.LIGHT_COUNT = o, t.exports = a;
}, function (t, e, i) {
  const n = i(0); const s = i(897); const r = i(896); const o = i(197); const a = new n({
    Extends: o,
    initialize(t) {
      o.call(this, {
        game: t.game,
        renderer: t.renderer,
        gl: t.renderer.gl,
        topology: t.topology ? t.topology : t.renderer.gl.TRIANGLES,
        vertShader: t.vertShader ? t.vertShader : r,
        fragShader: t.fragShader ? t.fragShader : s,
        vertexCapacity: t.vertexCapacity ? t.vertexCapacity : 3,
        vertexSize: t.vertexSize ? t.vertexSize : 2 * Float32Array.BYTES_PER_ELEMENT,
        vertices: new Float32Array([-1, 1, -1, -7, 7, 1]).buffer,
        attributes: [{
          name: 'inPosition', size: 2, type: t.renderer.gl.FLOAT, normalized: !1, offset: 0,
        }],
      }), this.vertexViewF32 = new Float32Array(this.vertexData), this.maxQuads = 1, this.resolutionDirty = !0;
    },
    onBind() { o.prototype.onBind.call(this); const t = this.renderer; const e = this.program; return this.resolutionDirty && (t.setFloat2(e, 'uResolution', this.width, this.height), t.setInt1(e, 'uMainSampler', 0), t.setInt1(e, 'uMaskSampler', 1), this.resolutionDirty = !1), this; },
    resize(t, e, i) { return o.prototype.resize.call(this, t, e, i), this.resolutionDirty = !0, this; },
    beginMask(t, e, i) { const n = this.renderer; const s = this.gl; const r = t.bitmapMask; r && s && (n.flush(), n.setFramebuffer(t.maskFramebuffer), s.clearColor(0, 0, 0, 0), s.clear(s.COLOR_BUFFER_BIT), r.renderWebGL(n, r, 0, i), n.flush(), n.setFramebuffer(t.mainFramebuffer), s.clearColor(0, 0, 0, 0), s.clear(s.COLOR_BUFFER_BIT)); },
    endMask(t) { const e = this.renderer; const i = this.gl; t.bitmapMask && i && (e.setFramebuffer(null), e.setPipeline(this), e.setTexture2D(t.maskTexture, 1), e.setTexture2D(t.mainTexture, 0), e.setInt1(this.program, 'uInvertMaskAlpha', t.invertAlpha), i.drawArrays(this.topology, 0, 3)); },
  }); t.exports = a;
}, function (t, e) { t.exports = function (t, e, i) { e || (e = 'image/png'), i || (i = 0.92); const n = t.getContext('experimental-webgl'); const s = new Uint8Array(n.drawingBufferWidth * n.drawingBufferHeight * 4); n.readPixels(0, 0, n.drawingBufferWidth, n.drawingBufferHeight, n.RGBA, n.UNSIGNED_BYTE, s); let r; const o = document.createElement('canvas'); const a = o.getContext('2d'); o.width = n.drawingBufferWidth, o.height = n.drawingBufferHeight; for (let h = (r = a.getImageData(0, 0, o.width, o.height)).data, l = 0; l < o.height; l += 1) for (let u = 0; u < o.width; u += 1) { const c = 4 * ((o.height - l) * o.width + u); const d = 4 * (l * o.width + u); h[d + 0] = s[c + 0], h[d + 1] = s[c + 1], h[d + 2] = s[c + 2], h[d + 3] = s[c + 3]; }a.putImageData(r, 0, 0); const f = o.toDataURL(e, i); const p = new Image(); return p.src = f, p; }; }, function (t, e, i) {
  const n = i(121); const s = i(0); const r = i(26); const o = i(117); const a = i(91); const h = i(38); const l = i(10); const u = i(422); const c = i(421); const d = i(420); const f = i(196); const p = new s({
    initialize(t) {
      const e = this; const i = t.config; const s = {
        alpha: i.transparent, depth: !1, antialias: i.antialias, premultipliedAlpha: i.premultipliedAlpha, stencil: !0, preserveDrawingBuffer: i.preserveDrawingBuffer, failIfMajorPerformanceCaveat: i.failIfMajorPerformanceCaveat, powerPreference: i.powerPreference,
      }; this.config = {
        clearBeforeRender: i.clearBeforeRender, antialias: i.antialias, backgroundColor: i.backgroundColor, contextCreation: s, resolution: i.resolution, autoResize: i.autoResize, roundPixels: i.roundPixels, maxTextures: i.maxTextures, maxTextureSize: i.maxTextureSize, batchSize: i.batchSize, maxLights: i.maxLights,
      }, this.game = t, this.type = r.WEBGL, this.width = t.config.width, this.height = t.config.height, this.canvas = t.canvas, this.lostContextCallbacks = [], this.restoredContextCallbacks = [], this.blendModes = [], this.nativeTextures = [], this.contextLost = !1, this.pipelines = null, this.snapshotState = { callback: null, type: null, encoder: null }, this.currentActiveTextureUnit = 0, this.currentTextures = new Array(16), this.currentFramebuffer = null, this.currentPipeline = null, this.currentProgram = null, this.currentVertexBuffer = null, this.currentIndexBuffer = null, this.currentBlendMode = 1 / 0, this.currentScissorEnabled = !1, this.currentScissor = null, this.scissorStack = [], this.canvas.addEventListener('webglcontextlost', (t) => { e.contextLost = !0, t.preventDefault(); for (let i = 0; i < e.lostContextCallbacks.length; ++i) { const n = e.lostContextCallbacks[i]; n[0].call(n[1], e); } }, !1), this.canvas.addEventListener('webglcontextrestored', () => { e.contextLost = !1, e.init(e.config); for (let t = 0; t < e.restoredContextCallbacks.length; ++t) { const i = e.restoredContextCallbacks[t]; i[0].call(i[1], e); } }, !1), this.gl = null, this.supportedExtensions = null, this.extensions = {}, this.glFormats = [], this.compression = { ETC1: !1, PVRTC: !1, S3TC: !1 }, this.drawingBufferHeight = 0, this.blankTexture = null, this.defaultCamera = new n(0, 0, 0, 0), this._tempMatrix1 = new h(), this._tempMatrix2 = new h(), this._tempMatrix3 = new h(), this._tempMatrix4 = new h(), this.init(this.config);
    },
    init(t) { let e; const i = this.canvas; const n = t.backgroundColor; if (!(e = this.game.config.context ? this.game.config.context : i.getContext('webgl', t.contextCreation) || i.getContext('experimental-webgl', t.contextCreation)) || e.isContextLost()) throw this.contextLost = !0, new Error('WebGL unsupported'); this.gl = e, this.game.context = e; for (let s = 0; s <= 16; s++) this.blendModes.push({ func: [e.ONE, e.ONE_MINUS_SRC_ALPHA], equation: e.FUNC_ADD }); this.blendModes[1].func = [e.ONE, e.DST_ALPHA], this.blendModes[2].func = [e.DST_COLOR, e.ONE_MINUS_SRC_ALPHA], this.blendModes[3].func = [e.ONE, e.ONE_MINUS_SRC_COLOR], this.glFormats[0] = e.BYTE, this.glFormats[1] = e.SHORT, this.glFormats[2] = e.UNSIGNED_BYTE, this.glFormats[3] = e.UNSIGNED_SHORT, this.glFormats[4] = e.FLOAT; const o = e.getSupportedExtensions(); t.maxTextures || (t.maxTextures = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)), t.maxTextureSize || (t.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE)); const a = 'WEBGL_compressed_texture_'; const h = `WEBKIT_${a}`; this.compression.ETC1 = e.getExtension(`${a}etc1`) || e.getExtension(`${h}etc1`), this.compression.PVRTC = e.getExtension(`${a}pvrtc`) || e.getExtension(`${h}pvrtc`), this.compression.S3TC = e.getExtension(`${a}s3tc`) || e.getExtension(`${h}s3tc`), this.supportedExtensions = o, e.disable(e.DEPTH_TEST), e.disable(e.CULL_FACE), e.enable(e.BLEND), e.clearColor(n.redGL, n.greenGL, n.blueGL, 1); for (let l = 0; l < this.currentTextures.length; ++l) this.currentTextures[l] = null; return this.pipelines = {}, this.addPipeline('TextureTintPipeline', new f({ game: this.game, renderer: this })), this.addPipeline('BitmapMaskPipeline', new c({ game: this.game, renderer: this })), this.addPipeline('Light2D', new d({ game: this.game, renderer: this, maxLights: t.maxLights })), this.setBlendMode(r.BlendModes.NORMAL), this.resize(this.width, this.height), this.game.events.once('texturesready', this.boot, this), this; },
    boot() { for (const t in this.pipelines) this.pipelines[t].boot(); const e = this.game.textures.getFrame('__DEFAULT'); this.pipelines.TextureTintPipeline.currentFrame = e, this.blankTexture = e; },
    resize(t, e) { const i = this.gl; const n = this.pipelines; const s = this.config.resolution; for (const r in this.width = Math.floor(t * s), this.height = Math.floor(e * s), this.canvas.width = this.width, this.canvas.height = this.height, this.config.autoResize && (this.canvas.style.width = `${this.width / s}px`, this.canvas.style.height = `${this.height / s}px`), i.viewport(0, 0, this.width, this.height), n)n[r].resize(t, e, s); return this.drawingBufferHeight = i.drawingBufferHeight, this.defaultCamera.setSize(t, e), i.scissor(0, this.drawingBufferHeight - this.height, this.width, this.height), this; },
    onContextRestored(t, e) { return this.restoredContextCallbacks.push([t, e]), this; },
    onContextLost(t, e) { return this.lostContextCallbacks.push([t, e]), this; },
    hasExtension(t) { return !!this.supportedExtensions && this.supportedExtensions.indexOf(t); },
    getExtension(t) { return this.hasExtension(t) ? (t in this.extensions || (this.extensions[t] = this.gl.getExtension(t)), this.extensions[t]) : null; },
    flush() { this.currentPipeline && this.currentPipeline.flush(); },
    hasPipeline(t) { return t in this.pipelines; },
    getPipeline(t) { return this.hasPipeline(t) ? this.pipelines[t] : null; },
    removePipeline(t) { return delete this.pipelines[t], this; },
    addPipeline(t, e) { return this.hasPipeline(t) ? console.warn(`Pipeline exists: ${t}`) : this.pipelines[t] = e, e.name = t, this.pipelines[t].resize(this.width, this.height, this.config.resolution), e; },
    pushScissor(t, e, i, n) { const s = [t, e, i, n]; return this.scissorStack.push(s), this.setScissor(t, e, i, n), this.currentScissor = s, s; },
    setScissor(t, e, i, n) { const s = this.gl; const r = this.currentScissor; const o = r[0]; const a = r[1]; const h = r[2]; const l = r[3]; o === t && a === e && h === i && l === n || (this.flush(), i > 0 && n > 0 && s.scissor(t, this.drawingBufferHeight - e - n, i, n)); },
    popScissor() { const t = this.scissorStack; t.pop(); const e = t[t.length - 1]; e && this.setScissor(e[0], e[1], e[2], e[3]), this.currentScissor = e; },
    setPipeline(t, e) { return this.currentPipeline === t && this.currentPipeline.vertexBuffer === this.currentVertexBuffer && this.currentPipeline.program === this.currentProgram || (this.flush(), this.currentPipeline = t, this.currentPipeline.bind()), this.currentPipeline.onBind(e), this.currentPipeline; },
    setBlendMode(t) { const e = this.gl; const i = this.blendModes[t]; return t !== r.BlendModes.SKIP_CHECK && this.currentBlendMode !== t && (this.flush(), e.enable(e.BLEND), e.blendEquation(i.equation), i.func.length > 2 ? e.blendFuncSeparate(i.func[0], i.func[1], i.func[2], i.func[3]) : e.blendFunc(i.func[0], i.func[1]), this.currentBlendMode = t, !0); },
    addBlendMode(t, e) { return this.blendModes.push({ func: t, equation: e }) - 1; },
    updateBlendMode(t, e, i) { return this.blendModes[t] && (this.blendModes[t].func = e, i && (this.blendModes[t].equation = i)), this; },
    removeBlendMode(t) { return t > 16 && this.blendModes[t] && this.blendModes.splice(t, 1), this; },
    setBlankTexture(t) { void 0 === t && (t = !1), !t && this.currentActiveTextureUnit === 0 && this.currentTextures[0] || this.setTexture2D(this.blankTexture.glTexture, 0); },
    setTexture2D(t, e) { const i = this.gl; return t !== this.currentTextures[e] && (this.flush(), this.currentActiveTextureUnit !== e && (i.activeTexture(i.TEXTURE0 + e), this.currentActiveTextureUnit = e), i.bindTexture(i.TEXTURE_2D, t), this.currentTextures[e] = t), this; },
    setFramebuffer(t) { const e = this.gl; let i = this.width; let n = this.height; return t !== this.currentFramebuffer && (t && t.renderTexture ? (i = t.renderTexture.width, n = t.renderTexture.height) : this.flush(), e.bindFramebuffer(e.FRAMEBUFFER, t), e.viewport(0, 0, i, n), this.currentFramebuffer = t), this; },
    setProgram(t) { const e = this.gl; return t !== this.currentProgram && (this.flush(), e.useProgram(t), this.currentProgram = t), this; },
    setVertexBuffer(t) { const e = this.gl; return t !== this.currentVertexBuffer && (this.flush(), e.bindBuffer(e.ARRAY_BUFFER, t), this.currentVertexBuffer = t), this; },
    setIndexBuffer(t) { const e = this.gl; return t !== this.currentIndexBuffer && (this.flush(), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, t), this.currentIndexBuffer = t), this; },
    createTextureFromSource(t, e, i, n) { const s = this.gl; let a = s.NEAREST; let h = s.CLAMP_TO_EDGE; return e = t ? t.width : e, i = t ? t.height : i, o(e, i) && (h = s.REPEAT), n === r.ScaleModes.LINEAR && this.config.antialias && (a = s.LINEAR), t || typeof e !== 'number' || typeof i !== 'number' ? this.createTexture2D(0, a, a, h, h, s.RGBA, t) : this.createTexture2D(0, a, a, h, h, s.RGBA, null, e, i); },
    createTexture2D(t, e, i, n, s, r, o, a, h, l) { l = void 0 === l || l === null || l; const u = this.gl; const c = u.createTexture(); return this.setTexture2D(c, 0), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_MIN_FILTER, e), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_MAG_FILTER, i), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_WRAP_S, s), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_WRAP_T, n), u.pixelStorei(u.UNPACK_PREMULTIPLY_ALPHA_WEBGL, l), o === null || void 0 === o ? u.texImage2D(u.TEXTURE_2D, t, r, a, h, 0, r, u.UNSIGNED_BYTE, null) : (u.texImage2D(u.TEXTURE_2D, t, r, r, u.UNSIGNED_BYTE, o), a = o.width, h = o.height), this.setTexture2D(null, 0), c.isAlphaPremultiplied = l, c.isRenderTexture = !1, c.width = a, c.height = h, this.nativeTextures.push(c), c; },
    createFramebuffer(t, e, i, n) {
      let s; const r = this.gl; const o = r.createFramebuffer(); if (this.setFramebuffer(o), n) { const a = r.createRenderbuffer(); r.bindRenderbuffer(r.RENDERBUFFER, a), r.renderbufferStorage(r.RENDERBUFFER, r.DEPTH_STENCIL, t, e), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.RENDERBUFFER, a); } if (i.isRenderTexture = !0, i.isAlphaPremultiplied = !1, r.framebufferTexture2D(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, i, 0), (s = r.checkFramebufferStatus(r.FRAMEBUFFER)) !== r.FRAMEBUFFER_COMPLETE) {
        throw new Error(`Framebuffer incomplete. Framebuffer status: ${{
          36054: 'Incomplete Attachment', 36055: 'Missing Attachment', 36057: 'Incomplete Dimensions', 36061: 'Framebuffer Unsupported',
        }[s]}`);
      } return o.renderTexture = i, this.setFramebuffer(null), o;
    },
    createProgram(t, e) { const i = this.gl; const n = i.createProgram(); const s = i.createShader(i.VERTEX_SHADER); const r = i.createShader(i.FRAGMENT_SHADER); if (i.shaderSource(s, t), i.shaderSource(r, e), i.compileShader(s), i.compileShader(r), !i.getShaderParameter(s, i.COMPILE_STATUS)) throw new Error(`Failed to compile Vertex Shader:\n${i.getShaderInfoLog(s)}`); if (!i.getShaderParameter(r, i.COMPILE_STATUS)) throw new Error(`Failed to compile Fragment Shader:\n${i.getShaderInfoLog(r)}`); if (i.attachShader(n, s), i.attachShader(n, r), i.linkProgram(n), !i.getProgramParameter(n, i.LINK_STATUS)) throw new Error(`Failed to link program:\n${i.getProgramInfoLog(n)}`); return n; },
    createVertexBuffer(t, e) { const i = this.gl; const n = i.createBuffer(); return this.setVertexBuffer(n), i.bufferData(i.ARRAY_BUFFER, t, e), this.setVertexBuffer(null), n; },
    createIndexBuffer(t, e) { const i = this.gl; const n = i.createBuffer(); return this.setIndexBuffer(n), i.bufferData(i.ELEMENT_ARRAY_BUFFER, t, e), this.setIndexBuffer(null), n; },
    deleteTexture(t) { const e = this.nativeTextures.indexOf(t); return e !== -1 && a(this.nativeTextures, e), this.gl.deleteTexture(t), this.currentTextures[0] === t && this.setBlankTexture(!0), this; },
    deleteFramebuffer(t) { return this.gl.deleteFramebuffer(t), this; },
    deleteProgram(t) { return this.gl.deleteProgram(t), this; },
    deleteBuffer(t) { return this.gl.deleteBuffer(t), this; },
    preRenderCamera(t) { const e = t._cx; const i = t._cy; const n = t._cw; const s = t._ch; const r = this.pipelines.TextureTintPipeline; const o = t.backgroundColor; if (t.renderToTexture) { this.flush(), this.pushScissor(e, i, n, -s), this.setFramebuffer(t.framebuffer); const a = this.gl; a.clearColor(0, 0, 0, 0), a.clear(a.COLOR_BUFFER_BIT), r.projOrtho(e, n + e, i, s + i, -1e3, 1e3), o.alphaGL > 0 && r.drawFillRect(e, i, n + e, s + i, l.getTintFromFloats(o.redGL, o.greenGL, o.blueGL, 1), o.alphaGL), t.emit('prerender', t); } else this.pushScissor(e, i, n, s), o.alphaGL > 0 && r.drawFillRect(e, i, n, s, l.getTintFromFloats(o.redGL, o.greenGL, o.blueGL, 1), o.alphaGL); },
    postRenderCamera(t) { const e = this.pipelines.TextureTintPipeline; if (t.flashEffect.postRenderWebGL(e, l.getTintFromFloats), t.fadeEffect.postRenderWebGL(e, l.getTintFromFloats), t.dirty = !1, this.popScissor(), t.renderToTexture) { e.flush(), this.setFramebuffer(null), t.emit('postrender', t), e.projOrtho(0, e.width, e.height, 0, -1e3, 1e3); const i = l.getTintAppendFloatAlpha; (t.pipeline ? t.pipeline : e).batchTexture(t, t.glTexture, t.width, t.height, t.x, t.y, t.width, t.height, t.zoom, t.zoom, t.rotation, t.flipX, !t.flipY, 1, 1, 0, 0, 0, 0, t.width, t.height, i(t._tintTL, t._alphaTL), i(t._tintTR, t._alphaTR), i(t._tintBL, t._alphaBL), i(t._tintBR, t._alphaBR), t._isTinted && t.tintFill, 0, 0, this.defaultCamera, null), this.setBlankTexture(!0); } },
    preRender() { if (!this.contextLost) { const t = this.gl; const e = this.config.backgroundColor; const i = this.pipelines; for (const n in this.config.clearBeforeRender && (t.clearColor(e.redGL, e.greenGL, e.blueGL, e.alphaGL), t.clear(t.COLOR_BUFFER_BIT | t.DEPTH_BUFFER_BIT | t.STENCIL_BUFFER_BIT)), t.enable(t.SCISSOR_TEST), i)i[n].onPreRender(); this.currentScissor = [0, 0, this.width, this.height], this.scissorStack = [this.currentScissor], this.game.scene.customViewports && t.scissor(0, this.drawingBufferHeight - this.height, this.width, this.height), this.setPipeline(this.pipelines.TextureTintPipeline); } },
    render(t, e, i, n) { if (!this.contextLost) { const s = e.list; const o = s.length; const a = this.pipelines; for (const h in a)a[h].onRender(t, n); this.preRenderCamera(n); for (let l = 0; l < o; l++) { const u = s[l]; if (u.willRender(n)) { u.blendMode !== this.currentBlendMode && this.setBlendMode(u.blendMode); const c = u.mask; c ? (c.preRenderWebGL(this, u, n), u.renderWebGL(this, u, i, n), c.postRenderWebGL(this, u)) : u.renderWebGL(this, u, i, n); } } this.setBlendMode(r.BlendModes.NORMAL), this.postRenderCamera(n); } },
    postRender() { if (!this.contextLost) { this.flush(), this.snapshotState.callback && (this.snapshotState.callback(u(this.canvas, this.snapshotState.type, this.snapshotState.encoder)), this.snapshotState.callback = null); const t = this.pipelines; for (const e in t)t[e].onPostRender(); } },
    snapshot(t, e, i) { return this.snapshotState.callback = t, this.snapshotState.type = e, this.snapshotState.encoder = i, this; },
    canvasToTexture(t, e, i) { void 0 === i && (i = !1); const n = this.gl; if (e) this.setTexture2D(e, 0), n.texImage2D(n.TEXTURE_2D, 0, n.RGBA, n.RGBA, n.UNSIGNED_BYTE, t), e.width = t.width, e.height = t.height, this.setTexture2D(null, 0); else { let s = n.CLAMP_TO_EDGE; !i && o(t.width, t.height) && (s = n.REPEAT), e = this.createTexture2D(0, n.NEAREST, n.NEAREST, s, s, n.RGBA, t, t.width, t.height, !0); } return e; },
    setTextureFilter(t, e) { const i = this.gl; const n = [i.LINEAR, i.NEAREST][e]; return this.setTexture2D(t, 0), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, n), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, n), this.setTexture2D(null, 0), this; },
    setFloat1(t, e, i) { return this.setProgram(t), this.gl.uniform1f(this.gl.getUniformLocation(t, e), i), this; },
    setFloat2(t, e, i, n) { return this.setProgram(t), this.gl.uniform2f(this.gl.getUniformLocation(t, e), i, n), this; },
    setFloat3(t, e, i, n, s) { return this.setProgram(t), this.gl.uniform3f(this.gl.getUniformLocation(t, e), i, n, s), this; },
    setFloat4(t, e, i, n, s, r) { return this.setProgram(t), this.gl.uniform4f(this.gl.getUniformLocation(t, e), i, n, s, r), this; },
    setFloat1v(t, e, i) { return this.setProgram(t), this.gl.uniform1fv(this.gl.getUniformLocation(t, e), i), this; },
    setFloat2v(t, e, i) { return this.setProgram(t), this.gl.uniform2fv(this.gl.getUniformLocation(t, e), i), this; },
    setFloat3v(t, e, i) { return this.setProgram(t), this.gl.uniform3fv(this.gl.getUniformLocation(t, e), i), this; },
    setFloat4v(t, e, i) { return this.setProgram(t), this.gl.uniform4fv(this.gl.getUniformLocation(t, e), i), this; },
    setInt1(t, e, i) { return this.setProgram(t), this.gl.uniform1i(this.gl.getUniformLocation(t, e), i), this; },
    setInt2(t, e, i, n) { return this.setProgram(t), this.gl.uniform2i(this.gl.getUniformLocation(t, e), i, n), this; },
    setInt3(t, e, i, n, s) { return this.setProgram(t), this.gl.uniform3i(this.gl.getUniformLocation(t, e), i, n, s), this; },
    setInt4(t, e, i, n, s, r) { return this.setProgram(t), this.gl.uniform4i(this.gl.getUniformLocation(t, e), i, n, s, r), this; },
    setMatrix2(t, e, i, n) { return this.setProgram(t), this.gl.uniformMatrix2fv(this.gl.getUniformLocation(t, e), i, n), this; },
    setMatrix3(t, e, i, n) { return this.setProgram(t), this.gl.uniformMatrix3fv(this.gl.getUniformLocation(t, e), i, n), this; },
    setMatrix4(t, e, i, n) { return this.setProgram(t), this.gl.uniformMatrix4fv(this.gl.getUniformLocation(t, e), i, n), this; },
    getMaxTextures() { return this.config.maxTextures; },
    getMaxTextureSize() { return this.config.maxTextureSize; },
    destroy() { for (const t in this.pipelines) this.pipelines[t].destroy(), delete this.pipelines[t]; for (let e = 0; e < this.nativeTextures.length; ++e) this.deleteTexture(this.nativeTextures[e]), delete this.nativeTextures[e]; delete this.gl, delete this.game, this.contextLost = !0, this.extensions = {}, this.nativeTextures.length = 0; },
  }); t.exports = p;
}, function (t, e, i) { const n = i(66); const s = i(339); t.exports = function () { const t = []; const e = s.supportNewBlendModes; const i = 'source-over'; return t[n.NORMAL] = i, t[n.ADD] = 'lighter', t[n.MULTIPLY] = e ? 'multiply' : i, t[n.SCREEN] = e ? 'screen' : i, t[n.OVERLAY] = e ? 'overlay' : i, t[n.DARKEN] = e ? 'darken' : i, t[n.LIGHTEN] = e ? 'lighten' : i, t[n.COLOR_DODGE] = e ? 'color-dodge' : i, t[n.COLOR_BURN] = e ? 'color-burn' : i, t[n.HARD_LIGHT] = e ? 'hard-light' : i, t[n.SOFT_LIGHT] = e ? 'soft-light' : i, t[n.DIFFERENCE] = e ? 'difference' : i, t[n.EXCLUSION] = e ? 'exclusion' : i, t[n.HUE] = e ? 'hue' : i, t[n.SATURATION] = e ? 'saturation' : i, t[n.COLOR] = e ? 'color' : i, t[n.LUMINOSITY] = e ? 'luminosity' : i, t; }; }, function (t, e) { t.exports = function (t, e, i) { void 0 === e && (e = 'image/png'), void 0 === i && (i = 0.92); const n = t.toDataURL(e, i); const s = new Image(); return s.src = n, s; }; }, function (t, e, i) {
  const n = i(425); const s = i(0); const r = i(26); const o = i(424); const a = i(94); const h = i(120); const l = i(38); const u = new s({
    initialize(t) {
      this.game = t, this.type = r.CANVAS, this.drawCount = 0, this.width = t.config.width, this.height = t.config.height, this.config = {
        clearBeforeRender: t.config.clearBeforeRender, backgroundColor: t.config.backgroundColor, resolution: t.config.resolution, autoResize: t.config.autoResize, antialias: t.config.antialias, roundPixels: t.config.roundPixels,
      }, this.scaleMode = t.config.antialias ? a.LINEAR : a.NEAREST, this.gameCanvas = t.canvas, this.gameContext = this.game.config.context ? this.game.config.context : this.gameCanvas.getContext('2d'), this.currentContext = this.gameContext, this.blendModes = o(), this.currentScaleMode = 0, this.snapshotCallback = null, this.snapshotType = null, this.snapshotEncoder = null, this._tempMatrix1 = new l(), this._tempMatrix2 = new l(), this._tempMatrix3 = new l(), this._tempMatrix4 = new l(), this.init();
    },
    init() { this.resize(this.width, this.height); },
    resize(t, e) { const i = this.config.resolution; this.width = t * i, this.height = e * i, this.gameCanvas.width = this.width, this.gameCanvas.height = this.height, this.config.autoResize && (this.gameCanvas.style.width = `${this.width / i}px`, this.gameCanvas.style.height = `${this.height / i}px`), this.scaleMode === a.NEAREST && h.disable(this.gameContext); },
    onContextLost() {},
    onContextRestored() {},
    resetTransform() { this.currentContext.setTransform(1, 0, 0, 1, 0, 0); },
    setBlendMode(t) { return this.currentContext.globalCompositeOperation = t, this; },
    setContext(t) { return this.currentContext = t || this.gameContext, this; },
    setAlpha(t) { return this.currentContext.globalAlpha = t, this; },
    preRender() { const t = this.gameContext; const e = this.config; const i = this.width; const n = this.height; e.clearBeforeRender && t.clearRect(0, 0, i, n), e.transparent || (t.fillStyle = e.backgroundColor.rgba, t.fillRect(0, 0, i, n)), this.drawCount = 0; },
    render(t, e, i, n) { const s = e.list; const r = s.length; const o = n._cx; const a = n._cy; const h = n._cw; const l = n._ch; const u = n.renderToTexture ? n.context : t.sys.context; const c = o !== 0 || a !== 0 || h !== u.canvas.width || l !== u.canvas.height; this.currentContext = u, n.transparent || (u.fillStyle = n.backgroundColor.rgba, u.fillRect(o, a, h, l)), u.globalAlpha = n.alpha, u.globalCompositeOperation = 'source-over', this.drawCount += s.length, c && (u.save(), u.beginPath(), u.rect(o, a, h, l), u.clip()), n.renderToTexture && n.emit('prerender', n), n.matrix.copyToContext(u); for (let d = 0; d < r; d++) { const f = s[d]; f.willRender(n) && (f.mask && f.mask.preRenderCanvas(this, f, n), f.renderCanvas(this, f, i, n), f.mask && f.mask.postRenderCanvas(this, f, n)); }u.setTransform(1, 0, 0, 1, 0, 0), u.globalCompositeOperation = 'source-over', u.globalAlpha = 1, n.flashEffect.postRenderCanvas(u), n.fadeEffect.postRenderCanvas(u), n.dirty = !1, c && u.restore(), n.renderToTexture && (n.emit('postrender', n), t.sys.context.drawImage(n.canvas, o, a)); },
    postRender() { const t = this.gameContext; t.globalAlpha = 1, t.globalCompositeOperation = 'source-over', this.snapshotCallback && (this.snapshotCallback(n(this.gameCanvas, this.snapshotType, this.snapshotEncoder)), this.snapshotCallback = null); },
    snapshot(t, e, i) { this.snapshotCallback = t, this.snapshotType = e, this.snapshotEncoder = i; },
    batchSprite(t, e, i, n) { const s = i.alpha * t.alpha; if (s !== 0) { const r = this.currentContext; const o = this._tempMatrix1; const a = this._tempMatrix2; const h = this._tempMatrix3; const l = e.canvasData; let u = l.x; let c = l.y; let d = e.cutWidth; let f = e.cutHeight; const p = e.source.resolution; let g = -t.displayOriginX + e.x; let v = -t.displayOriginY + e.y; const y = t.flipX ? -1 : 1; const m = t.flipY ? -1 : 1; if (t.isCropped) { const x = t._crop; x.flipX === t.flipX && x.flipY === t.flipY || e.updateCropUVs(x, t.flipX, t.flipY), d = x.cw, f = x.ch, u = x.cx, c = x.cy, g = -t.displayOriginX + x.x, v = -t.displayOriginY + x.y, y === -1 && (g >= 0 ? g = -(g + d) : g < 0 && (g = Math.abs(g) - d)), m === -1 && (v >= 0 ? v = -(v + f) : v < 0 && (v = Math.abs(v) - f)); }a.applyITRS(t.x, t.y, t.rotation, t.scaleX, t.scaleY), o.copyFrom(i.matrix), n ? (o.multiplyWithOffset(n, -i.scrollX * t.scrollFactorX, -i.scrollY * t.scrollFactorY), a.e = t.x, a.f = t.y, o.multiply(a, h)) : (a.e -= i.scrollX * t.scrollFactorX, a.f -= i.scrollY * t.scrollFactorY, o.multiply(a, h)), r.save(), h.setToContext(r), r.scale(y, m), r.globalCompositeOperation = this.blendModes[t.blendMode], r.globalAlpha = s, r.drawImage(e.source.image, u, c, d, f, g, v, d / p, f / p), r.restore(); } },
    destroy() { this.gameCanvas = null, this.gameContext = null, this.game = null; },
  }); t.exports = u;
}, function (t, e, i) {
  const n = new (i(0))({
    initialize(t) { this.parent = t, this.animationManager = t.scene.sys.anims, this.animationManager.once('remove', this.remove, this), this.isPlaying = !1, this.currentAnim = null, this.currentFrame = null, this._timeScale = 1, this.frameRate = 0, this.duration = 0, this.msPerFrame = 0, this.skipMissedFrames = !0, this._delay = 0, this._repeat = 0, this._repeatDelay = 0, this._yoyo = !1, this.forward = !0, this._reverse = !1, this.accumulator = 0, this.nextTick = 0, this.repeatCounter = 0, this.pendingRepeat = !1, this._paused = !1, this._wasPlaying = !1, this._pendingStop = 0, this._pendingStopValue; }, setDelay(t) { return void 0 === t && (t = 0), this._delay = t, this.parent; }, getDelay() { return this._delay; }, delayedPlay(t, e, i) { return this.play(e, !0, i), this.nextTick += t, this.parent; }, getCurrentKey() { if (this.currentAnim) return this.currentAnim.key; }, load(t, e) { return void 0 === e && (e = 0), this.isPlaying && this.stop(), this.animationManager.load(this, t, e), this.parent; }, pause(t) { return this._paused || (this._paused = !0, this._wasPlaying = this.isPlaying, this.isPlaying = !1), void 0 !== t && this.updateFrame(t), this.parent; }, resume(t) { return this._paused && (this._paused = !1, this.isPlaying = this._wasPlaying), void 0 !== t && this.updateFrame(t), this.parent; }, isPaused: { get() { return this._paused; } }, play(t, e, i) { return void 0 === e && (e = !1), void 0 === i && (i = 0), e && this.isPlaying && this.currentAnim.key === t ? this.parent : (this.forward = !0, this._reverse = !1, this._startAnimation(t, i)); }, playReverse(t, e, i) { return void 0 === e && (e = !1), void 0 === i && (i = 0), e && this.isPlaying && this.currentAnim.key === t ? this.parent : (this.forward = !1, this._reverse = !0, this._startAnimation(t, i)); }, _startAnimation(t, e) { this.load(t, e); const i = this.currentAnim; const n = this.parent; return this.repeatCounter = this._repeat === -1 ? Number.MAX_VALUE : this._repeat, i.getFirstTick(this), this.isPlaying = !0, this.pendingRepeat = !1, i.showOnStart && (n.visible = !0), n.emit('animationstart', this.currentAnim, this.currentFrame, n), n; }, reverse(t) { return this.isPlaying && this.currentAnim.key === t ? (this._reverse = !this._reverse, this.forward = !this.forward, this.parent) : this.parent; }, getProgress() { let t = this.currentFrame.progress; return this.forward || (t = 1 - t), t; }, setProgress(t) { return this.forward || (t = 1 - t), this.setCurrentFrame(this.currentAnim.getFrameByProgress(t)), this.parent; }, remove(t, e) { void 0 === e && (e = this.currentAnim), this.isPlaying && e.key === this.currentAnim.key && (this.stop(), this.setCurrentFrame(this.currentAnim.frames[0])); }, getRepeat() { return this._repeat; }, setRepeat(t) { return this._repeat = t, this.repeatCounter = 0, this.parent; }, getRepeatDelay() { return this._repeatDelay; }, setRepeatDelay(t) { return this._repeatDelay = t, this.parent; }, restart(t) { void 0 === t && (t = !1), this.currentAnim.getFirstTick(this, t), this.forward = !0, this.isPlaying = !0, this.pendingRepeat = !1, this._paused = !1, this.updateFrame(this.currentAnim.frames[0]); const e = this.parent; return e.emit('animationrestart', this.currentAnim, this.currentFrame, e), this.parent; }, stop() { this._pendingStop = 0, this.isPlaying = !1; const t = this.parent; return t.emit('animationcomplete', this.currentAnim, this.currentFrame, t), t; }, stopAfterDelay(t) { return this._pendingStop = 1, this._pendingStopValue = t, this.parent; }, stopOnRepeat() { return this._pendingStop = 2, this.parent; }, stopOnFrame(t) { return this._pendingStop = 3, this._pendingStopValue = t, this.parent; }, setTimeScale(t) { return void 0 === t && (t = 1), this._timeScale = t, this.parent; }, getTimeScale() { return this._timeScale; }, getTotalFrames() { return this.currentAnim.frames.length; }, update(t, e) { if (this.currentAnim && this.isPlaying && !this.currentAnim.paused) { if (this.accumulator += e * this._timeScale, this._pendingStop === 1 && (this._pendingStopValue -= e, this._pendingStopValue <= 0)) return this.currentAnim.completeAnimation(this); this.accumulator >= this.nextTick && this.currentAnim.setFrame(this); } }, setCurrentFrame(t) { const e = this.parent; return this.currentFrame = t, e.texture = t.frame.texture, e.frame = t.frame, e.isCropped && e.frame.updateCropUVs(e._crop, e.flipX, e.flipY), e.setSizeToFrame(), t.frame.customPivot ? e.setOrigin(t.frame.pivotX, t.frame.pivotY) : e.updateDisplayOrigin(), e; }, updateFrame(t) { const e = this.setCurrentFrame(t); if (this.isPlaying) { t.setAlpha && (e.alpha = t.alpha); const i = this.currentAnim; e.emit('animationupdate', i, t, e), this._pendingStop === 3 && this._pendingStopValue === t && this.currentAnim.completeAnimation(this); } }, setYoyo(t) { return void 0 === t && (t = !1), this._yoyo = t, this.parent; }, getYoyo() { return this._yoyo; }, destroy() { this.animationManager.off('remove', this.remove, this), this.animationManager = null, this.parent = null, this.currentAnim = null, this.currentFrame = null; },
  }); t.exports = n;
}, function (t, e) { t.exports = function (t) { return t.split('').reverse().join(''); }; }, function (t, e) { t.exports = function (t, e) { return t.replace(/%([0-9]+)/g, (t, i) => e[Number(i) - 1]); }; }, function (t, e, i) {
  t.exports = {
    Format: i(429), Pad: i(179), Reverse: i(428), UppercaseFirst: i(327), UUID: i(295),
  };
}, function (t, e, i) { const n = i(63); t.exports = function (t, e) { const i = n(t); for (const s in e)i.hasOwnProperty(s) && (i[s] = e[s]); return i; }; }, function (t, e) { t.exports = function (t, e) { for (let i = 0; i < e.length; i++) if (!t.hasOwnProperty(e[i])) return !1; return !0; }; }, function (t, e, i) { const n = i(4); const s = i(23); t.exports = function (t, e, i, r, o) { void 0 === o && (o = i); const a = n(t, e, o); return s(a, i, r); }; }, function (t, e, i) {
  t.exports = {
    Clone: i(63), Extend: i(20), GetAdvancedValue: i(12), GetFastValue: i(2), GetMinMaxValue: i(433), GetValue: i(4), HasAll: i(432), HasAny: i(298), HasValue: i(85), IsPlainObject: i(8), Merge: i(96), MergeRight: i(431),
  };
}, function (t, e, i) { t.exports = { Array: i(164), Objects: i(434), String: i(430) }; }, function (t, e, i) {
  const n = i(0); const s = i(203); const r = i(15); const o = i(202); const a = i(83); const h = i(97); const l = new n({
    initialize(t) { this.scene = t, this.systems = t.sys, this.timeScale = 1, this._add = [], this._pending = [], this._active = [], this._destroy = [], this._toProcess = 0, t.sys.events.once('boot', this.boot, this), t.sys.events.on('start', this.start, this); }, boot() { this.systems.events.once('destroy', this.destroy, this); }, start() { const t = this.systems.events; t.on('preupdate', this.preUpdate, this), t.on('update', this.update, this), t.once('shutdown', this.shutdown, this), this.timeScale = 1; }, createTimeline(t) { return o(this, t); }, timeline(t) { const e = o(this, t); return e.paused || (this._add.push(e), this._toProcess++), e; }, create(t) { return h(this, t); }, add(t) { const e = h(this, t); return this._add.push(e), this._toProcess++, e; }, existing(t) { return this._add.push(t), this._toProcess++, this; }, addCounter(t) { const e = s(this, t); return this._add.push(e), this._toProcess++, e; }, preUpdate() { if (this._toProcess !== 0) { let t; let e; let i = this._destroy; const n = this._active; const s = this._pending; for (t = 0; t < i.length; t++) { e = i[t]; let r = n.indexOf(e); r === -1 ? (r = s.indexOf(e)) > -1 && (e.state = a.REMOVED, s.splice(r, 1)) : (e.state = a.REMOVED, n.splice(r, 1)); } for (i.length = 0, i = this._add, t = 0; t < i.length; t++)(e = i[t]).state === a.PENDING_ADD && (e.init() ? (e.play(), this._active.push(e)) : this._pending.push(e)); i.length = 0, this._toProcess = 0; } }, update(t, e) { let i; const n = this._active; e *= this.timeScale; for (let s = 0; s < n.length; s++)(i = n[s]).update(t, e) && (this._destroy.push(i), this._toProcess++); }, makeActive(t) { if (this._add.indexOf(t) === -1 && this._active.indexOf(t) === -1) { const e = this._pending.indexOf(t); return e !== -1 && this._pending.splice(e, 1), this._add.push(t), t.state = a.PENDING_ADD, this._toProcess++, this; } }, each(t, e) { for (var i = [null], n = 1; n < arguments.length; n++)i.push(arguments[n]); for (const s in this.list)i[0] = this.list[s], t.apply(e, i); }, getAllTweens() { for (var t = this._active, e = [], i = 0; i < t.length; i++)e.push(t[i]); return e; }, getGlobalTimeScale() { return this.timeScale; }, getTweensOf(t) { let e; let i; const n = this._active; const s = []; if (Array.isArray(t)) for (i = 0; i < n.length; i++) { e = n[i]; for (let r = 0; r < t.length; r++)e.hasTarget(t[r]) && s.push(e); } else for (i = 0; i < n.length; i++)(e = n[i]).hasTarget(t) && s.push(e); return s; }, isTweening(t) { for (var e, i = this._active, n = 0; n < i.length; n++) if ((e = i[n]).hasTarget(t) && e.isPlaying()) return !0; return !1; }, killAll() { for (let t = this.getAllTweens(), e = 0; e < t.length; e++)t[e].stop(); return this; }, killTweensOf(t) { for (let e = this.getTweensOf(t), i = 0; i < e.length; i++)e[i].stop(); return this; }, pauseAll() { for (let t = this._active, e = 0; e < t.length; e++)t[e].pause(); return this; }, resumeAll() { for (let t = this._active, e = 0; e < t.length; e++)t[e].resume(); return this; }, setGlobalTimeScale(t) { return this.timeScale = t, this; }, shutdown() { this.killAll(), this._add = [], this._pending = [], this._active = [], this._destroy = [], this._toProcess = 0; const t = this.systems.events; t.off('preupdate', this.preUpdate, this), t.off('update', this.update, this), t.off('shutdown', this.shutdown, this); }, destroy() { this.shutdown(), this.scene.sys.events.off('start', this.start, this), this.scene = null, this.systems = null; },
  }); r.register('TweenManager', l, 'tweens'), t.exports = l;
}, function (t, e) { t.exports = ['callbackScope', 'completeDelay', 'delay', 'duration', 'ease', 'easeParams', 'flipX', 'flipY', 'hold', 'loop', 'loopDelay', 'offset', 'onComplete', 'onCompleteParams', 'onCompleteScope', 'onLoop', 'onLoopParams', 'onLoopScope', 'onRepeat', 'onRepeatParams', 'onRepeatScope', 'onStart', 'onStartParams', 'onStartScope', 'onUpdate', 'onUpdateParams', 'onUpdateScope', 'onYoyo', 'onYoyoParams', 'onYoyoScope', 'paused', 'props', 'repeat', 'repeatDelay', 'targets', 'useFrames', 'yoyo']; }, function (t, e, i) {
  t.exports = {
    GetBoolean: i(84), GetEaseFunction: i(86), GetNewValue: i(98), GetProps: i(205), GetTargets: i(131), GetTweens: i(204), GetValueOp: i(130), NumberTweenBuilder: i(203), TimelineBuilder: i(202), TweenBuilder: i(97),
  };
}, function (t, e, i) {
  const n = i(83); const s = i(20); let r = {
    Builders: i(438), TweenManager: i(436), Tween: i(128), TweenData: i(127), Timeline: i(201),
  }; r = s(!1, r, n), t.exports = r;
}, function (t, e, i) {
  const n = i(0); const s = i(15); const r = i(206); const o = new n({
    initialize(t) { this.scene = t, this.systems = t.sys, this.now = Date.now(), this.timeScale = 1, this.paused = !1, this._active = [], this._pendingInsertion = [], this._pendingRemoval = [], t.sys.events.once('boot', this.boot, this), t.sys.events.on('start', this.start, this); },
    boot() { this.systems.events.once('destroy', this.destroy, this); },
    start() { const t = this.systems.events; t.on('preupdate', this.preUpdate, this), t.on('update', this.update, this), t.once('shutdown', this.shutdown, this); },
    addEvent(t) { const e = new r(t); return this._pendingInsertion.push(e), e; },
    delayedCall(t, e, i, n) {
      return this.addEvent({
        delay: t, callback: e, args: i, callbackScope: n,
      });
    },
    clearPendingEvents() { return this._pendingInsertion = [], this; },
    removeAllEvents() { return this._pendingRemoval = this._pendingRemoval.concat(this._active), this; },
    preUpdate() { const t = this._pendingRemoval.length; const e = this._pendingInsertion.length; if (t !== 0 || e !== 0) { let i; let n; for (i = 0; i < t; i++) { n = this._pendingRemoval[i]; const s = this._active.indexOf(n); s > -1 && this._active.splice(s, 1), n.destroy(); } for (i = 0; i < e; i++)n = this._pendingInsertion[i], this._active.push(n); this._pendingRemoval.length = 0, this._pendingInsertion.length = 0; } },
    update(t, e) { if (this.now = t, !this.paused) { e *= this.timeScale; for (let i = 0; i < this._active.length; i++) { const n = this._active[i]; if (!n.paused && (n.elapsed += e * n.timeScale, n.elapsed >= n.delay)) { const s = n.elapsed - n.delay; n.elapsed = n.delay, !n.hasDispatched && n.callback && (n.hasDispatched = !0, n.callback.apply(n.callbackScope, n.args)), n.repeatCount > 0 ? (n.repeatCount--, n.elapsed = s, n.hasDispatched = !1) : this._pendingRemoval.push(n); } } } },
    shutdown() { let t; for (t = 0; t < this._pendingInsertion.length; t++) this._pendingInsertion[t].destroy(); for (t = 0; t < this._active.length; t++) this._active[t].destroy(); for (t = 0; t < this._pendingRemoval.length; t++) this._pendingRemoval[t].destroy(); this._active.length = 0, this._pendingRemoval.length = 0, this._pendingInsertion.length = 0; const e = this.systems.events; e.off('preupdate', this.preUpdate, this), e.off('update', this.update, this), e.off('shutdown', this.shutdown, this); },
    destroy() { this.shutdown(), this.scene.sys.events.off('start', this.start, this), this.scene = null, this.systems = null; },
  }); s.register('Clock', o, 'time'), t.exports = o;
}, function (t, e, i) { t.exports = { Clock: i(440), TimerEvent: i(206) }; }, function (t, e, i) { const n = i(5); const s = i(132); n.register('tilemap', function (t, e, i, n, r, o, a) { return t === null && (t = void 0), e === null && (e = void 0), i === null && (i = void 0), n === null && (n = void 0), r === null && (r = void 0), s(this.scene, t, e, i, n, r, o, a); }); }, function (t, e, i) { const n = i(13); const s = i(132); n.register('tilemap', function (t) { const e = void 0 !== t ? t : {}; return s(this.scene, e.key, e.tileWidth, e.tileHeight, e.width, e.height, e.data, e.insertNull); }); }, function (t, e) { t.exports = function (t, e, i, n, s) { e.cull(n); const r = e.culledTiles; const o = r.length; if (o !== 0) { const a = t._tempMatrix1; const h = t._tempMatrix2; const l = t._tempMatrix3; h.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), a.copyFrom(n.matrix); const u = t.currentContext; const c = e.gidMap; u.save(), s ? (a.multiplyWithOffset(s, -n.scrollX * e.scrollFactorX, -n.scrollY * e.scrollFactorY), h.e = e.x, h.f = e.y, a.multiply(h, l), l.copyToContext(u)) : (h.e -= n.scrollX * e.scrollFactorX, h.f -= n.scrollY * e.scrollFactorY, h.copyToContext(u)); const d = n.alpha * e.alpha; u.globalAlpha = n.alpha * e.alpha; for (let f = 0; f < o; f++) { const p = r[f]; const g = c[p.index]; if (g) { const v = g.image.getSourceImage(); const y = g.getTileTextureCoordinates(p.index); if (y) { const m = p.width / 2; const x = p.height / 2; u.save(), u.translate(p.pixelX + m, p.pixelY + x), p.rotation !== 0 && u.rotate(p.rotation), (p.flipX || p.flipY) && u.scale(p.flipX ? -1 : 1, p.flipY ? -1 : 1), u.globalAlpha = d * p.alpha, u.drawImage(v, y.x, y.y, p.width, p.height, -m, -x, p.width, p.height), u.restore(); } } }u.restore(); } }; }, function (t, e) { t.exports = function (t, e, i, n) { const s = e.tileset; const r = e.pipeline; const o = r.vertexBuffer; t.setPipeline(r), r.modelIdentity(), r.modelTranslate(e.x - n.scrollX * e.scrollFactorX, e.y - n.scrollY * e.scrollFactorY, 0), r.modelScale(e.scaleX, e.scaleY, 1), r.viewLoad2D(n.matrix.matrix); for (let a = 0; a < s.length; a++)e.upload(n, a), e.vertexCount[a] > 0 && (t.currentPipeline && t.currentPipeline.vertexCount > 0 && t.flush(), r.vertexBuffer = e.vertexBuffer[a], t.setPipeline(r), t.setTexture2D(s[a].glTexture, 0), t.gl.drawArrays(r.topology, 0, e.vertexCount[a])); r.vertexBuffer = o, r.viewIdentity(), r.modelIdentity(); }; }, function (t, e, i) { let n = i(1); let s = i(1); n = i(445), s = i(444), t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e) { t.exports = function (t, e, i, n, s) { e.cull(n); const r = e.culledTiles; const o = r.length; if (o !== 0) { const a = t._tempMatrix1; const h = t._tempMatrix2; const l = t._tempMatrix3; h.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), a.copyFrom(n.matrix); const u = t.currentContext; const c = e.gidMap; u.save(), s ? (a.multiplyWithOffset(s, -n.scrollX * e.scrollFactorX, -n.scrollY * e.scrollFactorY), h.e = e.x, h.f = e.y, a.multiply(h, l), l.copyToContext(u)) : (h.e -= n.scrollX * e.scrollFactorX, h.f -= n.scrollY * e.scrollFactorY, h.copyToContext(u)); for (let d = n.alpha * e.alpha, f = 0; f < o; f++) { const p = r[f]; const g = c[p.index]; if (g) { const v = g.image.getSourceImage(); const y = g.getTileTextureCoordinates(p.index); if (y) { const m = p.width / 2; const x = p.height / 2; u.save(), u.translate(p.pixelX + m, p.pixelY + x), p.rotation !== 0 && u.rotate(p.rotation), (p.flipX || p.flipY) && u.scale(p.flipX ? -1 : 1, p.flipY ? -1 : 1), u.globalAlpha = d * p.alpha, u.drawImage(v, y.x, y.y, p.width, p.height, -m, -x, p.width, p.height), u.restore(); } } }u.restore(); } }; }, function (t, e, i) { const n = i(10); t.exports = function (t, e, i, s) { e.cull(s); const r = e.culledTiles; const o = r.length; const a = s.alpha * e.alpha; if (!(o === 0 || a <= 0)) for (let h = e.gidMap, l = e.pipeline, u = n.getTintAppendFloatAlpha, c = e.scrollFactorX, d = e.scrollFactorY, f = e.x, p = e.y, g = e.scaleX, v = e.scaleY, y = e.tileset, m = 0; m < y.length; m++) for (let x = y[m], w = x.glTexture, b = 0; b < o; b++) { const T = r[b]; const S = h[T.index]; if (S === x) { const _ = S.getTileTextureCoordinates(T.index); if (_ !== null) { const A = T.width; const C = T.height; const M = _.x; const P = _.y; const E = 0.5 * T.width; const k = 0.5 * T.height; const L = u(T.tint, a * T.alpha); l.batchTexture(e, w, w.width, w.height, (E + f + T.pixelX) * g, (k + p + T.pixelY) * v, T.width, T.height, g, v, T.rotation, T.flipX, T.flipY, c, d, E, k, M, P, A, C, L, L, L, L, !1, 0, 0, s, null, !0); } } } }; }, function (t, e, i) { let n = i(1); let s = i(1); n = i(448), s = i(447), t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e, i) { const n = i(99); t.exports = function (t) { for (var e = [], i = [], s = 0; s < t.layer.length; s++) { const r = t.layer[s]; const o = r.tilesetName; o !== '' && i.indexOf(o) === -1 && (i.push(o), e.push(new n(o, 0, r.tilesize, r.tilesize, 0, 0))); } return e; }; }, function (t, e, i) {
  const n = i(78); const s = i(55); t.exports = function (t, e) {
    for (var i = [], r = 0; r < t.layer.length; r++) {
      for (var o = t.layer[r], a = new n({
          name: o.name, width: o.width, height: o.height, tileWidth: o.tilesize, tileHeight: o.tilesize, visible: o.visible === 1,
        }), h = [], l = [], u = 0; u < o.data.length; u++) { for (let c = 0; c < o.data[u].length; c++) { var d; const f = o.data[u][c] - 1; d = f > -1 ? new s(a, f, c, u, o.tilesize, o.tilesize) : e ? null : new s(a, -1, c, u, o.tilesize, o.tilesize), h.push(d); }l.push(h), h = []; }a.data = l, i.push(a);
    } return i;
  };
}, function (t, e, i) { const n = i(20); t.exports = function (t) { for (var e, i, s, r, o, a = 0; a < t.layers.length; a++) { e = t.layers[a], r = null; for (let h = 0; h < e.data.length; h++) { o = e.data[h]; for (let l = 0; l < o.length; l++)(i = o[l]) === null || i.index < 0 || (s = t.tiles[i.index][2], r = t.tilesets[s], i.width = r.tileWidth, i.height = r.tileHeight, r.tileProperties && r.tileProperties[i.index - r.firstgid] && (i.properties = n(i.properties, r.tileProperties[i.index - r.firstgid]))); } } }; }, function (t, e) { t.exports = function (t) { for (var e = [], i = 0; i < t.tilesets.length; i++) for (let n = t.tilesets[i], s = n.tileMargin, r = n.tileMargin, o = 0, a = 0, h = 0, l = n.firstgid; l < n.firstgid + n.total && (e[l] = [s, r, i], s += n.tileWidth + n.tileSpacing, ++o !== n.total) && (++a !== n.columns || (s = n.tileMargin, r += n.tileHeight + n.tileSpacing, a = 0, ++h !== n.rows)); l++);return e; }; }, function (t, e, i) { const n = i(2); const s = i(212); const r = i(211); t.exports = function (t) { for (var e = [], i = 0; i < t.layers.length; i++) if (t.layers[i].type === 'objectgroup') { for (var o = t.layers[i], a = n(o, 'offsetx', 0), h = n(o, 'offsety', 0), l = [], u = 0; u < o.objects.length; u++) { const c = s(o.objects[u], a, h); l.push(c); } const d = new r(o); d.objects = l, e.push(d); } return e; }; }, function (t, e, i) { const n = i(85); t.exports = function (t, e) { for (var i = {}, s = 0; s < e.length; s++) { const r = e[s]; n(t, r) && (i[r] = t[r]); } return i; }; }, function (t, e, i) { const n = i(99); const s = i(213); const r = i(212); t.exports = function (t) { for (var e, i = [], o = [], a = null, h = 0; h < t.tilesets.length; h++) { const l = t.tilesets[h]; if (l.source)console.warn("Phaser can't load external tilesets. Use the Embed Tileset button and then export the map again."); else if (l.image) { const u = new n(l.name, l.firstgid, l.tilewidth, l.tileheight, l.margin, l.spacing); if (t.version > 1) { if (Array.isArray(l.tiles)) { for (var c = {}, d = {}, f = 0; f < l.tiles.length; f++) { const p = l.tiles[f]; if (p.properties) { var g = {}; p.properties.forEach((t) => { g[t.name] = t.value; }), d[p.id] = g; } if (p.objectgroup && (c[p.id] = { objectgroup: p.objectgroup }, p.objectgroup.objects)) { const v = p.objectgroup.objects.map((t) => r(t)); c[p.id].objectgroup.objects = v; } }u.tileData = c, u.tileProperties = d; } } else if (l.tileproperties && (u.tileProperties = l.tileproperties), l.tiles) for (e in u.tileData = l.tiles, u.tileData) { const y = u.tileData[e].objectgroup; if (y && y.objects) { const m = y.objects.map((t) => r(t)); u.tileData[e].objectgroup.objects = m; } }u.updateTileData(l.imagewidth, l.imageheight), i.push(u); } else { const x = new s(l.name, l.firstgid, l.tilewidth, l.tileheight, l.margin, l.spacing, l.properties); for (e in l.tiles) { const w = l.tiles[e].image; const b = l.firstgid + parseInt(e, 10); x.addImage(b, w); }o.push(x); }a && (a.lastgid = l.firstgid - 1), a = l; } return { tilesets: i, imageCollections: o }; }; }, function (t, e, i) {
  const n = i(2); t.exports = function (t) {
    for (var e = [], i = 0; i < t.layers.length; i++) {
      if (t.layers[i].type === 'imagelayer') {
        const s = t.layers[i]; e.push({
          name: s.name, image: s.image, x: n(s, 'offsetx', 0) + s.x, y: n(s, 'offsety', 0) + s.y, alpha: s.opacity, visible: s.visible, properties: n(s, 'properties', {}),
        });
      }
    } return e;
  };
}, function (t, e) { t.exports = function (t) { for (var e = window.atob(t), i = e.length, n = new Array(i / 4), s = 0; s < i; s += 4)n[s / 4] = (e.charCodeAt(s) | e.charCodeAt(s + 1) << 8 | e.charCodeAt(s + 2) << 16 | e.charCodeAt(s + 3) << 24) >>> 0; return n; }; }, function (t, e, i) {
  const n = i(458); const s = i(2); const r = i(78); const o = i(214); const a = i(55); t.exports = function (t, e) {
    for (var i = [], h = 0; h < t.layers.length; h++) {
      if (t.layers[h].type === 'tilelayer') {
        const l = t.layers[h]; if (l.compression)console.warn(`TilemapParser.parseTiledJSON - Layer compression is unsupported, skipping layer '${l.name}'`); else {
          l.encoding && l.encoding === 'base64' && (l.data = n(l.data), delete l.encoding); for (var u = new r({
              name: l.name, x: s(l, 'offsetx', 0) + l.x, y: s(l, 'offsety', 0) + l.y, width: l.width, height: l.height, tileWidth: t.tilewidth, tileHeight: t.tileheight, alpha: l.opacity, visible: l.visible, properties: s(l, 'properties', {}),
            }), c = 0, d = [], f = [], p = 0, g = l.data.length; p < g; p++) { const v = o(l.data[p]); if (v.gid > 0) { const y = new a(u, v.gid, c, f.length, t.tilewidth, t.tileheight); y.rotation = v.rotation, y.flipX = v.flipped, d.push(y); } else { const m = e ? null : new a(u, -1, c, f.length, t.tilewidth, t.tileheight); d.push(m); }++c === l.width && (f.push(d), c = 0, d = []); }u.data = f, i.push(u);
        }
      }
    } return i;
  };
}, function (t, e, i) {
  t.exports = {
    Parse: i(217), Parse2DArray: i(133), ParseCSV: i(216), Impact: i(210), Tiled: i(215),
  };
}, function (t, e, i) { const n = i(50); const s = i(49); const r = i(3); t.exports = function (t, e, i, o, a, h) { return void 0 === o && (o = new r(0, 0)), o.x = n(t, i, a, h), o.y = s(e, i, a, h), o; }; }, function (t, e, i) { const n = i(17); t.exports = function (t, e, i, s, r, o) { if (void 0 !== r) { let a; const h = n(t, e, i, s, null, o); let l = 0; for (a = 0; a < r.length; a++)l += r[a].weight; if (!(l <= 0)) for (a = 0; a < h.length; a++) { for (var u = Math.random() * l, c = 0, d = -1, f = 0; f < r.length; f++) if (u <= (c += r[f].weight)) { const p = r[f].index; d = Array.isArray(p) ? p[Math.floor(Math.random() * p.length)] : p; break; }h[a].index = d; } } }; }, function (t, e, i) { const n = i(101); const s = i(100); const r = i(3); t.exports = function (t, e, i, o, a) { return void 0 === i && (i = new r(0, 0)), i.x = n(t, o, a), i.y = s(e, o, a), i; }; }, function (t, e, i) { const n = i(17); t.exports = function (t, e, i, s, r, o, a) { for (let h = n(i, s, r, o, null, a), l = 0; l < h.length; l++)h[l] && (h[l].index === t ? h[l].index = e : h[l].index === e && (h[l].index = t)); }; }, function (t, e, i) { const n = i(17); const s = i(122); t.exports = function (t, e, i, r, o) { const a = n(t, e, i, r, null, o); const h = a.map((t) => t.index); s(h); for (let l = 0; l < a.length; l++)a[l].index = h[l]; }; }, function (t, e, i) { const n = i(17); t.exports = function (t, e, i, s, r, o, a) { for (let h = n(t, e, i, s, null, a), l = 0; l < h.length; l++)h[l].setCollisionCallback(r, o); }; }, function (t, e) { t.exports = function (t, e, i, n) { if (typeof t === 'number')n.callbacks[t] = e !== null ? { callback: e, callbackContext: i } : void 0; else for (let s = 0, r = t.length; s < r; s++)n.callbacks[t[s]] = e !== null ? { callback: e, callbackContext: i } : void 0; }; }, function (t, e, i) { const n = i(56); const s = i(34); t.exports = function (t, e, i) { void 0 === t && (t = !0), void 0 === e && (e = !0); for (let r = 0; r < i.height; r++) for (let o = 0; o < i.width; o++) { const a = i.data[r][o]; if (a) { const h = a.getCollisionGroup(); h && h.objects && h.objects.length > 0 && n(a, t); } }e && s(0, 0, i.width, i.height, i); }; }, function (t, e, i) { const n = i(56); const s = i(34); const r = i(85); t.exports = function (t, e, i, o) { void 0 === e && (e = !0), void 0 === i && (i = !0); for (let a = 0; a < o.height; a++) for (let h = 0; h < o.width; h++) { const l = o.data[a][h]; if (l) for (const u in t) if (r(l.properties, u)) { let c = t[u]; Array.isArray(c) || (c = [c]); for (let d = 0; d < c.length; d++)l.properties[u] === c[d] && n(l, e); } }i && s(0, 0, o.width, o.height, o); }; }, function (t, e, i) { const n = i(56); const s = i(34); const r = i(134); t.exports = function (t, e, i, o) { void 0 === e && (e = !0), void 0 === i && (i = !0), Array.isArray(t) || (t = [t]); for (let a = 0; a < o.height; a++) for (let h = 0; h < o.width; h++) { const l = o.data[a][h]; l && t.indexOf(l.index) === -1 && (n(l, e), r(l.index, e, o)); }i && s(0, 0, o.width, o.height, o); }; }, function (t, e, i) { const n = i(56); const s = i(34); const r = i(134); t.exports = function (t, e, i, o, a) { if (void 0 === i && (i = !0), void 0 === o && (o = !0), !(t > e)) { for (let h = t; h <= e; h++)r(h, i, a); for (let l = 0; l < a.height; l++) for (let u = 0; u < a.width; u++) { const c = a.data[l][u]; c && c.index >= t && c.index <= e && n(c, i); }o && s(0, 0, a.width, a.height, a); } }; }, function (t, e, i) { const n = i(56); const s = i(34); const r = i(134); t.exports = function (t, e, i, o) { void 0 === e && (e = !0), void 0 === i && (i = !0), Array.isArray(t) || (t = [t]); for (let a = 0; a < t.length; a++)r(t[a], e, o); for (let h = 0; h < o.height; h++) for (let l = 0; l < o.width; l++) { const u = o.data[h][l]; u && t.indexOf(u.index) !== -1 && n(u, e); }i && s(0, 0, o.width, o.height, o); }; }, function (t, e, i) { const n = i(17); const s = i(347); const r = new s(105, 210, 231, 150); const o = new s(243, 134, 48, 200); const a = new s(40, 39, 37, 150); t.exports = function (t, e, i) { void 0 === e && (e = {}); const s = void 0 !== e.tileColor ? e.tileColor : r; const h = void 0 !== e.collidingTileColor ? e.collidingTileColor : o; const l = void 0 !== e.faceColor ? e.faceColor : a; const u = n(0, 0, i.width, i.height, null, i); t.translate(i.tilemapLayer.x, i.tilemapLayer.y), t.scale(i.tilemapLayer.scaleX, i.tilemapLayer.scaleY); for (let c = 0; c < u.length; c++) { const d = u[c]; let f = d.width; let p = d.height; let g = d.pixelX; let v = d.pixelY; const y = d.collides ? h : s; y !== null && (t.fillStyle(y.color, y.alpha / 255), t.fillRect(g, v, f, p)), g += 1, v += 1, f -= 2, p -= 2, l !== null && (t.lineStyle(1, l.color, l.alpha / 255), d.faceTop && t.lineBetween(g, v, g + f, v), d.faceRight && t.lineBetween(g + f, v, g + f, v + p), d.faceBottom && t.lineBetween(g, v + p, g + f, v + p), d.faceLeft && t.lineBetween(g, v, g, v + p)); } }; }, function (t, e, i) { const n = i(218); const s = i(50); const r = i(49); t.exports = function (t, e, i, o, a, h) { const l = s(t, !0, a, h); const u = r(e, !0, a, h); return n(l, u, i, o, h); }; }, function (t, e, i) { const n = i(17); const s = i(162); t.exports = function (t, e, i, r, o, a) { let h; const l = n(t, e, i, r, null, a); if (void 0 === o) for (o = [], h = 0; h < l.length; h++)o.indexOf(l[h].index) === -1 && o.push(l[h].index); for (h = 0; h < l.length; h++)l[h].index = s(o); }; }, function (t, e, i) { const n = i(34); const s = i(135); t.exports = function (t, e, i, r, o) { if (!Array.isArray(t)) return null; void 0 === r && (r = !0), Array.isArray(t[0]) || (t = [t]); for (var a = t.length, h = t[0].length, l = 0; l < a; l++) for (let u = 0; u < h; u++) { const c = t[l][u]; s(c, e + u, i + l, !1, o); }r && n(e - 1, i - 1, h + 2, a + 2, o); }; }, function (t, e, i) { const n = i(135); const s = i(50); const r = i(49); t.exports = function (t, e, i, o, a, h) { const l = s(e, !0, a, h); const u = r(i, !0, a, h); return n(t, l, u, o, h); }; }, function (t, e, i) { const n = i(219); const s = i(50); const r = i(49); t.exports = function (t, e, i, o) { const a = s(t, !0, i, o); const h = r(e, !0, i, o); return n(a, h, o); }; }, function (t, e, i) { const n = i(17); const s = i(50); const r = i(49); t.exports = function (t, e, i, o, a, h, l) { const u = s(t, !0, h, l); const c = r(e, !0, h, l); const d = Math.ceil(s(t + i, !1, h, l)); const f = Math.ceil(r(e + o, !1, h, l)); return n(u, c, d - u, f - c, a, l); }; }, function (t, e, i) { const n = i(274); const s = i(17); const r = i(273); const o = i(1); const a = i(101); const h = i(100); const l = i(50); const u = i(49); const c = function (t, e) { return r.RectangleToTriangle(e, t); }; t.exports = function (t, e, i, d) { if (void 0 === t) return []; let f = o; t instanceof n.Circle ? f = r.CircleToRectangle : t instanceof n.Rectangle ? f = r.RectangleToRectangle : t instanceof n.Triangle ? f = c : t instanceof n.Line && (f = r.LineToRectangle); const p = l(t.left, !0, i, d); const g = u(t.top, !0, i, d); const v = Math.ceil(l(t.right, !1, i, d)); const y = Math.ceil(u(t.bottom, !1, i, d)); const m = Math.max(v - p, 1); const x = Math.max(y - g, 1); const w = s(p, g, m, x, e, d); let b = d.tileWidth; let T = d.tileHeight; d.tilemapLayer && (b *= d.tilemapLayer.scaleX, T *= d.tilemapLayer.scaleY); for (var S = [], _ = new n.Rectangle(0, 0, b, T), A = 0; A < w.length; A++) { const C = w[A]; _.x = a(C.x, i, d), _.y = h(C.y, i, d), f(t, _) && S.push(C); } return S; }; }, function (t, e, i) { const n = i(102); const s = i(50); const r = i(49); t.exports = function (t, e, i, o, a) { const h = s(t, !0, o, a); const l = r(e, !0, o, a); return n(h, l, i, a); }; }, function (t, e, i) { const n = i(17); t.exports = function (t, e, i, s, r, o, a, h) { n(i, s, r, o, a, h).forEach(t, e); }; }, function (t, e, i) { const n = i(17); t.exports = function (t, e, i, s, r, o, a, h) { return n(i, s, r, o, a, h).find(t, e) || null; }; }, function (t, e) { t.exports = function (t, e, i, n) { void 0 === e && (e = 0), void 0 === i && (i = !1); let s; let r; let o; let a = 0; if (i) { for (r = n.height - 1; r >= 0; r--) for (s = n.width - 1; s >= 0; s--) if ((o = n.data[r][s]) && o.index === t) { if (a === e) return o; a += 1; } } else for (r = 0; r < n.height; r++) for (s = 0; s < n.width; s++) if ((o = n.data[r][s]) && o.index === t) { if (a === e) return o; a += 1; } return null; }; }, function (t, e, i) { const n = i(17); t.exports = function (t, e, i, s, r, o, a, h) { return n(i, s, r, o, a, h).filter(t, e); }; }, function (t, e, i) { const n = i(17); const s = i(34); const r = i(56); t.exports = function (t, e, i, o, a, h, l) { for (let u = l.collideIndexes.indexOf(t) !== -1, c = n(e, i, o, a, null, l), d = 0; d < c.length; d++)c[d].index = t, r(c[d], u); h && s(e - 1, i - 1, o + 2, a + 2, l); }; }, function (t, e, i) { const n = i(142); const s = i(243); t.exports = function (t, e, i, r) { void 0 === i && (i = []), void 0 === r && (r = 0), i.length = 0; let o; let a; let h; const l = t.tilemapLayer.tilemap; const u = t.tilemapLayer; const c = t.data; const d = t.width; const f = t.height; const p = Math.floor(l.tileWidth * u.scaleX); const g = Math.floor(l.tileHeight * u.scaleY); let v = 0; let y = d; let m = 0; let x = f; if (!u.skipCull && u.scrollFactorX === 1 && u.scrollFactorY === 1) { const w = n(e.worldView.x - u.x, p, 0, !0) - u.cullPaddingX; const b = s(e.worldView.right - u.x, p, 0, !0) + u.cullPaddingX; const T = n(e.worldView.y - u.y, g, 0, !0) - u.cullPaddingY; const S = s(e.worldView.bottom - u.y, g, 0, !0) + u.cullPaddingY; v = Math.max(0, w), y = Math.min(d, b), m = Math.max(0, T), x = Math.min(f, S); } if (r === 0) for (a = m; a < x; a++) for (o = v; o < y; o++)(h = c[a][o]) && h.index !== -1 && h.visible && h.alpha !== 0 && i.push(h); else if (r === 1) for (a = m; a < x; a++) for (o = y; o >= v; o--)(h = c[a][o]) && h.index !== -1 && h.visible && h.alpha !== 0 && i.push(h); else if (r === 2) for (a = x; a >= m; a--) for (o = v; o < y; o++)(h = c[a][o]) && h.index !== -1 && h.visible && h.alpha !== 0 && i.push(h); else if (r === 3) for (a = x; a >= m; a--) for (o = y; o >= v; o--)(h = c[a][o]) && h.index !== -1 && h.visible && h.alpha !== 0 && i.push(h); return u.tilesDrawn = i.length, u.tilesTotal = d * f, i; }; }, function (t, e, i) { const n = i(101); const s = i(100); const r = i(17); const o = i(220); t.exports = function (t, e, i, a, h, l) { void 0 === i && (i = {}), Array.isArray(t) || (t = [t]); const u = l.tilemapLayer; void 0 === a && (a = u.scene), void 0 === h && (h = a.cameras.main); let c; const d = r(0, 0, l.width, l.height, null, l); const f = []; for (c = 0; c < d.length; c++) { const p = d[c]; if (t.indexOf(p.index) !== -1) { i.x = n(p.x, h, l), i.y = s(p.y, h, l); const g = a.make.sprite(i); f.push(g); } } if (typeof e === 'number') for (c = 0; c < t.length; c++)o(t[c], e, 0, 0, l.width, l.height, l); else if (Array.isArray(e)) for (c = 0; c < t.length; c++)o(t[c], e[c], 0, 0, l.width, l.height, l); return f; }; }, function (t, e, i) { const n = i(17); const s = i(34); t.exports = function (t, e, i, r, o, a, h, l) { t < 0 && (t = 0), e < 0 && (e = 0), void 0 === h && (h = !0); for (let u = n(t, e, i, r, null, l), c = o - t, d = a - e, f = 0; f < u.length; f++) { const p = u[f].x + c; const g = u[f].y + d; p >= 0 && p < l.width && g >= 0 && g < l.height && l.data[g][p] && l.data[g][p].copy(u[f]); }h && s(o - 1, a - 1, i + 2, r + 2, l); }; }, function (t, e, i) {
  t.exports = {
    Components: i(103), Parsers: i(460), Formats: i(29), ImageCollection: i(213), ParseToTilemap: i(132), Tile: i(55), Tilemap: i(209), TilemapCreator: i(443), TilemapFactory: i(442), Tileset: i(99), LayerData: i(78), MapData: i(77), ObjectLayer: i(211), DynamicTilemapLayer: i(208), StaticTilemapLayer: i(207),
  };
}, function (t, e) { t.exports = { LINEAR: 0, NEAREST: 1 }; }, function (t, e, i) {
  const n = i(20); const s = i(491); let r = {
    FilterMode: s, Frame: i(113), Parsers: i(316), Texture: i(165), TextureManager: i(318), TextureSource: i(317),
  }; r = n(!1, r, s), t.exports = r;
}, function (t, e, i) {
  t.exports = {
    List: i(112), Map: i(180), ProcessQueue: i(228), RTree: i(227), Set: i(95),
  };
}, function (t, e, i) {
  t.exports = {
    SoundManagerCreator: i(325), BaseSound: i(114), BaseSoundManager: i(115), WebAudioSound: i(319), WebAudioSoundManager: i(320), HTML5AudioSound: i(323), HTML5AudioSoundManager: i(324), NoAudioSound: i(321), NoAudioSoundManager: i(322),
  };
}, function (t, e, i) {
  const n = i(23); const s = i(0); const r = i(2); const o = i(15); const a = new s({
    initialize(t) { this.scene = t, this.systems = t.sys, this.settings = t.sys.settings, this.key = t.sys.settings.key, this.manager = t.sys.game.scene, this.transitionProgress = 0, this._elapsed = 0, this._target = null, this._duration = 0, this._onUpdate, this._onUpdateScope, this._willSleep = !1, this._willRemove = !1, t.sys.events.once('boot', this.boot, this), t.sys.events.on('start', this.pluginStart, this); }, boot() { this.systems.events.once('destroy', this.destroy, this); }, pluginStart() { this._target = null, this.systems.events.once('shutdown', this.shutdown, this); }, start(t, e) { return void 0 === t && (t = this.key), this.manager.queueOp('stop', this.key), this.manager.queueOp('start', t, e), this; }, restart(t) { const e = this.key; return this.manager.queueOp('stop', e), this.manager.queueOp('start', e, t), this; }, transition(t) { void 0 === t && (t = {}); const e = r(t, 'target', !1); const i = this.manager.getScene(e); if (!e || !this.checkValidTransition(i)) return !1; const n = r(t, 'duration', 1e3); this._elapsed = 0, this._target = i, this._duration = n, this._willSleep = r(t, 'sleep', !1), this._willRemove = r(t, 'remove', !1); const s = r(t, 'onUpdate', null); s && (this._onUpdate = s, this._onUpdateScope = r(t, 'onUpdateScope', this.scene)); const o = r(t, 'allowInput', !1); this.settings.transitionAllowInput = o; const a = i.sys.settings; return a.isTransition = !0, a.transitionFrom = this.scene, a.transitionDuration = n, a.transitionAllowInput = o, r(t, 'moveAbove', !1) ? this.manager.moveAbove(this.key, e) : r(t, 'moveBelow', !1) && this.manager.moveBelow(this.key, e), i.sys.isSleeping() ? i.sys.wake() : this.manager.start(e, r(t, 'data')), this.systems.events.emit('transitionout', i, n), this.systems.events.on('update', this.step, this), !0; }, checkValidTransition(t) { return !(!t || t.sys.isActive() || t.sys.isTransitioning() || t === this.scene || this.systems.isTransitioning()); }, step(t, e) { this._elapsed += e, this.transitionProgress = n(this._elapsed / this._duration, 0, 1), this._onUpdate && this._onUpdate.call(this._onUpdateScope, this.transitionProgress), this._elapsed >= this._duration && this.transitionComplete(); }, transitionComplete() { const t = this._target.sys; const e = this._target.sys.settings; this.systems.events.off('update', this.step, this), t.events.emit('transitioncomplete', this.scene), e.isTransition = !1, e.transitionFrom = null, this._duration = 0, this._target = null, this._onUpdate = null, this._onUpdateScope = null, this._willRemove ? this.manager.remove(this.key) : this._willSleep ? this.systems.sleep() : this.manager.stop(this.key); }, add(t, e, i) { return this.manager.add(t, e, i), this; }, launch(t, e) { return t && t !== this.key && this.manager.queueOp('start', t, e), this; }, run(t, e) { return t && t !== this.key && this.manager.queueOp('run', t, e), this; }, pause(t, e) { return void 0 === t && (t = this.key), this.manager.queueOp('pause', t, e), this; }, resume(t, e) { return void 0 === t && (t = this.key), this.manager.queueOp('resume', t, e), this; }, sleep(t, e) { return void 0 === t && (t = this.key), this.manager.queueOp('sleep', t, e), this; }, wake(t, e) { return void 0 === t && (t = this.key), this.manager.queueOp('wake', t, e), this; }, switch(t) { return t !== this.key && this.manager.queueOp('switch', this.key, t), this; }, stop(t) { return void 0 === t && (t = this.key), this.manager.queueOp('stop', t), this; }, setActive(t, e, i) { void 0 === e && (e = this.key); const n = this.manager.getScene(e); return n && n.sys.setActive(t, i), this; }, setVisible(t, e) { void 0 === e && (e = this.key); const i = this.manager.getScene(e); return i && i.sys.setVisible(t), this; }, isSleeping(t) { return void 0 === t && (t = this.key), this.manager.isSleeping(t); }, isActive(t) { return void 0 === t && (t = this.key), this.manager.isActive(t); }, isVisible(t) { return void 0 === t && (t = this.key), this.manager.isVisible(t); }, swapPosition(t, e) { return void 0 === e && (e = this.key), t !== e && this.manager.swapPosition(t, e), this; }, moveAbove(t, e) { return void 0 === e && (e = this.key), t !== e && this.manager.moveAbove(t, e), this; }, moveBelow(t, e) { return void 0 === e && (e = this.key), t !== e && this.manager.moveBelow(t, e), this; }, remove(t) { return void 0 === t && (t = this.key), this.manager.remove(t), this; }, moveUp(t) { return void 0 === t && (t = this.key), this.manager.moveUp(t), this; }, moveDown(t) { return void 0 === t && (t = this.key), this.manager.moveDown(t), this; }, bringToTop(t) { return void 0 === t && (t = this.key), this.manager.bringToTop(t), this; }, sendToBack(t) { return void 0 === t && (t = this.key), this.manager.sendToBack(t), this; }, get(t) { return this.manager.getScene(t); }, getIndex(t) { return void 0 === t && (t = this.key), this.manager.getIndex(t); }, shutdown() { const t = this.systems.events; t.off('shutdown', this.shutdown, this), t.off('postupdate', this.step, this), t.off('transitionout'); }, destroy() { this.shutdown(), this.scene.sys.events.off('start', this.start, this), this.scene = null, this.systems = null, this.settings = null, this.manager = null; },
  }); o.register('ScenePlugin', a, 'scenePlugin'), t.exports = a;
}, function (t, e, i) {
  const n = i(116); const s = i(20); let r = {
    SceneManager: i(329), ScenePlugin: i(495), Settings: i(326), Systems: i(166),
  }; r = s(!1, r, n), t.exports = r;
}, function (t, e, i) { const n = i(221); const s = new (i(0))({ Extends: n, initialize(t, e) { n.call(this, e), this.scene = t, this.systems = t.sys, t.sys.events.once('boot', this.boot, this); }, boot() {} }); t.exports = s; }, function (t, e, i) {
  t.exports = {
    BasePlugin: i(221), DefaultPlugins: i(167), PluginCache: i(15), PluginManager: i(331), ScenePlugin: i(497),
  };
}, function (t, e, i) { const n = {}; t.exports = n; const s = i(137); const r = (i(194), i(33)); n.create = function (t) { const e = s.create(); const i = { label: 'World', gravity: { x: 0, y: 1, scale: 0.001 }, bounds: { min: { x: -1 / 0, y: -1 / 0 }, max: { x: 1 / 0, y: 1 / 0 } } }; return r.extend(e, i, t); }; }, function (t, e, i) {
  const n = {}; t.exports = n; const s = i(33); n._registry = {}, n.register = function (t) { if (n.isPlugin(t) || s.warn('Plugin.register:', n.toString(t), 'does not implement all required fields.'), t.name in n._registry) { const e = n._registry[t.name]; const i = n.versionParse(t.version).number; const r = n.versionParse(e.version).number; i > r ? (s.warn('Plugin.register:', n.toString(e), 'was upgraded to', n.toString(t)), n._registry[t.name] = t) : i < r ? s.warn('Plugin.register:', n.toString(e), 'can not be downgraded to', n.toString(t)) : t !== e && s.warn('Plugin.register:', n.toString(t), 'is already registered to different plugin object'); } else n._registry[t.name] = t; return t; }, n.resolve = function (t) { return n._registry[n.dependencyParse(t).name]; }, n.toString = function (t) { return typeof t === 'string' ? t : `${t.name || 'anonymous'}@${t.version || t.range || '0.0.0'}`; }, n.isPlugin = function (t) { return t && t.name && t.version && t.install; }, n.isUsed = function (t, e) { return t.used.indexOf(e) > -1; }, n.isFor = function (t, e) { const i = t.for && n.dependencyParse(t.for); return !t.for || e.name === i.name && n.versionSatisfies(e.version, i.range); }, n.use = function (t, e) { if (t.uses = (t.uses || []).concat(e || []), t.uses.length !== 0) { for (var i = n.dependencies(t), r = s.topologicalSort(i), o = [], a = 0; a < r.length; a += 1) if (r[a] !== t.name) { var h = n.resolve(r[a]); h ? n.isUsed(t, h.name) || (n.isFor(h, t) || (s.warn('Plugin.use:', n.toString(h), 'is for', h.for, 'but installed on', `${n.toString(t)}.`), h._warned = !0), h.install ? h.install(t) : (s.warn('Plugin.use:', n.toString(h), 'does not specify an install function.'), h._warned = !0), h._warned ? (o.push(` ${n.toString(h)}`), delete h._warned) : o.push(` ${n.toString(h)}`), t.used.push(h.name)) : o.push(` ${r[a]}`); }o.length > 0 && !h.silent && s.info(o.join('  ')); } else s.warn('Plugin.use:', n.toString(t), 'does not specify any dependencies to install.'); }, n.dependencies = function (t, e) { const i = n.dependencyParse(t); const r = i.name; if (!(r in (e = e || {}))) { t = n.resolve(t) || t, e[r] = s.map(t.uses || [], (e) => { n.isPlugin(e) && n.register(e); const r = n.dependencyParse(e); const o = n.resolve(e); return o && !n.versionSatisfies(o.version, r.range) ? (s.warn('Plugin.dependencies:', n.toString(o), 'does not satisfy', n.toString(r), 'used by', `${n.toString(i)}.`), o._warned = !0, t._warned = !0) : o || (s.warn('Plugin.dependencies:', n.toString(e), 'used by', n.toString(i), 'could not be resolved.'), t._warned = !0), r.name; }); for (let o = 0; o < e[r].length; o += 1)n.dependencies(e[r][o], e); return e; } }, n.dependencyParse = function (t) { return s.isString(t) ? (/^[\w-]+(@(\*|[\^~]?\d+\.\d+\.\d+(-[0-9A-Za-z-]+)?))?$/.test(t) || s.warn('Plugin.dependencyParse:', t, 'is not a valid dependency string.'), { name: t.split('@')[0], range: t.split('@')[1] || '*' }) : { name: t.name, range: t.range || t.version }; }, n.versionParse = function (t) {
    /^\*|[\^~]?\d+\.\d+\.\d+(-[0-9A-Za-z-]+)?$/.test(t) || s.warn('Plugin.versionParse:', t, 'is not a valid version or range.'); const e = t.split('-'); t = e[0]; const i = isNaN(Number(t[0])); const n = i ? t.substr(1) : t; const r = s.map(n.split('.'), (t) => Number(t)); return {
      isRange: i, version: n, range: t, operator: i ? t[0] : '', parts: r, prerelease: e[1], number: 1e8 * r[0] + 1e4 * r[1] + r[2],
    };
  }, n.versionSatisfies = function (t, e) { e = e || '*'; const i = n.versionParse(e); const s = i.parts; const r = n.versionParse(t); const o = r.parts; if (i.isRange) { if (i.operator === '*' || t === '*') return !0; if (i.operator === '~') return o[0] === s[0] && o[1] === s[1] && o[2] >= s[2]; if (i.operator === '^') return s[0] > 0 ? o[0] === s[0] && r.number >= i.number : s[1] > 0 ? o[1] === s[1] && o[2] >= s[2] : o[2] === s[2]; } return t === e || t === '*'; };
}, function (t, e, i) { const n = i(1065); n.Body = i(67), n.Composite = i(137), n.World = i(499), n.Detector = i(503), n.Grid = i(1064), n.Pairs = i(1063), n.Pair = i(418), n.Query = i(1089), n.Resolver = i(1062), n.SAT = i(502), n.Constraint = i(194), n.Common = i(33), n.Engine = i(1061), n.Events = i(195), n.Sleeping = i(222), n.Plugin = i(500), n.Bodies = i(126), n.Composites = i(1068), n.Axes = i(505), n.Bounds = i(80), n.Svg = i(1087), n.Vector = i(81), n.Vertices = i(76), n.World.add = n.Composite.add, n.World.remove = n.Composite.remove, n.World.addComposite = n.Composite.addComposite, n.World.addBody = n.Composite.addBody, n.World.addConstraint = n.Composite.addConstraint, n.World.clear = n.Composite.clear, t.exports = n; }, function (t, e, i) { const n = {}; t.exports = n; const s = i(76); const r = i(81); n.collides = function (t, e, i) { let o; let a; let h; let l; let u = !1; if (i) { const c = t.parent; const d = e.parent; const f = c.speed * c.speed + c.angularSpeed * c.angularSpeed + d.speed * d.speed + d.angularSpeed * d.angularSpeed; u = i && i.collided && f < 0.2, l = i; } else l = { collided: !1, bodyA: t, bodyB: e }; if (i && u) { const p = l.axisBody; const g = p === t ? e : t; const v = [p.axes[i.axisNumber]]; if (h = n._overlapAxes(p.vertices, g.vertices, v), l.reused = !0, h.overlap <= 0) return l.collided = !1, l; } else { if ((o = n._overlapAxes(t.vertices, e.vertices, t.axes)).overlap <= 0) return l.collided = !1, l; if ((a = n._overlapAxes(e.vertices, t.vertices, e.axes)).overlap <= 0) return l.collided = !1, l; o.overlap < a.overlap ? (h = o, l.axisBody = t) : (h = a, l.axisBody = e), l.axisNumber = h.axisNumber; }l.bodyA = t.id < e.id ? t : e, l.bodyB = t.id < e.id ? e : t, l.collided = !0, l.depth = h.overlap, l.parentA = l.bodyA.parent, l.parentB = l.bodyB.parent, t = l.bodyA, e = l.bodyB, r.dot(h.axis, r.sub(e.position, t.position)) < 0 ? l.normal = { x: h.axis.x, y: h.axis.y } : l.normal = { x: -h.axis.x, y: -h.axis.y }, l.tangent = r.perp(l.normal), l.penetration = l.penetration || {}, l.penetration.x = l.normal.x * l.depth, l.penetration.y = l.normal.y * l.depth; const y = n._findSupports(t, e, l.normal); let m = []; if (s.contains(t.vertices, y[0]) && m.push(y[0]), s.contains(t.vertices, y[1]) && m.push(y[1]), m.length < 2) { const x = n._findSupports(e, t, r.neg(l.normal)); s.contains(e.vertices, x[0]) && m.push(x[0]), m.length < 2 && s.contains(e.vertices, x[1]) && m.push(x[1]); } return m.length < 1 && (m = [y[0]]), l.supports = m, l; }, n._overlapAxes = function (t, e, i) { for (var s, o, a = r._temp[0], h = r._temp[1], l = { overlap: Number.MAX_VALUE }, u = 0; u < i.length; u++) { if (o = i[u], n._projectToAxis(a, t, o), n._projectToAxis(h, e, o), (s = Math.min(a.max - h.min, h.max - a.min)) <= 0) return l.overlap = s, l; s < l.overlap && (l.overlap = s, l.axis = o, l.axisNumber = u); } return l; }, n._projectToAxis = function (t, e, i) { for (var n = r.dot(e[0], i), s = n, o = 1; o < e.length; o += 1) { const a = r.dot(e[o], i); a > s ? s = a : a < n && (n = a); }t.min = n, t.max = s; }, n._findSupports = function (t, e, i) { for (var n, s, o, a, h = Number.MAX_VALUE, l = r._temp[0], u = e.vertices, c = t.position, d = 0; d < u.length; d++)s = u[d], l.x = s.x - c.x, l.y = s.y - c.y, (n = -r.dot(i, l)) < h && (h = n, o = s); return s = u[o.index - 1 >= 0 ? o.index - 1 : u.length - 1], l.x = s.x - c.x, l.y = s.y - c.y, h = -r.dot(i, l), a = s, s = u[(o.index + 1) % u.length], l.x = s.x - c.x, l.y = s.y - c.y, (n = -r.dot(i, l)) < h && (a = s), [o, a]; }; }, function (t, e, i) { const n = {}; t.exports = n; const s = i(502); const r = i(418); const o = i(80); n.collisions = function (t, e) { for (var i = [], a = e.pairs.table, h = e.metrics, l = 0; l < t.length; l++) { const u = t[l][0]; const c = t[l][1]; if ((!u.isStatic && !u.isSleeping || !c.isStatic && !c.isSleeping) && n.canCollide(u.collisionFilter, c.collisionFilter) && (h.midphaseTests += 1, o.overlaps(u.bounds, c.bounds))) for (let d = u.parts.length > 1 ? 1 : 0; d < u.parts.length; d++) for (let f = u.parts[d], p = c.parts.length > 1 ? 1 : 0; p < c.parts.length; p++) { const g = c.parts[p]; if (f === u && g === c || o.overlaps(f.bounds, g.bounds)) { var v; const y = a[r.id(f, g)]; v = y && y.isActive ? y.collision : null; const m = s.collides(f, g, v); h.narrowphaseTests += 1, m.reused && (h.narrowReuseCount += 1), m.collided && (i.push(m), h.narrowDetections += 1); } } } return i; }, n.canCollide = function (t, e) { return t.group === e.group && t.group !== 0 ? t.group > 0 : (t.mask & e.category) != 0 && (e.mask & t.category) != 0; }; }, function (t, e, i) {
  const n = i(126); const s = i(67); const r = i(0); const o = i(419); const a = i(2); const h = i(85); const l = i(76); const u = new r({
    Mixins: [o.Bounce, o.Collision, o.Friction, o.Gravity, o.Mass, o.Sensor, o.Sleep, o.Static], initialize(t, e, i) { this.tile = e, this.world = t, e.physics.matterBody && e.physics.matterBody.destroy(), e.physics.matterBody = this; const n = a(i, 'body', null); const s = a(i, 'addToWorld', !0); if (n) this.setBody(n, s); else { const r = e.getCollisionGroup(); a(r, 'objects', []).length > 0 ? this.setFromTileCollision(i) : this.setFromTileRectangle(i); } }, setFromTileRectangle(t) { void 0 === t && (t = {}), h(t, 'isStatic') || (t.isStatic = !0), h(t, 'addToWorld') || (t.addToWorld = !0); const e = this.tile.getBounds(); const i = e.x + e.width / 2; const s = e.y + e.height / 2; const r = n.rectangle(i, s, e.width, e.height, t); return this.setBody(r, t.addToWorld), this; }, setFromTileCollision(t) { void 0 === t && (t = {}), h(t, 'isStatic') || (t.isStatic = !0), h(t, 'addToWorld') || (t.addToWorld = !0); for (var e = this.tile.tilemapLayer.scaleX, i = this.tile.tilemapLayer.scaleY, r = this.tile.getLeft(), o = this.tile.getTop(), u = this.tile.getCollisionGroup(), c = a(u, 'objects', []), d = [], f = 0; f < c.length; f++) { const p = c[f]; let g = r + p.x * e; let v = o + p.y * i; const y = p.width * e; const m = p.height * i; let x = null; if (p.rectangle)x = n.rectangle(g + y / 2, v + m / 2, y, m, t); else if (p.ellipse)x = n.circle(g + y / 2, v + m / 2, y / 2, t); else if (p.polygon || p.polyline) { const w = (p.polygon ? p.polygon : p.polyline).map((t) => ({ x: t.x * e, y: t.y * i })); const b = l.create(w); if (l.isConvex(w)) { const T = l.centre(b); g += T.x, v += T.y; }x = n.fromVertices(g, v, b, t); }x && d.push(x); } return d.length === 1 ? this.setBody(d[0], t.addToWorld) : d.length > 1 && (t.parts = d, this.setBody(s.create(t), t.addToWorld)), this; }, setBody(t, e) { return void 0 === e && (e = !0), this.body && this.removeBody(), this.body = t, this.body.gameObject = this, e && this.world.add(this.body), this; }, removeBody() { return this.body && (this.world.remove(this.body), this.body.gameObject = void 0, this.body = void 0), this; }, destroy() { this.removeBody(), this.tile.physics.matterBody = void 0; },
  }); t.exports = u;
}, function (t, e, i) { const n = {}; t.exports = n; const s = i(81); const r = i(33); n.fromVertices = function (t) { for (var e = {}, i = 0; i < t.length; i++) { const n = (i + 1) % t.length; const o = s.normalise({ x: t[n].y - t[i].y, y: t[i].x - t[n].x }); let a = o.y === 0 ? 1 / 0 : o.x / o.y; e[a = a.toFixed(3).toString()] = o; } return r.values(e); }, n.rotate = function (t, e) { if (e !== 0) for (let i = Math.cos(e), n = Math.sin(e), s = 0; s < t.length; s++) { var r; const o = t[s]; r = o.x * i - o.y * n, o.y = o.x * n + o.y * i, o.x = r; } }; }, function (t, e, i) {
  t.exports = {
    Acceleration: i(1121), BodyScale: i(1120), BodyType: i(1119), Bounce: i(1118), CheckAgainst: i(1117), Collides: i(1116), Debug: i(1115), Friction: i(1114), Gravity: i(1113), Offset: i(1112), SetGameObject: i(1111), Velocity: i(1110),
  };
}, function (t, e, i) { const n = i(229); t.exports = function (t, e, i, s) { let r = n(t, e, i, s); if (i || r === 0 || t.immovable && e.immovable || t.customSeparateY || e.customSeparateY) return r !== 0 || t.embedded && e.embedded; const o = t.velocity.y; const a = e.velocity.y; if (t.immovable || e.immovable)t.immovable ? (e.y += r, e.velocity.y = o - a * e.bounce.y, t.moves && (e.x += (t.x - t.prev.x) * t.friction.x)) : (t.y -= r, t.velocity.y = a - o * t.bounce.y, e.moves && (t.x += (e.x - e.prev.x) * e.friction.x)); else { r *= 0.5, t.y -= r, e.y += r; let h = Math.sqrt(a * a * e.mass / t.mass) * (a > 0 ? 1 : -1); let l = Math.sqrt(o * o * t.mass / e.mass) * (o > 0 ? 1 : -1); const u = 0.5 * (h + l); h -= u, l -= u, t.velocity.y = u + h * t.bounce.y, e.velocity.y = u + l * e.bounce.y; } return !0; }; }, function (t, e, i) { const n = i(230); t.exports = function (t, e, i, s) { let r = n(t, e, i, s); if (i || r === 0 || t.immovable && e.immovable || t.customSeparateX || e.customSeparateX) return r !== 0 || t.embedded && e.embedded; const o = t.velocity.x; const a = e.velocity.x; if (t.immovable || e.immovable)t.immovable ? (e.x += r, e.velocity.x = o - a * e.bounce.x, t.moves && (e.y += (t.y - t.prev.y) * t.friction.y)) : (t.x -= r, t.velocity.x = a - o * t.bounce.x, e.moves && (t.y += (e.y - e.prev.y) * e.friction.y)); else { r *= 0.5, t.x -= r, e.x += r; let h = Math.sqrt(a * a * e.mass / t.mass) * (a > 0 ? 1 : -1); let l = Math.sqrt(o * o * t.mass / e.mass) * (o > 0 ? 1 : -1); const u = 0.5 * (h + l); h -= u, l -= u, t.velocity.x = u + h * t.bounce.x, e.velocity.x = u + l * e.bounce.x; } return !0; }; }, function (t, e) { t.exports = function (t, e) { e < 0 ? (t.blocked.none = !1, t.blocked.up = !0) : e > 0 && (t.blocked.none = !1, t.blocked.down = !0), t.position.y -= e, t.bounce.y === 0 ? t.velocity.y = 0 : t.velocity.y = -t.velocity.y * t.bounce.y; }; }, function (t, e, i) { const n = i(509); t.exports = function (t, e, i, s, r) { let o = 0; return t.deltaY() < 0 && !t.blocked.up && e.collideDown && t.checkCollision.up ? e.faceBottom && t.y < s && (o = t.y - s) < -r && (o = 0) : t.deltaY() > 0 && !t.blocked.down && e.collideUp && t.checkCollision.down && e.faceTop && t.bottom > i && (o = t.bottom - i) > r && (o = 0), o !== 0 && (t.customSeparateY ? t.overlapY = o : n(t, o)), o; }; }, function (t, e) { t.exports = function (t, e) { e < 0 ? (t.blocked.none = !1, t.blocked.left = !0) : e > 0 && (t.blocked.none = !1, t.blocked.right = !0), t.position.x -= e, t.bounce.x === 0 ? t.velocity.x = 0 : t.velocity.x = -t.velocity.x * t.bounce.x; }; }, function (t, e, i) { const n = i(511); t.exports = function (t, e, i, s, r) { let o = 0; return t.deltaX() < 0 && !t.blocked.left && e.collideRight && t.checkCollision.left ? e.faceRight && t.x < s && (o = t.x - s) < -r && (o = 0) : t.deltaX() > 0 && !t.blocked.right && e.collideLeft && t.checkCollision.right && e.faceLeft && t.right > i && (o = t.right - i) > r && (o = 0), o !== 0 && (t.customSeparateX ? t.overlapX = o : n(t, o)), o; }; }, function (t, e, i) { const n = i(512); const s = i(510); const r = i(226); t.exports = function (t, e, i, o, a, h) { const l = o.left; const u = o.top; const c = o.right; const d = o.bottom; const f = i.faceLeft || i.faceRight; const p = i.faceTop || i.faceBottom; if (!f && !p) return !1; let g = 0; let v = 0; let y = 0; let m = 1; if (e.deltaAbsX() > e.deltaAbsY() ? y = -1 : e.deltaAbsX() < e.deltaAbsY() && (m = -1), e.deltaX() !== 0 && e.deltaY() !== 0 && f && p && (y = Math.min(Math.abs(e.position.x - c), Math.abs(e.right - l)), m = Math.min(Math.abs(e.position.y - d), Math.abs(e.bottom - u))), y < m) { if (f && (g = n(e, i, l, c, h)) !== 0 && !r(o, e)) return !0; p && (v = s(e, i, u, d, h)); } else { if (p && (v = s(e, i, u, d, h)) !== 0 && !r(o, e)) return !0; f && (g = n(e, i, l, c, h)); } return g !== 0 || v !== 0; }; }, function (t, e) { t.exports = function (t, e) { return t.collisionCallback ? !t.collisionCallback.call(t.collisionCallbackContext, e, t) : !t.layer.callbacks[t.index] || !t.layer.callbacks[t.index].callback.call(t.layer.callbacks[t.index].callbackContext, e, t); }; }, function (t, e) {
  t.exports = {
    setVelocity(t, e) { return this.body.setVelocity(t, e), this; }, setVelocityX(t) { return this.body.setVelocityX(t), this; }, setVelocityY(t) { return this.body.setVelocityY(t), this; }, setMaxVelocity(t, e) { return this.body.maxVelocity.set(t, e), this; },
  };
}, function (t, e) { t.exports = { setOffset(t, e) { return this.body.setOffset(t, e), this; }, setSize(t, e, i) { return this.body.setSize(t, e, i), this; }, setCircle(t, e, i) { return this.body.setCircle(t, e, i), this; } }; }, function (t, e) { t.exports = { setMass(t) { return this.body.mass = t, this; } }; }, function (t, e) { const i = { setImmovable(t) { return void 0 === t && (t = !0), this.body.immovable = t, this; } }; t.exports = i; }, function (t, e) { t.exports = { setGravity(t, e) { return this.body.gravity.set(t, e), this; }, setGravityX(t) { return this.body.gravity.x = t, this; }, setGravityY(t) { return this.body.gravity.y = t, this; } }; }, function (t, e) { t.exports = { setFriction(t, e) { return this.body.friction.set(t, e), this; }, setFrictionX(t) { return this.body.friction.x = t, this; }, setFrictionY(t) { return this.body.friction.y = t, this; } }; }, function (t, e) { const i = { enableBody(t, e, i, n, s) { return t && this.body.reset(e, i), n && (this.body.gameObject.active = !0), s && (this.body.gameObject.visible = !0), this.body.enable = !0, this; }, disableBody(t, e) { return void 0 === t && (t = !1), void 0 === e && (e = !1), this.body.stop(), this.body.enable = !1, t && (this.body.gameObject.active = !1), e && (this.body.gameObject.visible = !1), this; }, refreshBody() { return this.body.updateFromGameObject(), this; } }; t.exports = i; }, function (t, e) {
  t.exports = {
    setDrag(t, e) { return this.body.drag.set(t, e), this; }, setDragX(t) { return this.body.drag.x = t, this; }, setDragY(t) { return this.body.drag.y = t, this; }, setDamping(t) { return this.body.useDamping = t, this; },
  };
}, function (t, e) {
  t.exports = {
    setDebug(t, e, i) { return this.debugShowBody = t, this.debugShowVelocity = e, this.debugBodyColor = i, this; }, setDebugBodyColor(t) { return this.body.debugBodyColor = t, this; }, debugShowBody: { get() { return this.body.debugShowBody; }, set(t) { this.body.debugShowBody = t; } }, debugShowVelocity: { get() { return this.body.debugShowVelocity; }, set(t) { this.body.debugShowVelocity = t; } }, debugBodyColor: { get() { return this.body.debugBodyColor; }, set(t) { this.body.debugBodyColor = t; } },
  };
}, function (t, e) {
  t.exports = {
    setBounce(t, e) { return this.body.bounce.set(t, e), this; }, setBounceX(t) { return this.body.bounce.x = t, this; }, setBounceY(t) { return this.body.bounce.y = t, this; }, setCollideWorldBounds(t) { return this.body.collideWorldBounds = t, this; },
  };
}, function (t, e) { t.exports = { setAngularVelocity(t) { return this.body.angularVelocity = t, this; }, setAngularAcceleration(t) { return this.body.angularAcceleration = t, this; }, setAngularDrag(t) { return this.body.angularDrag = t, this; } }; }, function (t, e) { t.exports = { setAcceleration(t, e) { return this.body.acceleration.set(t, e), this; }, setAccelerationX(t) { return this.body.acceleration.x = t, this; }, setAccelerationY(t) { return this.body.acceleration.y = t, this; } }; }, function (t, e, i) {
  const n = i(0); const s = i(31); const r = i(52); const o = i(249); const a = i(238); const h = i(2); const l = i(96); const u = i(15); const c = i(3); const d = i(233); const f = new n({
    initialize(t) { this.scene = t, this.systems = t.sys, this.config = this.getConfig(), this.world, this.add, t.sys.events.once('boot', this.boot, this), t.sys.events.on('start', this.start, this); }, boot() { this.world = new d(this.scene, this.config), this.add = new a(this.world), this.systems.events.once('destroy', this.destroy, this); }, start() { this.world || (this.world = new d(this.scene, this.config), this.add = new a(this.world)); const t = this.systems.events; t.on('update', this.world.update, this.world), t.on('postupdate', this.world.postUpdate, this.world), t.once('shutdown', this.shutdown, this); }, getConfig() { const t = this.systems.game.config.physics; const e = this.systems.settings.physics; return l(h(e, 'arcade', {}), h(t, 'arcade', {})); }, overlap(t, e, i, n, s) { return void 0 === i && (i = null), void 0 === n && (n = null), void 0 === s && (s = i), this.world.collideObjects(t, e, i, n, s, !0); }, collide(t, e, i, n, s) { return void 0 === i && (i = null), void 0 === n && (n = null), void 0 === s && (s = i), this.world.collideObjects(t, e, i, n, s, !1); }, pause() { return this.world.pause(); }, resume() { return this.world.resume(); }, accelerateTo(t, e, i, n, s, r) { void 0 === n && (n = 60); const o = Math.atan2(i - t.y, e - t.x); return t.body.acceleration.setToPolar(o, n), void 0 !== s && void 0 !== r && t.body.maxVelocity.set(s, r), o; }, accelerateToObject(t, e, i, n, s) { return this.accelerateTo(t, e.x, e.y, i, n, s); }, closest(t) { for (var e = this.world.tree.all(), i = Number.MAX_VALUE, n = null, s = t.x, r = t.y, a = e.length - 1; a >= 0; a--) { const h = e[a]; const l = o(s, r, h.x, h.y); l < i && (n = h, i = l); } return n; }, furthest(t) { for (var e = this.world.tree.all(), i = -1, n = null, s = t.x, r = t.y, a = e.length - 1; a >= 0; a--) { const h = e[a]; const l = o(s, r, h.x, h.y); l > i && (n = h, i = l); } return n; }, moveTo(t, e, i, n, s) { void 0 === n && (n = 60), void 0 === s && (s = 0); const o = Math.atan2(i - t.y, e - t.x); return s > 0 && (n = r(t.x, t.y, e, i) / (s / 1e3)), t.body.velocity.setToPolar(o, n), o; }, moveToObject(t, e, i, n) { return this.moveTo(t, e.x, e.y, i, n); }, velocityFromAngle(t, e, i) { return void 0 === e && (e = 60), void 0 === i && (i = new c()), i.setToPolar(s(t), e); }, velocityFromRotation(t, e, i) { return void 0 === e && (e = 60), void 0 === i && (i = new c()), i.setToPolar(t, e); }, shutdown() { if (this.world) { const t = this.systems.events; t.off('update', this.world.update, this.world), t.off('postupdate', this.world.postUpdate, this.world), t.off('shutdown', this.shutdown, this), this.add.destroy(), this.world.destroy(), this.add = null, this.world = null; } }, destroy() { this.shutdown(), this.scene.sys.events.off('start', this.start, this), this.scene = null, this.systems = null; },
  }); u.register('ArcadePhysics', f, 'arcadePhysics'), t.exports = f;
}, function (t, e, i) {
  const n = i(35); const s = i(20); let r = {
    ArcadePhysics: i(527), Body: i(232), Collider: i(231), Factory: i(238), Group: i(235), Image: i(237), Sprite: i(104), StaticBody: i(225), StaticGroup: i(234), World: i(233),
  }; r = s(!1, r, n), t.exports = r;
}, function (t, e, i) { const n = i(138); const s = i(240); const r = i(239); const o = new s(); const a = new r(); const h = new n(); t.exports = function (t, e, i) { return a.setAxisAngle(e, i), o.fromRotationTranslation(a, h.set(0, 0, 0)), t.transformMat4(o); }; }, function (t, e, i) {
  var n = new (i(0))({
    initialize(t, e, i, n) { this.x = 0, this.y = 0, this.z = 0, this.w = 0, typeof t === 'object' ? (this.x = t.x || 0, this.y = t.y || 0, this.z = t.z || 0, this.w = t.w || 0) : (this.x = t || 0, this.y = e || 0, this.z = i || 0, this.w = n || 0); }, clone() { return new n(this.x, this.y, this.z, this.w); }, copy(t) { return this.x = t.x, this.y = t.y, this.z = t.z || 0, this.w = t.w || 0, this; }, equals(t) { return this.x === t.x && this.y === t.y && this.z === t.z && this.w === t.w; }, set(t, e, i, n) { return typeof t === 'object' ? (this.x = t.x || 0, this.y = t.y || 0, this.z = t.z || 0, this.w = t.w || 0) : (this.x = t || 0, this.y = e || 0, this.z = i || 0, this.w = n || 0), this; }, add(t) { return this.x += t.x, this.y += t.y, this.z += t.z || 0, this.w += t.w || 0, this; }, subtract(t) { return this.x -= t.x, this.y -= t.y, this.z -= t.z || 0, this.w -= t.w || 0, this; }, scale(t) { return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this; }, length() { const t = this.x; const e = this.y; const i = this.z; const n = this.w; return Math.sqrt(t * t + e * e + i * i + n * n); }, lengthSq() { const t = this.x; const e = this.y; const i = this.z; const n = this.w; return t * t + e * e + i * i + n * n; }, normalize() { const t = this.x; const e = this.y; const i = this.z; const n = this.w; let s = t * t + e * e + i * i + n * n; return s > 0 && (s = 1 / Math.sqrt(s), this.x = t * s, this.y = e * s, this.z = i * s, this.w = n * s), this; }, dot(t) { return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w; }, lerp(t, e) { void 0 === e && (e = 0); const i = this.x; const n = this.y; const s = this.z; const r = this.w; return this.x = i + e * (t.x - i), this.y = n + e * (t.y - n), this.z = s + e * (t.z - s), this.w = r + e * (t.w - r), this; }, multiply(t) { return this.x *= t.x, this.y *= t.y, this.z *= t.z || 1, this.w *= t.w || 1, this; }, divide(t) { return this.x /= t.x, this.y /= t.y, this.z /= t.z || 1, this.w /= t.w || 1, this; }, distance(t) { const e = t.x - this.x; const i = t.y - this.y; const n = t.z - this.z || 0; const s = t.w - this.w || 0; return Math.sqrt(e * e + i * i + n * n + s * s); }, distanceSq(t) { const e = t.x - this.x; const i = t.y - this.y; const n = t.z - this.z || 0; const s = t.w - this.w || 0; return e * e + i * i + n * n + s * s; }, negate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this; }, transformMat4(t) { const e = this.x; const i = this.y; const n = this.z; const s = this.w; const r = t.val; return this.x = r[0] * e + r[4] * i + r[8] * n + r[12] * s, this.y = r[1] * e + r[5] * i + r[9] * n + r[13] * s, this.z = r[2] * e + r[6] * i + r[10] * n + r[14] * s, this.w = r[3] * e + r[7] * i + r[11] * n + r[15] * s, this; }, transformQuat(t) { const e = this.x; const i = this.y; const n = this.z; const s = t.x; const r = t.y; const o = t.z; const a = t.w; const h = a * e + r * n - o * i; const l = a * i + o * e - s * n; const u = a * n + s * i - r * e; const c = -s * e - r * i - o * n; return this.x = h * a + c * -s + l * -o - u * -r, this.y = l * a + c * -r + u * -s - h * -o, this.z = u * a + c * -o + h * -r - l * -s, this; }, reset() { return this.x = 0, this.y = 0, this.z = 0, this.w = 0, this; },
  }); n.prototype.sub = n.prototype.subtract, n.prototype.mul = n.prototype.multiply, n.prototype.div = n.prototype.divide, n.prototype.dist = n.prototype.distance, n.prototype.distSq = n.prototype.distanceSq, n.prototype.len = n.prototype.length, n.prototype.lenSq = n.prototype.lengthSq, t.exports = n;
}, function (t, e) { t.exports = function (t, e, i) { return Math.abs(t - e) <= i; }; }, function (t, e) { t.exports = function (t, e, i, n) { void 0 === e && (e = 1), void 0 === i && (i = 1), void 0 === n && (n = 1), n *= Math.PI / t; for (var s = [], r = [], o = 0; o < t; o++)e += (i -= e * n) * n, s[o] = i, r[o] = e; return { sin: r, cos: s, length: t }; }; }, function (t, e) { t.exports = function (t, e, i) { void 0 === e && (e = 0), void 0 === i && (i = 10); const n = Math.pow(i, -e); return Math.round(t * n) / n; }; }, function (t, e) { t.exports = function (t, e) { return void 0 === e && (e = 1), t.x = (2 * Math.random() - 1) * e, t.y = (2 * Math.random() - 1) * e, t.z = (2 * Math.random() - 1) * e, t.w = (2 * Math.random() - 1) * e, t; }; }, function (t, e) { t.exports = function (t, e) { void 0 === e && (e = 1); const i = 2 * Math.random() * Math.PI; const n = 2 * Math.random() - 1; const s = Math.sqrt(1 - n * n) * e; return t.x = Math.cos(i) * s, t.y = Math.sin(i) * s, t.z = n * e, t; }; }, function (t, e) { t.exports = function (t, e) { void 0 === e && (e = 1); const i = 2 * Math.random() * Math.PI; return t.x = Math.cos(i) * e, t.y = Math.sin(i) * e, t; }; }, function (t, e) { t.exports = function (t, e, i, n) { void 0 === i && (i = e + 1); let s = (t - e) / (i - e); return s > 1 ? void 0 !== n ? (s = (n - t) / (n - i)) < 0 && (s = 0) : s = 1 : s < 0 && (s = 0), s; }; }, function (t, e) { t.exports = function (t, e, i) { return Math.max(t - e, i); }; }, function (t, e) { t.exports = function (t, e, i) { return Math.min(t + e, i); }; }, function (t, e) { t.exports = function (t) { return t === parseFloat(t) ? !(t % 2) : void 0; }; }, function (t, e) { t.exports = function (t) { return t == parseFloat(t) ? !(t % 2) : void 0; }; }, function (t, e) { t.exports = function (t, e) { return t / e / 1e3; }; }, function (t, e) { t.exports = function (t, e, i) { void 0 === e && (e = 0), void 0 === i && (i = 10); const n = Math.pow(i, -e); return Math.floor(t * n) / n; }; }, function (t, e) { t.exports = function (t, e) { return Math.abs(t - e); }; }, function (t, e) { t.exports = function (t, e, i) { void 0 === e && (e = 0), void 0 === i && (i = 10); const n = Math.pow(i, -e); return Math.ceil(t * n) / n; }; }, function (t, e) { t.exports = function (t) { for (var e = 0, i = 0; i < t.length; i++)e += +t[i]; return e / t.length; }; }, function (t, e) { t.exports = function (t, e, i, n) { return void 0 === i && (i = 0), e === 0 ? t : (t -= i, t = e * Math.round(t / e), n ? (i + t) / e : i + t); }; }, function (t, e, i) { t.exports = { Ceil: i(243), Floor: i(142), To: i(547) }; }, function (t, e) { t.exports = function (t) { return t > 0 && (t & t - 1) == 0; }; }, function (t, e, i) { t.exports = { GetNext: i(294), IsSize: i(117), IsValue: i(549) }; }, function (t, e, i) { const n = i(182); t.exports = function (t, e, i) { return e + (i - e) * n(t, 0, 1); }; }, function (t, e, i) { const n = i(119); t.exports = function (t, e) { const i = t.length - 1; const s = i * e; const r = Math.floor(s); return e < 0 ? n(t[0], t[1], s) : e > 1 ? n(t[i], t[i - 1], i - s) : n(t[r], t[r + 1 > i ? i : r + 1], s - r); }; }, function (t, e, i) { const n = i(171); t.exports = function (t, e) { const i = t.length - 1; let s = i * e; let r = Math.floor(s); return t[0] === t[i] ? (e < 0 && (r = Math.floor(s = i * (1 + e))), n(s - r, t[(r - 1 + i) % i], t[r], t[(r + 1) % i], t[(r + 2) % i])) : e < 0 ? t[0] - (n(-s, t[0], t[0], t[1], t[1]) - t[0]) : e > 1 ? t[i] - (n(s - i, t[i], t[i], t[i - 1], t[i - 1]) - t[i]) : n(s - r, t[r ? r - 1 : 0], t[r], t[i < r + 1 ? i : r + 1], t[i < r + 2 ? i : r + 2]); }; }, function (t, e, i) { const n = i(245); t.exports = function (t, e) { for (var i = 0, s = t.length - 1, r = 0; r <= s; r++)i += Math.pow(1 - e, s - r) * Math.pow(e, r) * t[r] * n(s, r); return i; }; }, function (t, e, i) {
  t.exports = {
    Bezier: i(554), CatmullRom: i(553), CubicBezier: i(354), Linear: i(552), QuadraticBezier: i(350), SmoothStep: i(334), SmootherStep: i(551),
  };
}, function (t, e) { t.exports = function (t, e) { return void 0 === e && (e = 1e-4), Math.floor(t + e); }; }, function (t, e) { t.exports = function (t, e) { return void 0 === e && (e = 1e-4), Math.ceil(t - e); }; }, function (t, e, i) {
  t.exports = {
    Ceil: i(557), Equal: i(248), Floor: i(556), GreaterThan: i(247), LessThan: i(246),
  };
}, function (t, e, i) {
  t.exports = {
    Back: i(369), Bounce: i(368), Circular: i(367), Cubic: i(366), Elastic: i(365), Expo: i(364), Linear: i(363), Quadratic: i(362), Quartic: i(361), Quintic: i(360), Sine: i(359), Stepped: i(358),
  };
}, function (t, e) { t.exports = function (t, e, i, n, s) { return void 0 === s && (s = 2), Math.sqrt(Math.pow(i - t, s) + Math.pow(n - e, s)); }; }, function (t, e, i) { t.exports = { Between: i(52), Power: i(560), Squared: i(249) }; }, function (t, e) { t.exports = function (t, e) { const i = e - t; return i === 0 ? 0 : i - 360 * Math.floor((i - -180) / 360); }; }, function (t, e, i) { const n = i(16); t.exports = function (t, e, i) { return void 0 === i && (i = 0.05), t === e ? t : (Math.abs(e - t) <= i || Math.abs(e - t) >= n.PI2 - i ? t = e : (Math.abs(e - t) > Math.PI && (e < t ? e += n.PI2 : e -= n.PI2), e > t ? t += i : e < t && (t -= i)), t); }; }, function (t, e, i) { const n = i(250); t.exports = function (t) { return n(t + Math.PI); }; }, function (t, e) { t.exports = function (t, e) { return Math.atan2(e.x - t.x, e.y - t.y); }; }, function (t, e) { t.exports = function (t, e) { return Math.atan2(e.y - t.y, e.x - t.x); }; }, function (t, e) { t.exports = function (t, e, i, n) { return Math.atan2(i - t, n - e); }; }, function (t, e) { t.exports = function (t, e, i, n) { return Math.atan2(n - e, i - t); }; }, function (t, e, i) {
  t.exports = {
    Between: i(568), BetweenY: i(567), BetweenPoints: i(566), BetweenPointsY: i(565), Reverse: i(564), RotateTo: i(563), ShortestBetween: i(562), Normalize: i(250), Wrap: i(199), WrapDegrees: i(198),
  };
}, function (t, e, i) {
  const n = i(16); const s = i(20); let r = {
    Angle: i(569), Distance: i(561), Easing: i(559), Fuzzy: i(558), Interpolation: i(555), Pow2: i(550), Snap: i(548), RandomDataGenerator: i(404), Average: i(546), Bernstein: i(245), Between: i(170), CatmullRom: i(171), CeilTo: i(545), Clamp: i(23), DegToRad: i(31), Difference: i(544), Factorial: i(244), FloatBetween: i(299), FloorTo: i(543), FromPercent: i(93), GetSpeed: i(542), IsEven: i(541), IsEvenStrict: i(540), Linear: i(119), MaxAdd: i(539), MinSub: i(538), Percent: i(537), RadToDeg: i(172), RandomXY: i(536), RandomXYZ: i(535), RandomXYZW: i(534), Rotate: i(242), RotateAround: i(396), RotateAroundDistance: i(183), RoundAwayFromZero: i(314), RoundTo: i(533), SinCosTableGenerator: i(532), SmootherStep: i(182), SmoothStep: i(181), TransformXY: i(332), Within: i(531), Wrap: i(53), Vector2: i(3), Vector3: i(138), Vector4: i(530), Matrix3: i(241), Matrix4: i(240), Quaternion: i(239), RotateVec3: i(529),
  }; r = s(!1, r, n), t.exports = r;
}, function (t, e, i) {
  const n = i(0); const s = i(18); const r = i(95); const o = i(11); const a = i(7); const h = i(2); const l = i(15); const u = i(105); const c = new n({
    Extends: o, initialize(t) { o.call(this); const e = t.sys.game.config; const i = t.sys.settings.loader; this.scene = t, this.systems = t.sys, this.cacheManager = t.sys.cache, this.textureManager = t.sys.textures, a.install(this), this.prefix = '', this.path = '', this.baseURL = '', this.setBaseURL(h(i, 'baseURL', e.loaderBaseURL)), this.setPath(h(i, 'path', e.loaderPath)), this.setPrefix(h(i, 'prefix', e.loaderPrefix)), this.maxParallelDownloads = h(i, 'maxParallelDownloads', e.loaderMaxParallelDownloads), this.xhr = u(h(i, 'responseType', e.loaderResponseType), h(i, 'async', e.loaderAsync), h(i, 'user', e.loaderUser), h(i, 'password', e.loaderPassword), h(i, 'timeout', e.loaderTimeout)), this.crossOrigin = h(i, 'crossOrigin', e.loaderCrossOrigin), this.totalToLoad = 0, this.progress = 0, this.list = new r(), this.inflight = new r(), this.queue = new r(), this._deleteQueue = new r(), this.totalFailed = 0, this.totalComplete = 0, this.state = s.LOADER_IDLE, t.sys.events.once('boot', this.boot, this), t.sys.events.on('start', this.pluginStart, this); }, boot() { this.systems.events.once('destroy', this.destroy, this); }, pluginStart() { this.systems.events.once('shutdown', this.shutdown, this); }, setBaseURL(t) { return void 0 === t && (t = ''), t !== '' && t.substr(-1) !== '/' && (t = t.concat('/')), this.baseURL = t, this; }, setPath(t) { return void 0 === t && (t = ''), t !== '' && t.substr(-1) !== '/' && (t = t.concat('/')), this.path = t, this; }, setPrefix(t) { return void 0 === t && (t = ''), this.prefix = t, this; }, setCORS(t) { return this.crossOrigin = t, this; }, addFile(t) { Array.isArray(t) || (t = [t]); for (let e = 0; e < t.length; e++) { const i = t[e]; this.keyExists(i) || (this.list.set(i), this.emit('addfile', i.key, i.type, this, i), this.isLoading() && (this.totalToLoad++, this.updateProgress())); } }, keyExists(t) { let e = t.hasCacheConflict(); return e || this.list.iterate((i) => { if (i.type === t.type && i.key === t.key) return e = !0, !1; }), !e && this.isLoading() && (this.inflight.iterate((i) => { if (i.type === t.type && i.key === t.key) return e = !0, !1; }), this.queue.iterate((i) => { if (i.type === t.type && i.key === t.key) return e = !0, !1; })), e; }, addPack(t, e) { e && t.hasOwnProperty(e) && (t = { packKey: t[e] }); let i = 0; const n = this.baseURL; const s = this.path; const r = this.prefix; for (const o in t) { const a = t[o]; const l = h(a, 'baseURL', n); const u = h(a, 'path', s); const c = h(a, 'prefix', r); const d = h(a, 'files', null); const f = h(a, 'defaultType', 'void'); if (Array.isArray(d)) { this.setBaseURL(l), this.setPath(u), this.setPrefix(c); for (let p = 0; p < d.length; p++) { const g = d[p]; const v = g.hasOwnProperty('type') ? g.type : f; this[v] && (this[v](g), i++); } } } return this.setBaseURL(n), this.setPath(s), this.setPrefix(r), i > 0; }, isLoading() { return this.state === s.LOADER_LOADING || this.state === s.LOADER_PROCESSING; }, isReady() { return this.state === s.LOADER_IDLE || this.state === s.LOADER_COMPLETE; }, start() { this.isReady() && (this.progress = 0, this.totalFailed = 0, this.totalComplete = 0, this.totalToLoad = this.list.size, this.emit('start', this), this.list.size === 0 ? this.loadComplete() : (this.state = s.LOADER_LOADING, this.inflight.clear(), this.queue.clear(), this.updateProgress(), this.checkLoadQueue(), this.systems.events.on('update', this.update, this))); }, updateProgress() { this.progress = 1 - (this.list.size + this.inflight.size) / this.totalToLoad, this.emit('progress', this.progress); }, update() { this.state === s.LOADER_LOADING && this.list.size > 0 && this.inflight.size < this.maxParallelDownloads && this.checkLoadQueue(); }, checkLoadQueue() { this.list.each(function (t) { if ((t.state === s.FILE_POPULATED || t.state === s.FILE_PENDING && this.inflight.size < this.maxParallelDownloads) && (this.inflight.set(t), this.list.delete(t), t.crossOrigin || (t.crossOrigin = this.crossOrigin), t.load()), this.inflight.size === this.maxParallelDownloads) return !1; }, this); }, nextFile(t, e) { this.inflight && (this.inflight.delete(t), this.updateProgress(), e ? (this.totalComplete++, this.queue.set(t), this.emit('load', t), t.onProcess()) : (this.totalFailed++, this._deleteQueue.set(t), this.emit('loaderror', t), this.fileProcessComplete(t))); }, fileProcessComplete(t) { this.scene && this.systems && this.systems.game && !this.systems.game.pendingDestroy && (t.state === s.FILE_ERRORED ? t.multiFile && t.multiFile.onFileFailed(t) : t.state === s.FILE_COMPLETE && (t.multiFile ? t.multiFile.isReadyToProcess() && t.multiFile.addToCache() : t.addToCache()), this.queue.delete(t), this.list.size === 0 && this.inflight.size === 0 && this.queue.size === 0 && this.loadComplete()); }, loadComplete() { this.emit('loadcomplete', this), this.list.clear(), this.inflight.clear(), this.queue.clear(), this.progress = 1, this.state = s.LOADER_COMPLETE, this.systems.events.off('update', this.update, this), this._deleteQueue.iterateLocal('destroy'), this._deleteQueue.clear(), this.emit('complete', this, this.totalComplete, this.totalFailed); }, flagForRemoval(t) { this._deleteQueue.set(t); }, saveJSON(t, e) { return this.save(JSON.stringify(t), e); }, save(t, e, i) { void 0 === e && (e = 'file.json'), void 0 === i && (i = 'application/json'); const n = new Blob([t], { type: i }); const s = URL.createObjectURL(n); const r = document.createElement('a'); return r.download = e, r.textContent = `Download ${e}`, r.href = s, r.click(), this; }, reset() { this.list.clear(), this.inflight.clear(), this.queue.clear(); const t = this.systems.game.config; const e = this.systems.settings.loader; this.setBaseURL(h(e, 'baseURL', t.loaderBaseURL)), this.setPath(h(e, 'path', t.loaderPath)), this.setPrefix(h(e, 'prefix', t.loaderPrefix)), this.state = s.LOADER_IDLE; }, shutdown() { this.reset(), this.state = s.LOADER_SHUTDOWN, this.systems.events.off('update', this.update, this), this.systems.events.off('shutdown', this.shutdown, this); }, destroy() { this.shutdown(), this.state = s.LOADER_DESTROYED, this.systems.events.off('update', this.update, this), this.systems.events.off('start', this.pluginStart, this), this.list = null, this.inflight = null, this.queue = null, this.scene = null, this.systems = null, this.textureManager = null, this.cacheManager = null; },
  }); l.register('Loader', c, 'load'), t.exports = c;
}, function (t, e, i) {
  const n = i(0); const s = i(7); const r = i(2); const o = i(58); const a = i(8); const h = i(57); const l = i(251); const u = new n({
    Extends: h,
    initialize(t, e, i, n, s, u) {
      let c; let d; if (a(e)) {
        const f = e; c = new o(t, {
          key: e, url: r(f, 'textureURL'), extension: r(f, 'textureExtension', 'png'), normalMap: r(f, 'normalMap'), xhrSettings: r(f, 'textureXhrSettings'),
        }), d = new l(t, {
          key: e, url: r(f, 'atlasURL'), extension: r(f, 'atlasExtension', 'txt'), xhrSettings: r(f, 'atlasXhrSettings'),
        });
      } else c = new o(t, e, i, s), d = new l(t, e, n, u); c.linkFile ? h.call(this, t, 'unityatlas', e, [c, d, c.linkFile]) : h.call(this, t, 'unityatlas', e, [c, d]);
    },
    addToCache() { if (this.failed === 0 && !this.complete) { const t = this.files[0]; const e = this.files[1]; const i = this.files[2] ? this.files[2].data : null; this.loader.textureManager.addUnityAtlas(t.key, t.data, e.data, i), e.addToCache(), this.complete = !0; } },
  }); s.register('unityAtlas', function (t, e, i, n, s) { let r; if (Array.isArray(t)) for (let o = 0; o < t.length; o++)r = new u(this, t[o]), this.addFile(r.files); else r = new u(this, t, e, i, n, s), this.addFile(r.files); return this; }), t.exports = u;
}, function (t, e, i) { const n = i(0); const s = i(7); const r = i(51); const o = i(29); const a = new n({ Extends: r, initialize(t, e, i, n) { r.call(this, t, e, i, n), this.type = 'tilemapJSON', this.cache = t.cacheManager.tilemap; }, addToCache() { const t = { format: o.TILED_JSON, data: this.data }; this.cache.add(this.key, t), this.pendingDestroy(t); } }); s.register('tilemapTiledJSON', function (t, e, i) { if (Array.isArray(t)) for (let n = 0; n < t.length; n++) this.addFile(new a(this, t[n])); else this.addFile(new a(this, t, e, i)); return this; }), t.exports = a; }, function (t, e, i) { const n = i(0); const s = i(7); const r = i(51); const o = i(29); const a = new n({ Extends: r, initialize(t, e, i, n) { r.call(this, t, e, i, n), this.type = 'tilemapJSON', this.cache = t.cacheManager.tilemap; }, addToCache() { const t = { format: o.WELTMEISTER, data: this.data }; this.cache.add(this.key, t), this.pendingDestroy(t); } }); s.register('tilemapImpact', function (t, e, i) { if (Array.isArray(t)) for (let n = 0; n < t.length; n++) this.addFile(new a(this, t[n])); else this.addFile(new a(this, t, e, i)); return this; }), t.exports = a; }, function (t, e, i) {
  const n = i(0); const s = i(18); const r = i(21); const o = i(7); const a = i(2); const h = i(8); const l = i(29); const u = new n({
    Extends: r,
    initialize(t, e, i, n) {
      let s = 'csv'; if (h(e)) { const o = e; e = a(o, 'key'), i = a(o, 'url'), n = a(o, 'xhrSettings'), s = a(o, 'extension', s); } const u = {
        type: 'tilemapCSV', cache: t.cacheManager.tilemap, extension: s, responseType: 'text', key: e, url: i, xhrSettings: n,
      }; r.call(this, t, u), this.tilemapFormat = l.CSV;
    },
    onProcess() { this.state = s.FILE_PROCESSING, this.data = this.xhrLoader.responseText, this.onProcessComplete(); },
    addToCache() { const t = { format: this.tilemapFormat, data: this.data }; this.cache.add(this.key, t), this.pendingDestroy(t); },
  }); o.register('tilemapCSV', function (t, e, i) { if (Array.isArray(t)) for (let n = 0; n < t.length; n++) this.addFile(new u(this, t[n])); else this.addFile(new u(this, t, e, i)); return this; }), t.exports = u;
}, function (t, e, i) {
  const n = i(0); const s = i(18); const r = i(21); const o = i(7); const a = i(2); const h = i(8); const l = new n({
    Extends: r,
    initialize(t, e, i, n, s) {
      let o = 'svg'; if (h(e)) { const l = e; e = a(l, 'key'), i = a(l, 'url'), n = a(l, 'svgConfig', {}), s = a(l, 'xhrSettings'), o = a(l, 'extension', o); } const u = {
        type: 'svg', cache: t.textureManager, extension: o, responseType: 'text', key: e, url: i, xhrSettings: s, config: { width: a(n, 'width'), height: a(n, 'height'), scale: a(n, 'scale') },
      }; r.call(this, t, u);
    },
    onProcess() { this.state = s.FILE_PROCESSING; const t = this.xhrLoader.responseText; let e = [t]; let i = this.config.width; let n = this.config.height; const o = this.config.scale; t:if (i && n || o) { const a = (new DOMParser()).parseFromString(t, 'text/xml').getElementsByTagName('svg')[0]; const h = a.hasAttribute('viewBox'); let l = parseFloat(a.getAttribute('width')); let u = parseFloat(a.getAttribute('height')); if (!h && l && u)a.setAttribute('viewBox', `0  0 ${l} ${u}`); else if (h && !l && !u) { const c = a.getAttribute('viewBox').split(/\s+|,/); l = c[2], u = c[3]; } if (o) { if (!l || !u) break t; i = l * o, n = u * o; }a.setAttribute('width', `${i.toString()}px`), a.setAttribute('height', `${n.toString()}px`), e = [(new XMLSerializer()).serializeToString(a)]; } try { var d = new window.Blob(e, { type: 'image/svg+xml;charset=utf-8' }); } catch (t) { return void this.onProcessError(); } this.data = new Image(), this.data.crossOrigin = this.crossOrigin; const f = this; let p = !1; this.data.onload = function () { p || r.revokeObjectURL(f.data), f.onProcessComplete(); }, this.data.onerror = function () { p ? f.onProcessError() : (p = !0, r.revokeObjectURL(f.data), f.data.src = `data:image/svg+xml,${encodeURIComponent(e.join(''))}`); }, r.createObjectURL(this.data, d, 'image/svg+xml'); },
    addToCache() { const t = this.cache.addImage(this.key, this.data); this.pendingDestroy(t); },
  }); o.register('svg', function (t, e, i, n) { if (Array.isArray(t)) for (let s = 0; s < t.length; s++) this.addFile(new l(this, t[s])); else this.addFile(new l(this, t, e, i, n)); return this; }), t.exports = l;
}, function (t, e, i) { const n = i(0); const s = i(7); const r = i(58); const o = new n({ Extends: r, initialize(t, e, i, n, s) { r.call(this, t, e, i, s, n), this.type = 'spritesheet'; }, addToCache() { const t = this.cache.addSpriteSheet(this.key, this.data, this.config); this.pendingDestroy(t); } }); s.register('spritesheet', function (t, e, i, n) { if (Array.isArray(t)) for (let s = 0; s < t.length; s++) this.addFile(new o(this, t[s])); else this.addFile(new o(this, t, e, i, n)); return this; }), t.exports = o; }, function (t, e, i) {
  const n = i(0); const s = i(18); const r = i(21); const o = i(7); const a = i(2); const h = i(8); const l = new n({
    Extends: r,
    initialize(t, e, i, n) {
      let s = 'js'; if (h(e)) { const o = e; e = a(o, 'key'), i = a(o, 'url'), n = a(o, 'xhrSettings'), s = a(o, 'extension', s); } const l = {
        type: 'script', cache: !1, extension: s, responseType: 'text', key: e, url: i, xhrSettings: n,
      }; r.call(this, t, l);
    },
    onProcess() { this.state = s.FILE_PROCESSING, this.data = document.createElement('script'), this.data.language = 'javascript', this.data.type = 'text/javascript', this.data.defer = !1, this.data.text = this.xhrLoader.responseText, document.head.appendChild(this.data), this.onProcessComplete(); },
  }); o.register('script', function (t, e, i) { if (Array.isArray(t)) for (let n = 0; n < t.length; n++) this.addFile(new l(this, t[n])); else this.addFile(new l(this, t, e, i)); return this; }), t.exports = l;
}, function (t, e, i) {
  const n = i(0); const s = i(18); const r = i(21); const o = i(7); const a = i(2); const h = i(8); const l = new n({
    Extends: r,
    initialize(t, e, i, n, o, l) {
      let u = 'js'; if (h(e)) { const c = e; e = a(c, 'key'), i = a(c, 'url'), l = a(c, 'xhrSettings'), u = a(c, 'extension', u), n = a(c, 'systemKey'), o = a(c, 'sceneKey'); } const d = {
        type: 'scenePlugin', cache: !1, extension: u, responseType: 'text', key: e, url: i, xhrSettings: l, config: { systemKey: n, sceneKey: o },
      }; r.call(this, t, d), typeof i === 'function' && (this.data = i, this.state = s.FILE_POPULATED);
    },
    onProcess() { const t = this.loader.systems.plugins; const e = this.config; const i = this.key; const n = a(e, 'systemKey', i); const r = a(e, 'sceneKey', i); this.state === s.FILE_POPULATED ? t.installScenePlugin(n, this.data, r, this.loader.scene) : (this.state = s.FILE_PROCESSING, this.data = document.createElement('script'), this.data.language = 'javascript', this.data.type = 'text/javascript', this.data.defer = !1, this.data.text = this.xhrLoader.responseText, document.head.appendChild(this.data), t.installScenePlugin(n, window[this.key], r, this.loader.scene)), this.onProcessComplete(); },
  }); o.register('scenePlugin', function (t, e, i, n, s) { if (Array.isArray(t)) for (let r = 0; r < t.length; r++) this.addFile(new l(this, t[r])); else this.addFile(new l(this, t, e, i, n, s)); return this; }), t.exports = l;
}, function (t, e, i) {
  const n = i(0); const s = i(18); const r = i(21); const o = i(7); const a = i(2); const h = i(8); const l = new n({
    Extends: r,
    initialize(t, e, i, n, o, l) {
      let u = 'js'; if (h(e)) { const c = e; e = a(c, 'key'), i = a(c, 'url'), l = a(c, 'xhrSettings'), u = a(c, 'extension', u), n = a(c, 'start'), o = a(c, 'mapping'); } const d = {
        type: 'plugin', cache: !1, extension: u, responseType: 'text', key: e, url: i, xhrSettings: l, config: { start: n, mapping: o },
      }; r.call(this, t, d), typeof i === 'function' && (this.data = i, this.state = s.FILE_POPULATED);
    },
    onProcess() { const t = this.loader.systems.plugins; const e = this.config; const i = a(e, 'start', !1); const n = a(e, 'mapping', null); this.state === s.FILE_POPULATED ? t.install(this.key, this.data, i, n) : (this.state = s.FILE_PROCESSING, this.data = document.createElement('script'), this.data.language = 'javascript', this.data.type = 'text/javascript', this.data.defer = !1, this.data.text = this.xhrLoader.responseText, document.head.appendChild(this.data), t.install(this.key, window[this.key], i, n)), this.onProcessComplete(); },
  }); o.register('plugin', function (t, e, i, n, s) { if (Array.isArray(t)) for (let r = 0; r < t.length; r++) this.addFile(new l(this, t[r])); else this.addFile(new l(this, t, e, i, n, s)); return this; }), t.exports = l;
}, function (t, e, i) { const n = i(0); const s = i(18); const r = i(7); const o = i(51); const a = new n({ Extends: o, initialize(t, e, i, n, s) { o.call(this, t, e, i, n, s), this.type = 'packfile'; }, onProcess() { this.state !== s.FILE_POPULATED && (this.state = s.FILE_PROCESSING, this.data = JSON.parse(this.xhrLoader.responseText)), this.loader.addPack(this.data, this.config), this.onProcessComplete(); } }); r.register('pack', function (t, e, i, n) { if (Array.isArray(t)) for (let s = 0; s < t.length; s++) this.addFile(new a(this, t[s])); else this.addFile(new a(this, t, e, n, i)); return this; }), t.exports = a; }, function (t, e, i) {
  const n = i(0); const s = i(7); const r = i(2); const o = i(58); const a = i(8); const h = i(51); const l = i(57); const u = new n({
    Extends: l, initialize(t, e, i, n, s, o, u) { if (a(e)) { const c = e; e = r(c, 'key'), i = r(c, 'url'), o = r(c, 'xhrSettings'), n = r(c, 'path'), s = r(c, 'baseURL'), u = r(c, 'textureXhrSettings'); } const d = new h(t, e, i, o); l.call(this, t, 'multiatlas', e, [d]), this.config.path = n, this.config.baseURL = s, this.config.textureXhrSettings = u; }, onFileComplete(t) { if (this.files.indexOf(t) !== -1 && (this.pending--, t.type === 'json' && t.data.hasOwnProperty('textures'))) { const e = t.data.textures; const i = this.config; const n = this.loader; const s = n.baseURL; const a = n.path; const h = n.prefix; const l = r(i, 'baseURL', s); const u = r(i, 'path', a); const c = r(i, 'prefix', h); const d = r(i, 'textureXhrSettings'); n.setBaseURL(l), n.setPath(u), n.setPrefix(c); for (let f = 0; f < e.length; f++) { const p = e[f].image; const g = `_MA_${p}`; const v = new o(n, g, p, d); if (this.addToMultiFile(v), n.addFile(v), e[f].normalMap) { const y = new o(n, g, e[f].normalMap, d); y.type = 'normalMap', v.setLink(y), this.addToMultiFile(y), n.addFile(y); } }n.setBaseURL(s), n.setPath(a), n.setPrefix(h); } }, addToCache() { if (this.isReadyToProcess()) { const t = this.files[0]; t.addToCache(); for (var e = [], i = [], n = [], s = 1; s < this.files.length; s++) { const r = this.files[s]; if (r.type !== 'normalMap') for (let o = r.key.substr(4), a = r.data, h = 0; h < t.data.textures.length; h++) { const l = t.data.textures[h]; if (l.image === o) { i.push(a), e.push(l), r.linkFile && n.push(r.linkFile.data); break; } } } for (n.length === 0 && (n = void 0), this.loader.textureManager.addAtlasJSONArray(this.key, i, e, n), this.complete = !0, s = 0; s < this.files.length; s++) this.files[s].pendingDestroy(); } },
  }); s.register('multiatlas', function (t, e, i, n, s) { let r; if (Array.isArray(t)) for (let o = 0; o < t.length; o++)r = new u(this, t[o]), this.addFile(r.files); else r = new u(this, t, e, i, n, s), this.addFile(r.files); return this; }), t.exports = u;
}, function (t, e, i) {
  const n = i(0); const s = i(18); const r = i(21); const o = i(7); const a = i(2); const h = i(8); const l = new n({
    Extends: r,
    initialize(t, e, i, n, s, o) {
      void 0 === n && (n = 512), void 0 === s && (s = 512); let l = 'html'; if (h(e)) { const u = e; e = a(u, 'key'), i = a(u, 'url'), o = a(u, 'xhrSettings'), l = a(u, 'extension', l), n = a(u, 'width', n), s = a(u, 'height', s); } const c = {
        type: 'html', cache: t.textureManager, extension: l, responseType: 'text', key: e, url: i, xhrSettings: o, config: { width: n, height: s },
      }; r.call(this, t, c);
    },
    onProcess() { this.state = s.FILE_PROCESSING; const t = this.config.width; const e = this.config.height; const i = []; i.push(`<svg width="${t}px" height="${e}px" viewBox="0 0 ${t} ${e}" xmlns="http://www.w3.org/2000/svg">`), i.push('<foreignObject width="100%" height="100%">'), i.push('<body xmlns="http://www.w3.org/1999/xhtml">'), i.push(this.xhrLoader.responseText), i.push('</body>'), i.push('</foreignObject>'), i.push('</svg>'); const n = [i.join('\n')]; const o = this; try { var a = new window.Blob(n, { type: 'image/svg+xml;charset=utf-8' }); } catch (t) { return o.state = s.FILE_ERRORED, void o.onProcessComplete(); } this.data = new Image(), this.data.crossOrigin = this.crossOrigin, this.data.onload = function () { r.revokeObjectURL(o.data), o.onProcessComplete(); }, this.data.onerror = function () { r.revokeObjectURL(o.data), o.onProcessError(); }, r.createObjectURL(this.data, a, 'image/svg+xml'); },
    addToCache() { const t = this.cache.addImage(this.key, this.data); this.pendingDestroy(t); },
  }); o.register('htmlTexture', function (t, e, i, n, s) { if (Array.isArray(t)) for (let r = 0; r < t.length; r++) this.addFile(new l(this, t[r])); else this.addFile(new l(this, t, e, i, n, s)); return this; }), t.exports = l;
}, function (t, e, i) {
  const n = i(0); const s = i(18); const r = i(21); const o = i(7); const a = i(2); const h = i(8); const l = new n({
    Extends: r,
    initialize(t, e, i, n) {
      let s = 'html'; if (h(e)) { const o = e; e = a(o, 'key'), i = a(o, 'url'), n = a(o, 'xhrSettings'), s = a(o, 'extension', s); } const l = {
        type: 'text', cache: t.cacheManager.html, extension: s, responseType: 'text', key: e, url: i, xhrSettings: n,
      }; r.call(this, t, l);
    },
    onProcess() { this.state = s.FILE_PROCESSING, this.data = this.xhrLoader.responseText, this.onProcessComplete(); },
  }); o.register('html', function (t, e, i) { if (Array.isArray(t)) for (let n = 0; n < t.length; n++) this.addFile(new l(this, t[n])); else this.addFile(new l(this, t, e, i)); return this; }), t.exports = l;
}, function (t, e, i) {
  const n = i(0); const s = i(18); const r = i(21); const o = i(7); const a = i(2); const h = i(8); const l = new n({
    Extends: r,
    initialize(t, e, i, n) {
      let s = 'glsl'; if (h(e)) { const o = e; e = a(o, 'key'), i = a(o, 'url'), n = a(o, 'xhrSettings'), s = a(o, 'extension', s); } const l = {
        type: 'glsl', cache: t.cacheManager.shader, extension: s, responseType: 'text', key: e, url: i, xhrSettings: n,
      }; r.call(this, t, l);
    },
    onProcess() { this.state = s.FILE_PROCESSING, this.data = this.xhrLoader.responseText, this.onProcessComplete(); },
  }); o.register('glsl', function (t, e, i) { if (Array.isArray(t)) for (let n = 0; n < t.length; n++) this.addFile(new l(this, t[n])); else this.addFile(new l(this, t, e, i)); return this; }), t.exports = l;
}, function (t, e, i) {
  const n = i(0); const s = i(7); const r = i(2); const o = i(58); const a = i(8); const h = i(57); const l = i(310); const u = i(139); const c = new n({
    Extends: h,
    initialize(t, e, i, n, s, l) {
      let c; let d; if (a(e)) {
        const f = e; e = r(f, 'key'), c = new o(t, {
          key: e, url: r(f, 'textureURL'), extension: r(f, 'textureExtension', 'png'), normalMap: r(f, 'normalMap'), xhrSettings: r(f, 'textureXhrSettings'),
        }), d = new u(t, {
          key: e, url: r(f, 'fontDataURL'), extension: r(f, 'fontDataExtension', 'xml'), xhrSettings: r(f, 'fontDataXhrSettings'),
        });
      } else c = new o(t, e, i, s), d = new u(t, e, n, l); c.linkFile ? h.call(this, t, 'bitmapfont', e, [c, d, c.linkFile]) : h.call(this, t, 'bitmapfont', e, [c, d]);
    },
    addToCache() { if (this.isReadyToProcess()) { const t = this.files[0]; const e = this.files[1]; t.addToCache(), e.addToCache(), this.loader.cacheManager.bitmapFont.add(t.key, { data: l(e.data), texture: t.key, frame: null }), this.complete = !0; } },
  }); s.register('bitmapFont', function (t, e, i, n, s) { let r; if (Array.isArray(t)) for (let o = 0; o < t.length; o++)r = new c(this, t[o]), this.addFile(r.files); else r = new c(this, t, e, i, n, s), this.addFile(r.files); return this; }), t.exports = c;
}, function (t, e, i) {
  const n = i(0); const s = i(18); const r = i(21); const o = i(7); const a = i(2); const h = i(8); const l = new n({
    Extends: r,
    initialize(t, e, i, n, s) {
      let o = 'bin'; if (h(e)) { const l = e; e = a(l, 'key'), i = a(l, 'url'), n = a(l, 'xhrSettings'), o = a(l, 'extension', o), s = a(l, 'dataType', s); } const u = {
        type: 'binary', cache: t.cacheManager.binary, extension: o, responseType: 'arraybuffer', key: e, url: i, xhrSettings: n, config: { dataType: s },
      }; r.call(this, t, u);
    },
    onProcess() { this.state = s.FILE_PROCESSING; const t = this.config.dataType; this.data = t ? new t(this.xhrLoader.response) : this.xhrLoader.response, this.onProcessComplete(); },
  }); o.register('binary', function (t, e, i, n) { if (Array.isArray(t)) for (let s = 0; s < t.length; s++) this.addFile(new l(this, t[s])); else this.addFile(new l(this, t, e, n, i)); return this; }), t.exports = l;
}, function (t, e, i) {
  const n = i(253); const s = i(0); const r = i(7); const o = i(2); const a = i(8); const h = i(51); const l = i(57); const u = new s({
    Extends: l, initialize(t, e, i, s, r, u, c) { if (a(e)) { const d = e; e = o(d, 'key'), i = o(d, 'jsonURL'), s = o(d, 'audioURL'), r = o(d, 'audioConfig'), u = o(d, 'audioXhrSettings'), c = o(d, 'jsonXhrSettings'); } let f; if (s) { const p = n.create(t, e, s, r, u); p && (f = new h(t, e, i, c), l.call(this, t, 'audiosprite', e, [p, f]), this.config.resourceLoad = !1); } else f = new h(t, e, i, c), l.call(this, t, 'audiosprite', e, [f]), this.config.resourceLoad = !0, this.config.audioConfig = r, this.config.audioXhrSettings = u; }, onFileComplete(t) { if (this.files.indexOf(t) !== -1 && (this.pending--, this.config.resourceLoad && t.type === 'json' && t.data.hasOwnProperty('resources'))) { const e = t.data.resources; const i = o(this.config, 'audioConfig'); const s = o(this.config, 'audioXhrSettings'); const r = n.create(this.loader, t.key, e, i, s); r && (this.addToMultiFile(r), this.loader.addFile(r)); } }, addToCache() { if (this.isReadyToProcess()) { const t = this.files[0]; const e = this.files[1]; t.addToCache(), e.addToCache(), this.complete = !0; } },
  }); r.register('audioSprite', function (t, e, i, n, s, r) { let o; const a = this.systems.game; const h = a.config.audio; const l = a.device.audio; if (h && h.noAudio || !l.webAudio && !l.audioData) return this; if (Array.isArray(t)) for (let c = 0; c < t.length; c++)(o = new u(this, t[c])).files && this.addFile(o.files); else (o = new u(this, t, e, i, n, s, r)).files && this.addFile(o.files); return this; });
}, function (t, e, i) {
  const n = i(0); const s = i(7); const r = i(2); const o = i(58); const a = i(8); const h = i(57); const l = i(139); const u = new n({
    Extends: h,
    initialize(t, e, i, n, s, u) {
      let c; let d; if (a(e)) {
        const f = e; e = r(f, 'key'), c = new o(t, {
          key: e, url: r(f, 'textureURL'), extension: r(f, 'textureExtension', 'png'), normalMap: r(f, 'normalMap'), xhrSettings: r(f, 'textureXhrSettings'),
        }), d = new l(t, {
          key: e, url: r(f, 'atlasURL'), extension: r(f, 'atlasExtension', 'xml'), xhrSettings: r(f, 'atlasXhrSettings'),
        });
      } else c = new o(t, e, i, s), d = new l(t, e, n, u); c.linkFile ? h.call(this, t, 'atlasxml', e, [c, d, c.linkFile]) : h.call(this, t, 'atlasxml', e, [c, d]);
    },
    addToCache() { if (this.isReadyToProcess()) { const t = this.files[0]; const e = this.files[1]; const i = this.files[2] ? this.files[2].data : null; this.loader.textureManager.addAtlasXML(t.key, t.data, e.data, i), e.addToCache(), this.complete = !0; } },
  }); s.register('atlasXML', function (t, e, i, n, s) { let r; if (Array.isArray(t)) for (let o = 0; o < t.length; o++)r = new u(this, t[o]), this.addFile(r.files); else r = new u(this, t, e, i, n, s), this.addFile(r.files); return this; }), t.exports = u;
}, function (t, e, i) {
  const n = i(0); const s = i(7); const r = i(2); const o = i(58); const a = i(8); const h = i(51); const l = i(57); const u = new n({
    Extends: l,
    initialize(t, e, i, n, s, u) {
      let c; let d; if (a(e)) {
        const f = e; e = r(f, 'key'), c = new o(t, {
          key: e, url: r(f, 'textureURL'), extension: r(f, 'textureExtension', 'png'), normalMap: r(f, 'normalMap'), xhrSettings: r(f, 'textureXhrSettings'),
        }), d = new h(t, {
          key: e, url: r(f, 'atlasURL'), extension: r(f, 'atlasExtension', 'json'), xhrSettings: r(f, 'atlasXhrSettings'),
        });
      } else c = new o(t, e, i, s), d = new h(t, e, n, u); c.linkFile ? l.call(this, t, 'atlasjson', e, [c, d, c.linkFile]) : l.call(this, t, 'atlasjson', e, [c, d]);
    },
    addToCache() { if (this.isReadyToProcess()) { const t = this.files[0]; const e = this.files[1]; const i = this.files[2] ? this.files[2].data : null; this.loader.textureManager.addAtlas(t.key, t.data, e.data, i), e.addToCache(), this.complete = !0; } },
  }); s.register('atlas', function (t, e, i, n, s) { let r; if (Array.isArray(t)) for (let o = 0; o < t.length; o++)r = new u(this, t[o]), this.addFile(r.files); else r = new u(this, t, e, i, n, s), this.addFile(r.files); return this; }), t.exports = u;
}, function (t, e, i) {
  const n = i(0); const s = i(7); const r = i(51); const o = new n({
    Extends: r, initialize(t, e, i, n, s) { r.call(this, t, e, i, n, s), this.type = 'animationJSON'; }, onProcess() { this.loader.once('loadcomplete', this.onLoadComplete, this), r.prototype.onProcess.call(this); }, onLoadComplete() { this.loader.systems.anims.fromJSON(this.data), this.pendingDestroy(); },
  }); s.register('animation', function (t, e, i, n) { if (Array.isArray(t)) for (let s = 0; s < t.length; s++) this.addFile(new o(this, t[s])); else this.addFile(new o(this, t, e, n, i)); return this; }), t.exports = o;
}, function (t, e, i) {
  t.exports = {
    AnimationJSONFile: i(591), AtlasJSONFile: i(590), AtlasXMLFile: i(589), AudioFile: i(253), AudioSpriteFile: i(588), BinaryFile: i(587), BitmapFontFile: i(586), GLSLFile: i(585), HTML5AudioFile: i(252), HTMLFile: i(584), HTMLTextureFile: i(583), ImageFile: i(58), JSONFile: i(51), MultiAtlasFile: i(582), PackFile: i(581), PluginFile: i(580), ScenePluginFile: i(579), ScriptFile: i(578), SpriteSheetFile: i(577), SVGFile: i(576), TextFile: i(251), TilemapCSVFile: i(575), TilemapImpactFile: i(574), TilemapJSONFile: i(573), UnityAtlasFile: i(572), XMLFile: i(139),
  };
}, function (t, e, i) {
  const n = i(18); const s = i(20); let r = {
    FileTypes: i(592), File: i(21), FileTypesManager: i(7), GetURL: i(141), LoaderPlugin: i(571), MergeXHRSettings: i(140), MultiFile: i(57), XHRLoader: i(254), XHRSettings: i(105),
  }; r = s(!1, r, n), t.exports = r;
}, function (t, e, i) { t.exports = { TouchManager: i(333) }; }, function (t, e, i) { t.exports = { MouseManager: i(336) }; }, function (t, e) { t.exports = function (t, e) { return void 0 === e && (e = 50), t.isUp && t.duration < e; }; }, function (t, e) { t.exports = function (t, e) { return void 0 === e && (e = 50), t.isDown && t.duration < e; }; }, function (t, e) { t.exports = function (t) { return !!t._justUp && (t._justUp = !1, !0); }; }, function (t, e) { t.exports = function (t) { return !!t._justDown && (t._justDown = !1, !0); }; }, function (t, e) { t.exports = function (t, e) { if (t.originalEvent = e, t.preventDefault && e.preventDefault(), t.enabled) return t.isDown = !1, t.isUp = !0, t.timeUp = e.timeStamp, t.duration = t.timeUp - t.timeDown, t.repeats = 0, t._justDown = !1, t._justUp = !0, t._tick = -1, t; }; }, function (t, e) { t.exports = function (t, e) { if (t.originalEvent = e, t.preventDefault && e.preventDefault(), t.enabled) return t.altKey = e.altKey, t.ctrlKey = e.ctrlKey, t.shiftKey = e.shiftKey, t.location = e.location, !1 === t.isDown && (t.isDown = !0, t.isUp = !1, t.timeDown = e.timeStamp, t.duration = 0, t._justDown = !0, t._justUp = !1), t.repeats++, t; }; }, function (t, e, i) { const n = i(143); const s = {}; for (const r in n)s[n[r]] = r; t.exports = s; }, function (t, e) { t.exports = function (t) { return t.current = t.keyCodes[0], t.index = 0, t.timeLastMatched = 0, t.matched = !1, t.timeMatched = 0, t; }; }, function (t, e) { t.exports = function (t, e) { return e.timeLastMatched = t.timeStamp, e.index++, e.index === e.size || (e.current = e.keyCodes[e.index], !1); }; }, function (t, e, i) { const n = i(604); t.exports = function (t, e) { if (e.matched) return !0; let i = !1; let s = !1; if (t.keyCode === e.current) if (e.index > 0 && e.maxKeyDelay > 0) { const r = e.timeLastMatched + e.maxKeyDelay; t.timeStamp <= r && (s = !0, i = n(t, e)); } else s = !0, i = n(t, e); return !s && e.resetOnWrongKey && (e.index = 0, e.current = e.keyCodes[0]), i && (e.timeLastMatched = t.timeStamp, e.matched = !0, e.timeMatched = t.timeStamp), i; }; }, function (t, e, i) {
  const n = i(0); const s = i(11); const r = i(4); const o = i(106); const a = i(256); const h = i(143); const l = i(255); const u = i(602); const c = i(601); const d = i(600); const f = i(142); const p = new n({
    Extends: s,
    initialize(t) { s.call(this), this.scene = t.scene, this.settings = this.scene.sys.settings, this.sceneInputPlugin = t, this.enabled = !0, this.target, this.keys = [], this.combos = [], this.queue = [], this.onKeyHandler, this.time = 0, t.pluginEvents.once('boot', this.boot, this), t.pluginEvents.on('start', this.start, this); },
    boot() { const t = this.settings.input; const e = this.scene.sys.game.config; this.enabled = r(t, 'keyboard', e.inputKeyboard), this.target = r(t, 'keyboard.target', e.inputKeyboardEventTarget), this.sceneInputPlugin.pluginEvents.once('destroy', this.destroy, this); },
    start() { this.enabled && this.startListeners(), this.sceneInputPlugin.pluginEvents.once('shutdown', this.shutdown, this); },
    isActive() { return this.enabled && this.scene.sys.isActive(); },
    startListeners() { const t = this; const e = function (e) { if (!e.defaultPrevented && t.isActive()) { t.queue.push(e); const i = t.keys[e.keyCode]; i && i.preventDefault && e.preventDefault(); } }; this.onKeyHandler = e, this.target.addEventListener('keydown', e, !1), this.target.addEventListener('keyup', e, !1), this.sceneInputPlugin.pluginEvents.on('update', this.update, this); },
    stopListeners() { this.target.removeEventListener('keydown', this.onKeyHandler), this.target.removeEventListener('keyup', this.onKeyHandler), this.sceneInputPlugin.pluginEvents.off('update', this.update); },
    createCursorKeys() {
      return this.addKeys({
        up: h.UP, down: h.DOWN, left: h.LEFT, right: h.RIGHT, space: h.SPACE, shift: h.SHIFT,
      });
    },
    addKeys(t) { const e = {}; if (typeof t === 'string') { t = t.split(','); for (let i = 0; i < t.length; i++) { const n = t[i].trim(); n && (e[n] = this.addKey(n)); } } else for (const s in t)e[s] = this.addKey(t[s]); return e; },
    addKey(t) { const e = this.keys; if (t instanceof a) { const i = e.indexOf(t); return i > -1 ? e[i] = t : e[t.keyCode] = t, t; } return typeof t === 'string' && (t = h[t.toUpperCase()]), e[t] || (e[t] = new a(t)), e[t]; },
    removeKey(t) { const e = this.keys; if (t instanceof a) { const i = e.indexOf(t); i > -1 && (this.keys[i] = void 0); } else typeof t === 'string' && (t = h[t.toUpperCase()]); e[t] && (e[t] = void 0); },
    createCombo(t, e) { return new l(this, t, e); },
    checkDown(t, e) { if (this.enabled && t.isDown) { const i = f(this.time - t.timeDown, e); if (i > t._tick) return t._tick = i, !0; } return !1; },
    update(t) { this.time = t; const e = this.queue.length; if (this.enabled && e !== 0) for (let i = this.queue.splice(0, e), n = this.keys, s = 0; s < e; s++) { const r = i[s]; const o = r.keyCode; r.type === 'keydown' ? (!u[o] || void 0 !== n[o] && !1 !== n[o].isDown || (this.emit(r.type, r), this.emit(`keydown_${u[o]}`, r)), n[o] && c(n[o], r)) : (this.emit(r.type, r), this.emit(`keyup_${u[o]}`, r), n[o] && d(n[o], r)); } },
    resetKeys() { for (let t = this.keys, e = 0; e < t.length; e++)t[e] && t[e].reset(); return this; },
    shutdown() { this.resetKeys(), this.stopListeners(), this.removeAllListeners(), this.queue = []; },
    destroy() { this.shutdown(), this.keys = [], this.combos = [], this.queue = [], this.scene = null, this.settings = null, this.sceneInputPlugin = null, this.target = null; },
  }); o.register('KeyboardPlugin', p, 'keyboard', 'keyboard', 'inputKeyboard'), t.exports = p;
}, function (t, e, i) {
  t.exports = {
    KeyboardPlugin: i(606), Key: i(256), KeyCodes: i(143), KeyCombo: i(255), JustDown: i(599), JustUp: i(598), DownDuration: i(597), UpDuration: i(596),
  };
}, function (t, e) { t.exports = function (t, e) { return function (i, n, s, r) { const o = t.getPixelAlpha(n, s, r.texture.key, r.frame.name); return o && o >= e; }; }; }, function (t, e, i) {
  const n = i(71); const s = i(40); const r = i(0); const o = i(260); const a = i(608); const h = i(52); const l = i(90); const u = i(89); const c = i(11); const d = i(2); const f = i(106); const p = i(8); const g = i(15); const v = i(9); const y = i(39); const m = i(59); const x = i(69); const w = new r({
    Extends: c,
    initialize(t) {
      c.call(this), this.scene = t, this.systems = t.sys, this.settings = t.sys.settings, this.manager = t.sys.game.input, this.pluginEvents = new c(), this.enabled = !0, this.displayList, this.cameras, f.install(this), this.mouse = this.manager.mouse, this.topOnly = !0, this.pollRate = -1, this._pollTimer = 0; const e = { cancelled: !1 }; this._eventContainer = { stopPropagation() { e.cancelled = !0; } }, this._eventData = e, this.dragDistanceThreshold = 0, this.dragTimeThreshold = 0, this._temp = [], this._tempZones = [], this._list = [], this._pendingInsertion = [], this._pendingRemoval = [], this._draggable = [], this._drag = {
        0: [], 1: [], 2: [], 3: [], 4: [], 5: [], 6: [], 7: [], 8: [], 9: [], 10: [],
      }, this._over = {
        0: [], 1: [], 2: [], 3: [], 4: [], 5: [], 6: [], 7: [], 8: [], 9: [], 10: [],
      }, this._validTypes = ['onDown', 'onUp', 'onOver', 'onOut', 'onMove', 'onDragStart', 'onDrag', 'onDragEnd', 'onDragEnter', 'onDragLeave', 'onDragOver', 'onDrop'], t.sys.events.once('boot', this.boot, this), t.sys.events.on('start', this.start, this);
    },
    boot() { this.cameras = this.systems.cameras, this.displayList = this.systems.displayList, this.systems.events.once('destroy', this.destroy, this), this.pluginEvents.emit('boot'); },
    start() { const t = this.systems.events; t.on('transitionstart', this.transitionIn, this), t.on('transitionout', this.transitionOut, this), t.on('transitioncomplete', this.transitionComplete, this), t.on('preupdate', this.preUpdate, this), t.on('update', this.update, this), t.once('shutdown', this.shutdown, this), this.enabled = !0, this.pluginEvents.emit('start'); },
    preUpdate() { this.pluginEvents.emit('preUpdate'); const t = this._pendingRemoval; const e = this._pendingInsertion; const i = t.length; const n = e.length; if (i !== 0 || n !== 0) { for (var s = this._list, r = 0; r < i; r++) { const o = t[r]; const a = s.indexOf(o); a > -1 && (s.splice(a, 1), this.clear(o)); }t.length = 0, this._pendingRemoval.length = 0, this._list = s.concat(e.splice(0)); } },
    isActive() { return this.enabled && this.scene.sys.isActive(); },
    update(t, e) { if (this.isActive()) { this.pluginEvents.emit('update', t, e); const i = this.manager; if (!i.globalTopOnly || !i.ignoreEvents) { let n = i.dirty || this.pollRate === 0; if (this.pollRate > -1 && (this._pollTimer -= e, this._pollTimer < 0 && (n = !0, this._pollTimer = this.pollRate)), n) for (let s = this.manager.pointers, r = 0; r < this.manager.pointersTotal; r++) { const o = s[r]; this._tempZones = [], this._temp = this.hitTestPointer(o), this.sortGameObjects(this._temp), this.sortGameObjects(this._tempZones), this.topOnly && (this._temp.length && this._temp.splice(1), this._tempZones.length && this._tempZones.splice(1)); let a = this.processDragEvents(o, t); o.wasTouch || (a += this.processOverOutEvents(o)), o.justDown && (a += this.processDownEvents(o)), o.justUp && (a += this.processUpEvents(o)), o.justMoved && (a += this.processMoveEvents(o)), a > 0 && i.globalTopOnly && (i.ignoreEvents = !0); } } } },
    clear(t) { const e = t.input; if (e) { this.queueForRemoval(t), e.gameObject = void 0, e.target = void 0, e.hitArea = void 0, e.hitAreaCallback = void 0, e.callbackContext = void 0, this.manager.resetCursor(e), t.input = null; let i = this._draggable.indexOf(t); return i > -1 && this._draggable.splice(i, 1), (i = this._drag[0].indexOf(t)) > -1 && this._drag[0].splice(i, 1), (i = this._over[0].indexOf(t)) > -1 && this._over[0].splice(i, 1), t; } },
    disable(t) { t.input.enabled = !1; },
    enable(t, e, i, n) { return void 0 === n && (n = !1), t.input ? t.input.enabled = !0 : this.setHitArea(t, e, i), t.input && n && !t.input.dropZone && (t.input.dropZone = n), this; },
    hitTestPointer(t) { for (var e = this.cameras.getCamerasBelowPointer(t), i = 0; i < e.length; i++) { for (var n = e[i], s = this.manager.hitTest(t, this._list, n), r = 0; r < s.length; r++) { const o = s[r]; o.input.dropZone && this._tempZones.push(o); } if (s.length > 0) return t.camera = n, s; } return t.camera = e[0], []; },
    processDownEvents(t) { let e = 0; const i = this._temp; const n = this._eventData; const s = this._eventContainer; n.cancelled = !1; for (var r = !1, o = 0; o < i.length; o++) { const a = i[o]; if (a.input) { if (e++, a.emit('pointerdown', t, a.input.localX, a.input.localY, s), n.cancelled) { r = !0; break; } if (this.emit('gameobjectdown', t, a, s), n.cancelled) { r = !0; break; } } } return r || this.emit('pointerdown', t, i), e; },
    processDragEvents(t, e) { if (this._draggable.length === 0) return 0; let i; let n; let s; let r; const o = this._temp; if (t.dragState === 0 && t.primaryDown && t.justDown && o.length > 0 ? t.dragState = 1 : t.dragState > 0 && !t.primaryDown && t.justUp && (t.dragState = 5), t.dragState === 1) { const a = []; for (i = 0; i < o.length; i++)(n = o[i]).input.draggable && n.input.dragState === 0 && a.push(n); if (a.length === 0) return t.dragState = 0, 0; a.length > 1 && (this.sortGameObjects(a), this.topOnly && a.splice(1)), this._drag[t.id] = a, this.dragDistanceThreshold === 0 && this.dragTimeThreshold === 0 ? t.dragState = 3 : t.dragState = 2; } if (t.dragState === 2 && (this.dragDistanceThreshold > 0 && h(t.x, t.y, t.downX, t.downY) >= this.dragDistanceThreshold && (t.dragState = 3), this.dragTimeThreshold > 0 && e >= t.downTime + this.dragTimeThreshold && (t.dragState = 3)), t.dragState === 3) { for (s = this._drag[t.id], i = 0; i < s.length; i++)(r = (n = s[i]).input).dragState = 2, r.dragX = t.x - n.x, r.dragY = t.y - n.y, r.dragStartX = n.x, r.dragStartY = n.y, n.emit('dragstart', t, r.dragX, r.dragY), this.emit('dragstart', t, n); return t.dragState = 4, s.length; } if (t.dragState === 4 && t.justMoved && !t.justUp) { const l = this._tempZones; for (s = this._drag[t.id], i = 0; i < s.length; i++) { if ((r = (n = s[i]).input).target) { const u = l.indexOf(r.target); u === 0 ? (n.emit('dragover', t, r.target), this.emit('dragover', t, n, r.target)) : u > 0 ? (n.emit('dragleave', t, r.target), this.emit('dragleave', t, n, r.target), r.target = l[0], n.emit('dragenter', t, r.target), this.emit('dragenter', t, n, r.target)) : (n.emit('dragleave', t, r.target), this.emit('dragleave', t, n, r.target), l[0] ? (r.target = l[0], n.emit('dragenter', t, r.target), this.emit('dragenter', t, n, r.target)) : r.target = null); } else !r.target && l[0] && (r.target = l[0], n.emit('dragenter', t, r.target), this.emit('dragenter', t, n, r.target)); const c = t.x - n.input.dragX; const d = t.y - n.input.dragY; n.emit('drag', t, c, d), this.emit('drag', t, n, c, d); } return s.length; } if (t.dragState === 5) { for (s = this._drag[t.id], i = 0; i < s.length; i++) if ((r = (n = s[i]).input).dragState === 2) { r.dragState = 0, r.dragX = r.localX - n.displayOriginX, r.dragY = r.localY - n.displayOriginY; let f = !1; r.target && (n.emit('drop', t, r.target), this.emit('drop', t, n, r.target), r.target = null, f = !0), n.emit('dragend', t, r.dragX, r.dragY, f), this.emit('dragend', t, n, f); }t.dragState = 0, s.splice(0); } return 0; },
    processMoveEvents(t) { let e = 0; const i = this._temp; const n = this._eventData; const s = this._eventContainer; n.cancelled = !1; for (var r = !1, o = 0; o < i.length; o++) { const a = i[o]; if (a.input) { if (e++, a.emit('pointermove', t, a.input.localX, a.input.localY, s), n.cancelled) { r = !0; break; } if (this.emit('gameobjectmove', t, a, s), n.cancelled) { r = !0; break; } if (this.topOnly) break; } } return r || this.emit('pointermove', t, i), e; },
    processOverOutEvents(t) { let e; let i; const n = this._temp; const s = []; const r = []; const o = []; let a = this._over[t.id]; const h = this._drag[t.id]; const l = this.manager; for (e = 0; e < a.length; e++)i = a[e], n.indexOf(i) === -1 && h.indexOf(i) === -1 ? s.push(i) : o.push(i); for (e = 0; e < n.length; e++)i = n[e], a.indexOf(i) === -1 && r.push(i); let u = s.length; let c = 0; const d = this._eventData; const f = this._eventContainer; d.cancelled = !1; let p = !1; if (u > 0) { for (this.sortGameObjects(s), e = 0; e < u; e++) if ((i = s[e]).input) { if (i.emit('pointerout', t, f), l.resetCursor(i.input), c++, d.cancelled) { p = !0; break; } if (this.emit('gameobjectout', t, i, f), d.cancelled) { p = !0; break; } }p || this.emit('pointerout', t, s); } if (u = r.length, d.cancelled = !1, p = !1, u > 0) { for (this.sortGameObjects(r), e = 0; e < u; e++) if ((i = r[e]).input) { if (i.emit('pointerover', t, i.input.localX, i.input.localY, f), l.setCursor(i.input), c++, d.cancelled) { p = !0; break; } if (this.emit('gameobjectover', t, i, f), d.cancelled) { p = !0; break; } }p || this.emit('pointerover', t, r); } return a = o.concat(r), this._over[t.id] = this.sortGameObjects(a), c; },
    processUpEvents(t) { const e = this._temp; const i = this._eventData; const n = this._eventContainer; i.cancelled = !1; for (var s = !1, r = 0; r < e.length; r++) { const o = e[r]; if (o.input) { if (o.emit('pointerup', t, o.input.localX, o.input.localY, n), i.cancelled) { s = !0; break; } if (this.emit('gameobjectup', t, o, n), i.cancelled) { s = !0; break; } } } return s || this.emit('pointerup', t, e), e.length; },
    queueForInsertion(t) { return this._pendingInsertion.indexOf(t) === -1 && this._list.indexOf(t) === -1 && this._pendingInsertion.push(t), this; },
    queueForRemoval(t) { return this._pendingRemoval.push(t), this; },
    setDraggable(t, e) { void 0 === e && (e = !0), Array.isArray(t) || (t = [t]); for (let i = 0; i < t.length; i++) { const n = t[i]; n.input.draggable = e; const s = this._draggable.indexOf(n); e && s === -1 ? this._draggable.push(n) : !e && s > -1 && this._draggable.splice(s, 1); } return this; },
    makePixelPerfect(t) { void 0 === t && (t = 1); const e = this.systems.textures; return a(e, t); },
    setHitArea(t, e, i) { if (void 0 === e) return this.setHitAreaFromTexture(t); Array.isArray(t) || (t = [t]); let n = !1; let s = !1; let r = !1; let a = !1; if (p(e)) { const h = e; e = d(h, 'hitArea', null), i = d(h, 'hitAreaCallback', null), n = d(h, 'draggable', !1), s = d(h, 'dropZone', !1), r = d(h, 'cursor', !1), a = d(h, 'useHandCursor', !1); const l = d(h, 'pixelPerfect', !1); const u = d(h, 'alphaTolerance', 1); l && (e = {}, i = this.makePixelPerfect(u)), e && i || this.setHitAreaFromTexture(t); } else typeof e !== 'function' || i || (i = e, e = {}); for (let c = 0; c < t.length; c++) { const f = t[c]; const g = f.input ? f.input : o(f, e, i); g.dropZone = s, g.cursor = a ? 'pointer' : r, f.input = g, n && this.setDraggable(f), this.queueForInsertion(f); } return this; },
    setHitAreaCircle(t, e, i, r, o) { void 0 === o && (o = s); const a = new n(e, i, r); return this.setHitArea(t, a, o); },
    setHitAreaEllipse(t, e, i, n, s, r) { void 0 === r && (r = u); const o = new l(e, i, n, s); return this.setHitArea(t, o, r); },
    setHitAreaFromTexture(t, e) { void 0 === e && (e = y), Array.isArray(t) || (t = [t]); for (let i = 0; i < t.length; i++) { const n = t[i]; const s = n.frame; let r = 0; let a = 0; s ? (r = s.realWidth, a = s.realHeight) : n.width && (r = n.width, a = n.height), n.type !== 'Container' || r !== 0 && a !== 0 ? r !== 0 && a !== 0 && (n.input = o(n, new v(0, 0, r, a), e), this.queueForInsertion(n)) : console.warn('Container.setInteractive() must specify a Shape or call setSize() first'); } return this; },
    setHitAreaRectangle(t, e, i, n, s, r) { void 0 === r && (r = y); const o = new v(e, i, n, s); return this.setHitArea(t, o, r); },
    setHitAreaTriangle(t, e, i, n, s, r, o, a) { void 0 === a && (a = x); const h = new m(e, i, n, s, r, o); return this.setHitArea(t, h, a); },
    setPollAlways() { return this.pollRate = 0, this._pollTimer = 0, this; },
    setPollOnMove() { return this.pollRate = -1, this._pollTimer = 0, this; },
    setPollRate(t) { return this.pollRate = t, this._pollTimer = 0, this; },
    setGlobalTopOnly(t) { return this.manager.globalTopOnly = t, this; },
    setTopOnly(t) { return this.topOnly = t, this; },
    sortGameObjects(t) { return t.length < 2 ? t : (this.scene.sys.depthSort(), t.sort(this.sortHandlerGO.bind(this))); },
    sortHandlerGO(t, e) { if (!t.parentContainer && !e.parentContainer) return this.displayList.getIndex(e) - this.displayList.getIndex(t); if (t.parentContainer === e.parentContainer) return e.parentContainer.getIndex(e) - t.parentContainer.getIndex(t); if (t.parentContainer === e) return -1; if (e.parentContainer === t) return 1; for (let i = t.getIndexList(), n = e.getIndexList(), s = Math.min(i.length, n.length), r = 0; r < s; r++) { const o = i[r]; const a = n[r]; if (o !== a) return a - o; } return 0; },
    stopPropagation() { return this.manager.globalTopOnly && (this.manager.ignoreEvents = !0), this; },
    addUpCallback(t, e) { return this.manager.addUpCallback(t, e), this; },
    addDownCallback(t, e) { return this.manager.addDownCallback(t, e), this; },
    addMoveCallback(t, e) { return this.manager.addMoveCallback(t, e), this; },
    addPointer(t) { return this.manager.addPointer(t); },
    setDefaultCursor(t) { return this.manager.setDefaultCursor(t), this; },
    transitionIn() { this.enabled = this.settings.transitionAllowInput; },
    transitionComplete() { this.settings.transitionAllowInput || (this.enabled = !0); },
    transitionOut() { this.enabled = this.settings.transitionAllowInput; },
    shutdown() { this.pluginEvents.emit('shutdown'), this._temp.length = 0, this._list.length = 0, this._draggable.length = 0, this._pendingRemoval.length = 0, this._pendingInsertion.length = 0; for (let t = 0; t < 10; t++) this._drag[t] = [], this._over[t] = []; this.removeAllListeners(); const e = this.systems.events; e.off('transitionstart', this.transitionIn, this), e.off('transitionout', this.transitionOut, this), e.off('transitioncomplete', this.transitionComplete, this), e.off('preupdate', this.preUpdate, this), e.off('update', this.update, this), e.off('shutdown', this.shutdown, this); },
    destroy() { this.shutdown(), this.pluginEvents.emit('destroy'), this.pluginEvents.removeAllListeners(), this.scene.sys.events.off('start', this.start, this), this.scene = null, this.cameras = null, this.manager = null, this.events = null, this.mouse = null; },
    x: { get() { return this.manager.activePointer.x; } },
    y: { get() { return this.manager.activePointer.y; } },
    mousePointer: { get() { return this.manager.mousePointer; } },
    activePointer: { get() { return this.manager.activePointer; } },
    pointer1: { get() { return this.manager.pointers[1]; } },
    pointer2: { get() { return this.manager.pointers[2]; } },
    pointer3: { get() { return this.manager.pointers[3]; } },
    pointer4: { get() { return this.manager.pointers[4]; } },
    pointer5: { get() { return this.manager.pointers[5]; } },
    pointer6: { get() { return this.manager.pointers[6]; } },
    pointer7: { get() { return this.manager.pointers[7]; } },
    pointer8: { get() { return this.manager.pointers[8]; } },
    pointer9: { get() { return this.manager.pointers[9]; } },
    pointer10: { get() { return this.manager.pointers[10]; } },
  }); g.register('InputPlugin', w, 'input'), t.exports = w;
}, function (t, e) {
  t.exports = {
    UP: 12, DOWN: 13, LEFT: 14, RIGHT: 15, MENU: 16, A: 0, B: 1, X: 2, Y: 3, LB: 4, RB: 5, LT: 6, RT: 7, BACK: 8, START: 9, LS: 10, RS: 11, LEFT_STICK_H: 0, LEFT_STICK_V: 1, RIGHT_STICK_H: 2, RIGHT_STICK_V: 3,
  };
}, function (t, e) {
  t.exports = {
    UP: 12, DOWN: 13, LEFT: 14, RIGHT: 15, SELECT: 8, START: 9, B: 0, A: 1, Y: 2, X: 3, LEFT_SHOULDER: 4, RIGHT_SHOULDER: 5,
  };
}, function (t, e) {
  t.exports = {
    UP: 12, DOWN: 13, LEFT: 14, RIGHT: 15, SHARE: 8, OPTIONS: 9, PS: 16, TOUCHBAR: 17, X: 0, CIRCLE: 1, SQUARE: 2, TRIANGLE: 3, L1: 4, R1: 5, L2: 6, R2: 7, L3: 10, R3: 11, LEFT_STICK_H: 0, LEFT_STICK_V: 1, RIGHT_STICK_H: 2, RIGHT_STICK_V: 3,
  };
}, function (t, e, i) { t.exports = { DUALSHOCK_4: i(612), SNES_USB: i(611), XBOX_360: i(610) }; }, function (t, e, i) {
  const n = i(0); const s = i(11); const r = i(257); const o = i(4); const a = i(106); const h = new n({
    Extends: s, initialize(t) { s.call(this), this.scene = t.scene, this.settings = this.scene.sys.settings, this.sceneInputPlugin = t, this.enabled = !0, this.target, this.gamepads = [], this.queue = [], this.onGamepadHandler, this._pad1, this._pad2, this._pad3, this._pad4, t.pluginEvents.once('boot', this.boot, this), t.pluginEvents.on('start', this.start, this); }, boot() { const t = this.scene.sys.game; const e = this.settings.input; const i = t.config; this.enabled = o(e, 'gamepad', i.inputGamepad) && t.device.input.gamepads, this.target = o(e, 'gamepad.target', i.inputGamepadEventTarget), this.sceneInputPlugin.pluginEvents.once('destroy', this.destroy, this); }, start() { this.enabled && this.startListeners(), this.sceneInputPlugin.pluginEvents.once('shutdown', this.shutdown, this); }, isActive() { return this.enabled && this.scene.sys.isActive(); }, startListeners() { const t = this; const e = this.target; const i = function (e) { !e.defaultPrevented && t.isActive() && (t.refreshPads(), t.queue.push(e)); }; this.onGamepadHandler = i, e.addEventListener('gamepadconnected', i, !1), e.addEventListener('gamepaddisconnected', i, !1), this.sceneInputPlugin.pluginEvents.on('update', this.update, this); }, stopListeners() { this.target.removeEventListener('gamepadconnected', this.onGamepadHandler), this.target.removeEventListener('gamepaddisconnected', this.onGamepadHandler), this.sceneInputPlugin.pluginEvents.off('update', this.update); }, disconnectAll() { for (let t = 0; t < this.gamepads.length; t++) this.gamepads.connected = !1; }, refreshPads() { const t = navigator.getGamepads(); if (t) for (let e = this.gamepads, i = 0; i < t.length; i++) { const n = t[i]; if (n) { const s = n.id; const o = n.index; const a = e[o]; if (a)a.id !== s ? (a.destroy(), e[o] = new r(this, n)) : a.update(n); else { const h = new r(this, n); e[o] = h, this._pad1 ? this._pad2 ? this._pad3 ? this._pad4 || (this._pad4 = h) : this._pad3 = h : this._pad2 = h : this._pad1 = h; } } } else this.disconnectAll(); }, getAll() { for (var t = [], e = this.gamepads, i = 0; i < e.length; i++)e[i] && t.push(e[i]); return t; }, getPad(t) { for (let e = this.gamepads, i = 0; i < e.length; i++) if (e[i] && e[i].index === t) return e[i]; }, update() { if (this.enabled) { this.refreshPads(); const t = this.queue.length; if (t !== 0) for (let e = this.queue.splice(0, t), i = 0; i < t; i++) { const n = e[i]; const s = this.getPad(n.gamepad.index); n.type === 'gamepadconnected' ? this.emit('connected', s, n) : n.type === 'gamepaddisconnected' && this.emit('disconnected', s, n); } } }, shutdown() { this.stopListeners(), this.disconnectAll(), this.removeAllListeners(); }, destroy() { this.shutdown(); for (let t = 0; t < this.gamepads.length; t++) this.gamepads[t] && this.gamepads[t].destroy(); this.gamepads = [], this.scene = null, this.settings = null, this.sceneInputPlugin = null, this.target = null; }, total: { get() { return this.gamepads.length; } }, pad1: { get() { return this._pad1; } }, pad2: { get() { return this._pad2; } }, pad3: { get() { return this._pad3; } }, pad4: { get() { return this._pad4; } },
  }); a.register('GamepadPlugin', h, 'gamepad', 'gamepad', 'inputGamepad'), t.exports = h;
}, function (t, e, i) {
  t.exports = {
    Axis: i(259), Button: i(258), Gamepad: i(257), GamepadPlugin: i(614), Configs: i(613),
  };
}, function (t, e, i) {
  const n = i(337); const s = i(20); let r = {
    CreateInteractiveObject: i(260), Gamepad: i(615), InputManager: i(338), InputPlugin: i(609), InputPluginCache: i(106), Keyboard: i(607), Mouse: i(595), Pointer: i(335), Touch: i(594),
  }; r = s(!1, r, n), t.exports = r;
}, function (t, e, i) { const n = i(144); t.exports = function (t, e, i) { return n(t, e.x, e.y, i); }; }, function (t, e, i) { const n = i(144); const s = i(261); t.exports = function (t, e) { const i = s(t); return n(t, i.x, i.y, e); }; }, function (t, e, i) { const n = i(65); t.exports = function (t) { const e = t.getLineA(); const i = t.getLineB(); const s = t.getLineC(); return n(e) + n(i) + n(s); }; }, function (t, e) { t.exports = function (t, e) { return t.x1 === e.x1 && t.y1 === e.y1 && t.x2 === e.x2 && t.y2 === e.y2 && t.x3 === e.x3 && t.y3 === e.y3; }; }, function (t, e) { t.exports = function (t, e) { return e.setTo(t.x1, t.y1, t.x2, t.y2, t.x3, t.y3); }; }, function (t, e, i) { const n = i(69); t.exports = function (t, e) { return n(t, e.x, e.y); }; }, function (t, e, i) { const n = i(59); t.exports = function (t) { return new n(t.x1, t.y1, t.x2, t.y2, t.x3, t.y3); }; }, function (t, e, i) { const n = i(71); t.exports = function (t, e) { void 0 === e && (e = new n()); let i; let s; const r = t.x1; const o = t.y1; const a = t.x2; const h = t.y2; const l = t.x3; const u = t.y3; const c = a - r; const d = h - o; const f = l - r; const p = u - o; const g = c * (r + a) + d * (o + h); const v = f * (r + l) + p * (o + u); const y = 2 * (c * (u - h) - d * (l - a)); if (Math.abs(y) < 1e-6) { const m = Math.min(r, a, l); const x = Math.min(o, h, u); i = 0.5 * (Math.max(r, a, l) - m), s = 0.5 * (Math.max(o, h, u) - x), e.x = m + i, e.y = x + s, e.radius = Math.sqrt(i * i + s * s); } else e.x = (p * g - d * v) / y, e.y = (c * v - f * g) / y, i = e.x - r, s = e.y - o, e.radius = Math.sqrt(i * i + s * s); return e; }; }, function (t, e, i) { const n = i(3); function s(t, e, i, n) { return t * n - e * i; }t.exports = function (t, e) { void 0 === e && (e = new n()); const i = t.x3; const r = t.y3; const o = t.x1 - i; const a = t.y1 - r; const h = t.x2 - i; const l = t.y2 - r; const u = 2 * s(o, a, h, l); const c = s(a, o * o + a * a, l, h * h + l * l); const d = s(o, o * o + a * a, h, h * h + l * l); return e.x = i - c / u, e.y = r + d / u, e; }; }, function (t, e, i) { const n = i(263); const s = i(262); t.exports = function (t, e, i, r) { void 0 === r && (r = n); const o = r(t); const a = e - o.x; const h = i - o.y; return s(t, a, h); }; }, function (t, e, i) { const n = i(59); t.exports = function (t, e, i, s) { return void 0 === s && (s = i), new n(t, e, t, e - s, t + i, e); }; }, function (t, e, i) { const n = i(64); const s = i(59); t.exports = function (t, e, i, r, o) { void 0 === e && (e = null), void 0 === i && (i = 1), void 0 === r && (r = 1), void 0 === o && (o = []); for (var a, h, l, u, c, d, f, p, g, v = n(t, e), y = 0; y < v.length; y += 3)a = v[y], h = v[y + 1], l = v[y + 2], u = t[2 * a] * i, c = t[2 * a + 1] * r, d = t[2 * h] * i, f = t[2 * h + 1] * r, p = t[2 * l] * i, g = t[2 * l + 1] * r, o.push(new s(u, c, d, f, p, g)); return o; }; }, function (t, e, i) { const n = i(59); t.exports = function (t, e, i) { const s = i * (Math.sqrt(3) / 2); return new n(t, e, t + i / 2, e + s, t - i / 2, e + s); }; }, function (t, e) { t.exports = function (t) { const e = t.x1; const i = t.y1; const n = t.x2; const s = t.y2; const r = t.x3; const o = t.y3; return Math.abs(((r - e) * (s - i) - (n - e) * (o - i)) / 2); }; }, function (t, e, i) { const n = i(59); n.Area = i(630), n.BuildEquilateral = i(629), n.BuildFromPolygon = i(628), n.BuildRight = i(627), n.CenterOn = i(626), n.Centroid = i(263), n.CircumCenter = i(625), n.CircumCircle = i(624), n.Clone = i(623), n.Contains = i(69), n.ContainsArray = i(147), n.ContainsPoint = i(622), n.CopyFrom = i(621), n.Decompose = i(269), n.Equals = i(620), n.GetPoint = i(278), n.GetPoints = i(277), n.InCenter = i(261), n.Perimeter = i(619), n.Offset = i(262), n.Random = i(184), n.Rotate = i(618), n.RotateAroundPoint = i(617), n.RotateAroundXY = i(144), t.exports = n; }, function (t, e) { t.exports = function (t, e, i) { return void 0 === i && (i = e), t.width *= e, t.height *= i, t; }; }, function (t, e) { t.exports = function (t, e) { return t.width === e.width && t.height === e.height; }; }, function (t, e, i) { const n = i(170); const s = i(264); const r = i(6); t.exports = function (t, e, i) { if (void 0 === i && (i = new r()), s(t, e)) switch (n(0, 3)) { case 0: i.x = t.x + Math.random() * (e.right - t.x), i.y = t.y + Math.random() * (e.top - t.y); break; case 1: i.x = e.x + Math.random() * (t.right - e.x), i.y = e.bottom + Math.random() * (t.bottom - e.bottom); break; case 2: i.x = t.x + Math.random() * (e.x - t.x), i.y = e.y + Math.random() * (t.bottom - e.y); break; case 3: i.x = e.right + Math.random() * (t.right - e.right), i.y = t.y + Math.random() * (e.bottom - t.y); } return i; }; }, function (t, e, i) { const n = i(6); const s = i(31); t.exports = function (t, e, i) { void 0 === i && (i = new n()), e = s(e); const r = Math.sin(e); const o = Math.cos(e); let a = o > 0 ? t.width / 2 : t.width / -2; let h = r > 0 ? t.height / 2 : t.height / -2; return Math.abs(a * r) < Math.abs(h * o) ? h = a * r / o : a = h * o / r, i.x = a + t.centerX, i.y = h + t.centerY, i; }; }, function (t, e) { t.exports = function (t, e) { return t.x < e.right && t.right > e.x && t.y < e.bottom && t.bottom > e.y; }; }, function (t, e) { t.exports = function (t, e) { return t.x += e.x, t.y += e.y, t; }; }, function (t, e) { t.exports = function (t, e, i) { return t.x += e, t.y += i, t; }; }, function (t, e) { t.exports = function (t, e, i) { const n = Math.min(t.x, e); const s = Math.max(t.right, e); t.x = n, t.width = s - n; const r = Math.min(t.y, i); const o = Math.max(t.bottom, i); return t.y = r, t.height = o - r, t; }; }, function (t, e) { t.exports = function (t, e) { const i = Math.min(t.x, e.x); const n = Math.max(t.right, e.right); t.x = i, t.width = n - i; const s = Math.min(t.y, e.y); const r = Math.max(t.bottom, e.bottom); return t.y = s, t.height = r - s, t; }; }, function (t, e) { t.exports = function (t, e) { for (var i = t.x, n = t.right, s = t.y, r = t.bottom, o = 0; o < e.length; o++)i = Math.min(i, e[o].x), n = Math.max(n, e[o].x), s = Math.min(s, e[o].y), r = Math.max(r, e[o].y); return t.x = i, t.y = s, t.width = n - i, t.height = r - s, t; }; }, function (t, e, i) { const n = i(9); const s = i(148); t.exports = function (t, e, i) { return void 0 === i && (i = new n()), s(t, e) ? (i.x = Math.max(t.x, e.x), i.y = Math.max(t.y, e.y), i.width = Math.min(t.right, e.right) - i.x, i.height = Math.min(t.bottom, e.bottom) - i.y) : i.setEmpty(), i; }; }, function (t, e, i) { const n = i(175); t.exports = function (t, e, i) { const s = t.centerX; const r = t.centerY; return t.setSize(t.width + 2 * e, t.height + 2 * i), n(t, s, r); }; }, function (t, e, i) { const n = i(6); t.exports = function (t, e) { return void 0 === e && (e = new n()), e.x = t.width, e.y = t.height, e; }; }, function (t, e, i) { const n = i(6); t.exports = function (t, e) { return void 0 === e && (e = new n()), e.x = t.centerX, e.y = t.centerY, e; }; }, function (t, e) { t.exports = function (t) { return t.x = Math.floor(t.x), t.y = Math.floor(t.y), t.width = Math.floor(t.width), t.height = Math.floor(t.height), t; }; }, function (t, e) { t.exports = function (t) { return t.x = Math.floor(t.x), t.y = Math.floor(t.y), t; }; }, function (t, e, i) { const n = i(145); t.exports = function (t, e) { const i = n(t); return i > n(e) ? t.setSize(e.height * i, e.height) : t.setSize(e.width, e.width / i), t.setPosition(e.centerX - t.width / 2, e.centerY - t.height / 2); }; }, function (t, e, i) { const n = i(145); t.exports = function (t, e) { const i = n(t); return i < n(e) ? t.setSize(e.height * i, e.height) : t.setSize(e.width, e.width / i), t.setPosition(e.centerX - t.width / 2, e.centerY - t.height / 2); }; }, function (t, e) { t.exports = function (t, e) { return t.x === e.x && t.y === e.y && t.width === e.width && t.height === e.height; }; }, function (t, e) { t.exports = function (t, e) { return e.setTo(t.x, t.y, t.width, t.height); }; }, function (t, e, i) { const n = i(39); t.exports = function (t, e) { return n(t, e.x, e.y); }; }, function (t, e, i) { const n = i(9); t.exports = function (t) { return new n(t.x, t.y, t.width, t.height); }; }, function (t, e) { t.exports = function (t) { return t.x = Math.ceil(t.x), t.y = Math.ceil(t.y), t.width = Math.ceil(t.width), t.height = Math.ceil(t.height), t; }; }, function (t, e) { t.exports = function (t) { return t.x = Math.ceil(t.x), t.y = Math.ceil(t.y), t; }; }, function (t, e) { t.exports = function (t) { return t.width * t.height; }; }, function (t, e) { t.exports = function (t) { return t.points.reverse(), t; }; }, function (t, e) { t.exports = function (t, e) { void 0 === e && (e = []); for (let i = 0; i < t.points.length; i++)e.push(t.points[i].x), e.push(t.points[i].y); return e; }; }, function (t, e, i) { const n = i(150); t.exports = function (t, e) { return n(t, e.x, e.y); }; }, function (t, e, i) { const n = i(151); t.exports = function (t) { return new n(t.points); }; }, function (t, e, i) { const n = i(151); n.Clone = i(660), n.Contains = i(150), n.ContainsPoint = i(659), n.GetAABB = i(285), n.GetNumberArray = i(658), n.GetPoints = i(284), n.Perimeter = i(283), n.Reverse = i(657), n.Smooth = i(282), t.exports = n; }, function (t, e, i) { const n = i(267); t.exports = function (t, e) { if (t.x !== 0 || t.y !== 0) { const i = n(t); t.x /= i, t.y /= i; } return t.x *= e, t.y *= e, t; }; }, function (t, e, i) { const n = i(6); t.exports = function (t, e, i) { void 0 === i && (i = new n()); const s = t.x * e.x + t.y * e.y; return s !== 0 && (i.x = s * e.x, i.y = s * e.y), i; }; }, function (t, e, i) { const n = i(6); const s = i(266); t.exports = function (t, e, i) { void 0 === i && (i = new n()); const r = (t.x * e.x + t.y * e.y) / s(e); return r !== 0 && (i.x = r * e.x, i.y = r * e.y), i; }; }, function (t, e, i) { const n = i(6); t.exports = function (t, e) { return void 0 === e && (e = new n()), e.setTo(-t.x, -t.y); }; }, function (t, e) { t.exports = function (t) { return t.setTo(t.y, t.x); }; }, function (t, e, i) { const n = i(6); t.exports = function (t, e, i, s) { return void 0 === i && (i = 0), void 0 === s && (s = new n()), s.x = t.x + (e.x - t.x) * i, s.y = t.y + (e.y - t.y) * i, s; }; }, function (t, e, i) { const n = i(9); t.exports = function (t, e) { void 0 === e && (e = new n()); for (var i = Number.NEGATIVE_INFINITY, s = Number.POSITIVE_INFINITY, r = Number.NEGATIVE_INFINITY, o = Number.POSITIVE_INFINITY, a = 0; a < t.length; a++) { const h = t[a]; h.x > i && (i = h.x), h.x < s && (s = h.x), h.y > r && (r = h.y), h.y < o && (o = h.y); } return e.x = s, e.y = o, e.width = i - s, e.height = r - o, e; }; }, function (t, e, i) { const n = i(6); t.exports = function (t, e) { if (void 0 === e && (e = new n()), !Array.isArray(t)) throw new Error('GetCentroid points argument must be an array'); const i = t.length; if (i < 1) throw new Error('GetCentroid points array must not be empty'); if (i === 1)e.x = t[0].x, e.y = t[0].y; else { for (let s = 0; s < i; s++)e.x += t[s].x, e.y += t[s].y; e.x /= i, e.y /= i; } return e; }; }, function (t, e) { t.exports = function (t) { return t.setTo(Math.floor(t.x), Math.floor(t.y)); }; }, function (t, e) { t.exports = function (t, e) { return t.x === e.x && t.y === e.y; }; }, function (t, e) { t.exports = function (t, e) { return e.setTo(t.x, t.y); }; }, function (t, e, i) { const n = i(6); t.exports = function (t) { return new n(t.x, t.y); }; }, function (t, e) { t.exports = function (t) { return t.setTo(Math.ceil(t.x), Math.ceil(t.y)); }; }, function (t, e, i) { const n = i(6); n.Ceil = i(674), n.Clone = i(673), n.CopyFrom = i(672), n.Equals = i(671), n.Floor = i(670), n.GetCentroid = i(669), n.GetMagnitude = i(267), n.GetMagnitudeSq = i(266), n.GetRectangleFromPoints = i(668), n.Interpolate = i(667), n.Invert = i(666), n.Negative = i(665), n.Project = i(664), n.ProjectUnit = i(663), n.SetMagnitude = i(662), t.exports = n; }, function (t, e) { t.exports = function (t) { return Math.abs(t.x1 - t.x2); }; }, function (t, e) { t.exports = function (t) { return (t.y2 - t.y1) / (t.x2 - t.x1); }; }, function (t, e) { t.exports = function (t, e, i, n, s) { return t.x1 = e, t.y1 = i, t.x2 = e + Math.cos(n) * s, t.y2 = i + Math.sin(n) * s, t; }; }, function (t, e, i) { const n = i(146); t.exports = function (t, e, i) { return n(t, e.x, e.y, i); }; }, function (t, e, i) { const n = i(146); t.exports = function (t, e) { const i = (t.x1 + t.x2) / 2; const s = (t.y1 + t.y2) / 2; return n(t, i, s, e); }; }, function (t, e, i) { const n = i(68); const s = i(268); t.exports = function (t, e) { return 2 * s(e) - Math.PI - n(t); }; }, function (t, e) { t.exports = function (t) { return -(t.x2 - t.x1) / (t.y2 - t.y1); }; }, function (t, e) { t.exports = function (t, e, i) { return t.x1 += e, t.y1 += i, t.x2 += e, t.y2 += i, t; }; }, function (t, e, i) { const n = i(16); const s = i(68); t.exports = function (t) { return Math.sin(s(t) - n.TAU); }; }, function (t, e, i) { const n = i(16); const s = i(68); t.exports = function (t) { return Math.cos(s(t) - n.TAU); }; }, function (t, e) { t.exports = function (t) { return Math.abs(t.y1 - t.y2); }; }, function (t, e, i) { const n = i(16); const s = i(68); const r = i(6); t.exports = function (t, e) { void 0 === e && (e = new r()); const i = s(t) - n.TAU; return e.x = Math.cos(i), e.y = Math.sin(i), e; }; }, function (t, e, i) { const n = i(6); t.exports = function (t, e) { return void 0 === e && (e = new n()), e.x = (t.x1 + t.x2) / 2, e.y = (t.y1 + t.y2) / 2, e; }; }, function (t, e) { t.exports = function (t, e) { return t.x1 === e.x1 && t.y1 === e.y1 && t.x2 === e.x2 && t.y2 === e.y2; }; }, function (t, e) { t.exports = function (t, e) { return e.setTo(t.x1, t.y1, t.x2, t.y2); }; }, function (t, e, i) { const n = i(54); t.exports = function (t) { return new n(t.x1, t.y1, t.x2, t.y2); }; }, function (t, e) { t.exports = function (t, e, i) { const n = e - (t.x1 + t.x2) / 2; const s = i - (t.y1 + t.y2) / 2; return t.x1 += n, t.y1 += s, t.x2 += n, t.y2 += s, t; }; }, function (t, e, i) { const n = i(54); n.Angle = i(68), n.BresenhamPoints = i(385), n.CenterOn = i(692), n.Clone = i(691), n.CopyFrom = i(690), n.Equals = i(689), n.GetMidPoint = i(688), n.GetNormal = i(687), n.GetPoint = i(397), n.GetPoints = i(189), n.Height = i(686), n.Length = i(65), n.NormalAngle = i(268), n.NormalX = i(685), n.NormalY = i(684), n.Offset = i(683), n.PerpSlope = i(682), n.Random = i(188), n.ReflectAngle = i(681), n.Rotate = i(680), n.RotateAroundPoint = i(679), n.RotateAroundXY = i(146), n.SetToAngle = i(678), n.Slope = i(677), n.Width = i(676), t.exports = n; }, function (t, e, i) { const n = i(147); const s = i(269); const r = i(107); t.exports = function (t, e) { if (t.left > e.right || t.right < e.left || t.top > e.bottom || t.bottom < e.top) return !1; const i = t.getLineA(); const o = t.getLineB(); const a = t.getLineC(); const h = e.getLineA(); const l = e.getLineB(); const u = e.getLineC(); if (r(i, h) || r(i, l) || r(i, u)) return !0; if (r(o, h) || r(o, l) || r(o, u)) return !0; if (r(a, h) || r(a, l) || r(a, u)) return !0; let c = s(t); let d = n(e, c, !0); return d.length > 0 || (c = s(e), (d = n(t, c, !0)).length > 0); }; }, function (t, e, i) { const n = i(69); const s = i(107); t.exports = function (t, e) { return !!(n(t, e.getPointA()) || n(t, e.getPointB()) || s(t.getLineA(), e) || s(t.getLineB(), e) || s(t.getLineC(), e)); }; }, function (t, e, i) { const n = i(272); const s = i(69); t.exports = function (t, e) { return !(t.left > e.right || t.right < e.left || t.top > e.bottom || t.bottom < e.top || !s(t, e.x, e.y) && !n(t.getLineA(), e) && !n(t.getLineB(), e) && !n(t.getLineC(), e)); }; }, function (t, e) { t.exports = function (t, e, i, n, s, r) { return void 0 === r && (r = 0), !(e > t.right + r || i < t.left - r || n > t.bottom + r || s < t.top - r); }; }, function (t, e, i) { const n = i(107); const s = i(39); const r = i(147); const o = i(270); t.exports = function (t, e) { if (e.left > t.right || e.right < t.left || e.top > t.bottom || e.bottom < t.top) return !1; const i = e.getLineA(); const a = e.getLineB(); const h = e.getLineC(); if (s(t, i.x1, i.y1) || s(t, i.x2, i.y2)) return !0; if (s(t, a.x1, a.y1) || s(t, a.x2, a.y2)) return !0; if (s(t, h.x1, h.y1) || s(t, h.x2, h.y2)) return !0; const l = t.getLineA(); const u = t.getLineB(); const c = t.getLineC(); const d = t.getLineD(); if (n(i, l) || n(i, u) || n(i, c) || n(i, d)) return !0; if (n(a, l) || n(a, u) || n(a, c) || n(a, d)) return !0; if (n(h, l) || n(h, u) || n(h, c) || n(h, d)) return !0; const f = o(t); return r(e, f, !0).length > 0; }; }, function (t, e, i) { const n = i(271); t.exports = function (t, e) { if (!n(t, e)) return !1; const i = Math.min(e.x1, e.x2); const s = Math.max(e.x1, e.x2); const r = Math.min(e.y1, e.y2); const o = Math.max(e.y1, e.y2); return t.x >= i && t.x <= s && t.y >= r && t.y <= o; }; }, function (t, e) { t.exports = function (t, e) { const i = t.x1; const n = t.y1; const s = t.x2; const r = t.y2; const o = e.x; const a = e.y; const h = e.right; const l = e.bottom; let u = 0; if (i >= o && i <= h && n >= a && n <= l || s >= o && s <= h && r >= a && r <= l) return !0; if (i < o && s >= o) { if ((u = n + (r - n) * (o - i) / (s - i)) > a && u <= l) return !0; } else if (i > h && s <= h && (u = n + (r - n) * (h - i) / (s - i)) >= a && u <= l) return !0; if (n < a && r >= a) { if ((u = i + (s - i) * (a - n) / (r - n)) >= o && u <= h) return !0; } else if (n > l && r <= l && (u = i + (s - i) * (l - n) / (r - n)) >= o && u <= h) return !0; return !1; }; }, function (t, e, i) { const n = i(9); const s = i(148); t.exports = function (t, e, i) { return void 0 === i && (i = new n()), s(t, e) && (i.x = Math.max(t.x, e.x), i.y = Math.max(t.y, e.y), i.width = Math.min(t.right, e.right) - i.x, i.height = Math.min(t.bottom, e.bottom) - i.y), i; }; }, function (t, e) { t.exports = function (t, e) { const i = e.width / 2; const n = e.height / 2; const s = Math.abs(t.x - e.x - i); const r = Math.abs(t.y - e.y - n); const o = i + t.radius; const a = n + t.radius; if (s > o || r > a) return !1; if (s <= i || r <= n) return !0; const h = s - i; const l = r - n; return h * h + l * l <= t.radius * t.radius; }; }, function (t, e, i) { const n = i(52); t.exports = function (t, e) { return n(t.x, t.y, e.x, e.y) <= t.radius + e.radius; }; }, function (t, e) { t.exports = function (t, e) { return t.x += e.x, t.y += e.y, t; }; }, function (t, e) { t.exports = function (t, e, i) { return t.x += e, t.y += i, t; }; }, function (t, e, i) { const n = i(9); t.exports = function (t, e) { return void 0 === e && (e = new n()), e.x = t.left, e.y = t.top, e.width = t.width, e.height = t.height, e; }; }, function (t, e) { t.exports = function (t, e) { return t.x === e.x && t.y === e.y && t.width === e.width && t.height === e.height; }; }, function (t, e) { t.exports = function (t, e) { return e.setTo(t.x, t.y, t.width, t.height); }; }, function (t, e, i) { const n = i(89); t.exports = function (t, e) { return n(t, e.x, e.y) && n(t, e.right, e.y) && n(t, e.x, e.bottom) && n(t, e.right, e.bottom); }; }, function (t, e, i) { const n = i(89); t.exports = function (t, e) { return n(t, e.x, e.y); }; }, function (t, e, i) { const n = i(90); t.exports = function (t) { return new n(t.x, t.y, t.width, t.height); }; }, function (t, e) { t.exports = function (t) { return t.isEmpty() ? 0 : t.getMajorRadius() * t.getMinorRadius() * Math.PI; }; }, function (t, e, i) { const n = i(90); n.Area = i(712), n.Circumference = i(306), n.CircumferencePoint = i(156), n.Clone = i(711), n.Contains = i(89), n.ContainsPoint = i(710), n.ContainsRect = i(709), n.CopyFrom = i(708), n.Equals = i(707), n.GetBounds = i(706), n.GetPoint = i(308), n.GetPoints = i(307), n.Offset = i(705), n.OffsetPoint = i(704), n.Random = i(185), t.exports = n; }, function (t, e) { t.exports = function (t, e) { return t.x += e.x, t.y += e.y, t; }; }, function (t, e) { t.exports = function (t, e, i) { return t.x += e, t.y += i, t; }; }, function (t, e, i) { const n = i(9); t.exports = function (t, e) { return void 0 === e && (e = new n()), e.x = t.left, e.y = t.top, e.width = t.diameter, e.height = t.diameter, e; }; }, function (t, e) { t.exports = function (t, e) { return t.x === e.x && t.y === e.y && t.radius === e.radius; }; }, function (t, e) { t.exports = function (t, e) { return e.setTo(t.x, t.y, t.radius); }; }, function (t, e, i) { const n = i(40); t.exports = function (t, e) { return n(t, e.x, e.y) && n(t, e.right, e.y) && n(t, e.x, e.bottom) && n(t, e.right, e.bottom); }; }, function (t, e, i) { const n = i(40); t.exports = function (t, e) { return n(t, e.x, e.y); }; }, function (t, e, i) { const n = i(71); t.exports = function (t) { return new n(t.x, t.y, t.radius); }; }, function (t, e) { t.exports = function (t) { return t.radius > 0 ? Math.PI * t.radius * t.radius : 0; }; }, function (t, e, i) { const n = i(71); n.Area = i(722), n.Circumference = i(402), n.CircumferencePoint = i(192), n.Clone = i(721), n.Contains = i(40), n.ContainsPoint = i(720), n.ContainsRect = i(719), n.CopyFrom = i(718), n.Equals = i(717), n.GetBounds = i(716), n.GetPoint = i(405), n.GetPoints = i(403), n.Offset = i(715), n.OffsetPoint = i(714), n.Random = i(191), t.exports = n; }, function (t, e, i) {
  const n = i(0); const s = i(275); const r = i(15); const o = new n({
    Extends: s, initialize(t) { this.scene = t, this.systems = t.sys, t.sys.settings.isBooted || t.sys.events.once('boot', this.boot, this), s.call(this); }, boot() { const t = this.systems.events; t.on('shutdown', this.shutdown, this), t.on('destroy', this.destroy, this); }, destroy() { this.shutdown(), this.scene = void 0, this.systems = void 0; },
  }); r.register('LightsPlugin', o, 'lights'), t.exports = o;
}, function (t, e, i) { const n = i(28); const s = i(13); const r = i(12); const o = i(149); s.register('quad', function (t, e) { void 0 === t && (t = {}); const i = r(t, 'x', 0); const s = r(t, 'y', 0); const a = r(t, 'key', null); const h = r(t, 'frame', null); const l = new o(this.scene, i, s, a, h); return void 0 !== e && (t.add = e), n(this.scene, l, t), l; }); }, function (t, e, i) { const n = i(28); const s = i(13); const r = i(12); const o = i(4); const a = i(108); s.register('mesh', function (t, e) { void 0 === t && (t = {}); const i = r(t, 'key', null); const s = r(t, 'frame', null); const h = o(t, 'vertices', []); const l = o(t, 'colors', []); const u = o(t, 'alphas', []); const c = o(t, 'uv', []); const d = new a(this.scene, 0, 0, h, c, l, u, i, s); return void 0 !== e && (t.add = e), n(this.scene, d, t), d; }); }, function (t, e, i) { const n = i(149); i(5).register('quad', function (t, e, i, s) { return this.displayList.add(new n(this.scene, t, e, i, s)); }); }, function (t, e, i) { const n = i(108); i(5).register('mesh', function (t, e, i, s, r, o, a, h) { return this.displayList.add(new n(this.scene, t, e, i, s, r, o, a, h)); }); }, function (t, e) { t.exports = function () {}; }, function (t, e, i) { const n = i(10); t.exports = function (t, e, i, s, r) { const o = this.pipeline; t.setPipeline(o, e); const a = o._tempMatrix1; const h = o._tempMatrix2; const l = o._tempMatrix3; h.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), a.copyFrom(s.matrix), r ? (a.multiplyWithOffset(r, -s.scrollX * e.scrollFactorX, -s.scrollY * e.scrollFactorY), h.e = e.x, h.f = e.y, a.multiply(h, l)) : (h.e -= s.scrollX * e.scrollFactorX, h.f -= s.scrollY * e.scrollFactorY, a.multiply(h, l)); const u = e.frame.glTexture; const c = e.vertices; const d = e.uv; const f = e.colors; const p = e.alphas; const g = c.length; const v = Math.floor(0.5 * g); o.vertexCount + v >= o.vertexCapacity && o.flush(), o.setTexture2D(u, 0); for (let y = o.vertexViewF32, m = o.vertexViewU32, x = o.vertexCount * o.vertexComponentCount - 1, w = 0, b = e.tintFill, T = 0; T < g; T += 2) { const S = c[T + 0]; const _ = c[T + 1]; let A = S * l.a + _ * l.c + l.e; let C = S * l.b + _ * l.d + l.f; s.roundPixels && (A |= 0, C |= 0), y[++x] = A, y[++x] = C, y[++x] = d[T + 0], y[++x] = d[T + 1], y[++x] = b, m[++x] = n.getTintAppendFloatAlpha(f[w], s.alpha * p[w]), w++; }o.vertexCount += v; }; }, function (t, e, i) { let n = i(1); let s = i(1); n = i(730), s = i(729), t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e, i) { const n = i(13); const s = i(12); const r = i(125); n.register('zone', function (t) { const e = s(t, 'x', 0); const i = s(t, 'y', 0); const n = s(t, 'width', 1); const o = s(t, 'height', n); return new r(this.scene, e, i, n, o); }); }, function (t, e, i) { const n = i(28); const s = i(13); const r = i(12); const o = i(152); s.register('tileSprite', function (t, e) { void 0 === t && (t = {}); const i = r(t, 'x', 0); const s = r(t, 'y', 0); const a = r(t, 'width', 512); const h = r(t, 'height', 512); const l = r(t, 'key', ''); const u = r(t, 'frame', ''); const c = new o(this.scene, i, s, a, h, l, u); return void 0 !== e && (t.add = e), n(this.scene, c, t), c; }); }, function (t, e, i) { const n = i(28); const s = i(13); const r = i(12); const o = i(153); s.register('text', function (t, e) { void 0 === t && (t = {}); const i = r(t, 'text', ''); const s = r(t, 'style', null); const a = r(t, 'padding', null); a !== null && (s.padding = a); const h = new o(this.scene, 0, 0, i, s); return void 0 !== e && (t.add = e), n(this.scene, h, t), h.autoRound = r(t, 'autoRound', !0), h.resolution = r(t, 'resolution', 1), h; }); }, function (t, e, i) { const n = i(109); const s = i(28); const r = i(13); const o = i(12); const a = i(4); r.register('bitmapText', function (t, e) { void 0 === t && (t = {}); const i = a(t, 'font', ''); const r = o(t, 'text', ''); const h = o(t, 'size', !1); const l = a(t, 'align', 0); const u = new n(this.scene, 0, 0, i, r, h, l); return void 0 !== e && (t.add = e), s(this.scene, u, t), u; }); }, function (t, e, i) { const n = i(28); const s = i(311); const r = i(13); const o = i(12); const a = i(61); r.register('sprite', function (t, e) { void 0 === t && (t = {}); const i = o(t, 'key', null); const r = o(t, 'frame', null); const h = new a(this.scene, 0, 0, i, r); return void 0 !== e && (t.add = e), n(this.scene, h, t), s(h, t), h; }); }, function (t, e, i) { const n = i(28); const s = i(13); const r = i(12); const o = i(154); s.register('renderTexture', function (t, e) { void 0 === t && (t = {}); const i = r(t, 'x', 0); const s = r(t, 'y', 0); const a = r(t, 'width', 32); const h = r(t, 'height', 32); const l = new o(this.scene, i, s, a, h); return void 0 !== e && (t.add = e), n(this.scene, l, t), l; }); }, function (t, e, i) { const n = i(13); const s = i(12); const r = i(2); const o = i(155); n.register('particles', function (t, e) { void 0 === t && (t = {}); const i = s(t, 'key', null); const n = s(t, 'frame', null); const a = r(t, 'emitters', null); const h = new o(this.scene, i, n, a); return void 0 !== e && (t.add = e), r(t, 'add', !1) && this.displayList.add(h), this.updateList.add(h), h; }); }, function (t, e, i) { const n = i(28); const s = i(13); const r = i(12); const o = i(87); s.register('image', function (t, e) { void 0 === t && (t = {}); const i = r(t, 'key', null); const s = r(t, 'frame', null); const a = new o(this.scene, 0, 0, i, s); return void 0 !== e && (t.add = e), n(this.scene, a, t), a; }); }, function (t, e, i) { const n = i(13); const s = i(88); n.register('group', function (t) { return new s(this.scene, null, t); }); }, function (t, e, i) { const n = i(13); const s = i(158); n.register('graphics', function (t, e) { void 0 === t && (t = {}), void 0 !== e && (t.add = e); const i = new s(this.scene, t); return t.add && this.scene.sys.displayList.add(i), i; }); }, function (t, e, i) { const n = i(159); const s = i(28); const r = i(13); const o = i(12); r.register('dynamicBitmapText', function (t, e) { void 0 === t && (t = {}); const i = o(t, 'font', ''); const r = o(t, 'text', ''); const a = o(t, 'size', !1); const h = new n(this.scene, 0, 0, i, r, a); return void 0 !== e && (t.add = e), s(this.scene, h, t), h; }); }, function (t, e, i) { const n = i(28); const s = i(160); const r = i(13); const o = i(12); r.register('container', function (t, e) { void 0 === t && (t = {}); const i = o(t, 'x', 0); const r = o(t, 'y', 0); const a = new s(this.scene, i, r); return void 0 !== e && (t.add = e), n(this.scene, a, t), a; }); }, function (t, e, i) { const n = i(161); const s = i(28); const r = i(13); const o = i(12); r.register('blitter', function (t, e) { void 0 === t && (t = {}); const i = o(t, 'key', null); const r = o(t, 'frame', null); const a = new n(this.scene, 0, 0, i, r); return void 0 !== e && (t.add = e), s(this.scene, a, t), a; }); }, function (t, e, i) { const n = i(5); const s = i(279); n.register('triangle', function (t, e, i, n, r, o, a, h, l, u) { return this.displayList.add(new s(this.scene, t, e, i, n, r, o, a, h, l, u)); }); }, function (t, e, i) { const n = i(280); i(5).register('star', function (t, e, i, s, r, o, a) { return this.displayList.add(new n(this.scene, t, e, i, s, r, o, a)); }); }, function (t, e, i) { const n = i(5); const s = i(281); n.register('rectangle', function (t, e, i, n, r, o) { return this.displayList.add(new s(this.scene, t, e, i, n, r, o)); }); }, function (t, e, i) { const n = i(5); const s = i(286); n.register('polygon', function (t, e, i, n, r) { return this.displayList.add(new s(this.scene, t, e, i, n, r)); }); }, function (t, e, i) { const n = i(5); const s = i(287); n.register('line', function (t, e, i, n, r, o, a, h) { return this.displayList.add(new s(this.scene, t, e, i, n, r, o, a, h)); }); }, function (t, e, i) { const n = i(5); const s = i(288); n.register('isotriangle', function (t, e, i, n, r, o, a, h) { return this.displayList.add(new s(this.scene, t, e, i, n, r, o, a, h)); }); }, function (t, e, i) { const n = i(5); const s = i(289); n.register('isobox', function (t, e, i, n, r, o, a) { return this.displayList.add(new s(this.scene, t, e, i, n, r, o, a)); }); }, function (t, e, i) { const n = i(5); const s = i(290); n.register('grid', function (t, e, i, n, r, o, a, h, l, u) { return this.displayList.add(new s(this.scene, t, e, i, n, r, o, a, h, l, u)); }); }, function (t, e, i) { const n = i(291); i(5).register('ellipse', function (t, e, i, s, r, o) { return this.displayList.add(new n(this.scene, t, e, i, s, r, o)); }); }, function (t, e, i) { const n = i(5); const s = i(292); n.register('curve', function (t, e, i, n, r) { return this.displayList.add(new s(this.scene, t, e, i, n, r)); }); }, function (t, e, i) { const n = i(293); const s = i(5); s.register('arc', function (t, e, i, s, r, o, a, h) { return this.displayList.add(new n(this.scene, t, e, i, s, r, o, a, h)); }), s.register('circle', function (t, e, i, s, r) { return this.displayList.add(new n(this.scene, t, e, i, 0, 360, !1, s, r)); }); }, function (t, e, i) { const n = i(125); i(5).register('zone', function (t, e, i, s) { return this.displayList.add(new n(this.scene, t, e, i, s)); }); }, function (t, e, i) { const n = i(152); i(5).register('tileSprite', function (t, e, i, s, r, o) { return this.displayList.add(new n(this.scene, t, e, i, s, r, o)); }); }, function (t, e, i) { const n = i(153); i(5).register('text', function (t, e, i, s) { return this.displayList.add(new n(this.scene, t, e, i, s)); }); }, function (t, e, i) { const n = i(109); i(5).register('bitmapText', function (t, e, i, s, r, o) { return this.displayList.add(new n(this.scene, t, e, i, s, r, o)); }); }, function (t, e, i) { const n = i(5); const s = i(61); n.register('sprite', function (t, e, i, n) { const r = new s(this.scene, t, e, i, n); return this.displayList.add(r), this.updateList.add(r), r; }); }, function (t, e, i) { const n = i(5); const s = i(154); n.register('renderTexture', function (t, e, i, n) { return this.displayList.add(new s(this.scene, t, e, i, n)); }); }, function (t, e, i) { const n = i(5); const s = i(296); n.register('follower', function (t, e, i, n, r) { const o = new s(this.scene, t, e, i, n, r); return this.displayList.add(o), this.updateList.add(o), o; }); }, function (t, e, i) { const n = i(5); const s = i(155); n.register('particles', function (t, e, i) { const n = new s(this.scene, t, e, i); return this.displayList.add(n), this.updateList.add(n), n; }); }, function (t, e, i) { const n = i(87); i(5).register('image', function (t, e, i, s) { return this.displayList.add(new n(this.scene, t, e, i, s)); }); }, function (t, e, i) { const n = i(88); i(5).register('group', function (t, e) { return this.updateList.add(new n(this.scene, t, e)); }); }, function (t, e, i) { const n = i(158); i(5).register('graphics', function (t) { return this.displayList.add(new n(this.scene, t)); }); }, function (t, e, i) { const n = i(159); i(5).register('dynamicBitmapText', function (t, e, i, s, r) { return this.displayList.add(new n(this.scene, t, e, i, s, r)); }); }, function (t, e, i) { const n = i(160); i(5).register('container', function (t, e, i) { return this.displayList.add(new n(this.scene, t, e, i)); }); }, function (t, e, i) { const n = i(161); i(5).register('blitter', function (t, e, i, s) { return this.displayList.add(new n(this.scene, t, e, i, s)); }); }, function (t, e, i) { const n = i(30); const s = i(36); const r = i(22); t.exports = function (t, e, i, o, a) { const h = t.currentContext; if (r(t, h, e, o, a)) { const l = e._displayOriginX; const u = e._displayOriginY; const c = e.geom.x1 - l; const d = e.geom.y1 - u; const f = e.geom.x2 - l; const p = e.geom.y2 - u; const g = e.geom.x3 - l; const v = e.geom.y3 - u; h.beginPath(), h.moveTo(c, d), h.lineTo(f, p), h.lineTo(g, v), h.closePath(), e.isFilled && (n(h, e), h.fill()), e.isStroked && (s(h, e), h.stroke()); } }; }, function (t, e, i) { const n = i(60); const s = i(10); t.exports = function (t, e, i, r, o) { const a = this.pipeline; const h = a._tempMatrix1; const l = a._tempMatrix2; const u = a._tempMatrix3; t.setPipeline(a), l.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), h.copyFrom(r.matrix), o ? (h.multiplyWithOffset(o, -r.scrollX * e.scrollFactorX, -r.scrollY * e.scrollFactorY), l.e = e.x, l.f = e.y) : (l.e -= r.scrollX * e.scrollFactorX, l.f -= r.scrollY * e.scrollFactorY), h.multiply(l, u); const c = e._displayOriginX; const d = e._displayOriginY; const f = r.alpha * e.alpha; if (e.isFilled) { const p = a.fillTint; const g = s.getTintAppendFloatAlphaAndSwap(e.fillColor, e.fillAlpha * f); p.TL = g, p.TR = g, p.BL = g, p.BR = g; const v = e.geom.x1 - c; const y = e.geom.y1 - d; const m = e.geom.x2 - c; const x = e.geom.y2 - d; const w = e.geom.x3 - c; const b = e.geom.y3 - d; a.setTexture2D(), a.batchFillTriangle(v, y, m, x, w, b, l, h); }e.isStroked && n(a, e, f, c, d); }; }, function (t, e, i) { let n = i(1); let s = i(1); n = i(771), s = i(770), t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e, i) { const n = i(30); const s = i(36); const r = i(22); t.exports = function (t, e, i, o, a) { const h = t.currentContext; if (r(t, h, e, o, a)) { const l = e._displayOriginX; const u = e._displayOriginY; const c = e.pathData; let d = c.length - 1; const f = c[0] - l; const p = c[1] - u; h.beginPath(), h.moveTo(f, p), e.closePath || (d -= 2); for (let g = 2; g < d; g += 2) { const v = c[g] - l; const y = c[g + 1] - u; h.lineTo(v, y); }h.closePath(), e.isFilled && (n(h, e), h.fill()), e.isStroked && (s(h, e), h.stroke()); } }; }, function (t, e, i) { const n = i(82); const s = i(60); t.exports = function (t, e, i, r, o) { const a = this.pipeline; const h = a._tempMatrix1; const l = a._tempMatrix2; const u = a._tempMatrix3; t.setPipeline(a), l.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), h.copyFrom(r.matrix), o ? (h.multiplyWithOffset(o, -r.scrollX * e.scrollFactorX, -r.scrollY * e.scrollFactorY), l.e = e.x, l.f = e.y) : (l.e -= r.scrollX * e.scrollFactorX, l.f -= r.scrollY * e.scrollFactorY), h.multiply(l, u); const c = e._displayOriginX; const d = e._displayOriginY; const f = r.alpha * e.alpha; e.isFilled && n(a, u, e, f, c, d), e.isStroked && s(a, e, f, c, d); }; }, function (t, e, i) { let n = i(1); let s = i(1); n = i(774), s = i(773), t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e, i) { const n = i(30); const s = i(36); const r = i(22); t.exports = function (t, e, i, o, a) { const h = t.currentContext; if (r(t, h, e, o, a)) { const l = e._displayOriginX; const u = e._displayOriginY; e.isFilled && (n(h, e), h.fillRect(-l, -u, e.width, e.height)), e.isStroked && (s(h, e), h.beginPath(), h.rect(-l, -u, e.width, e.height), h.stroke()); } }; }, function (t, e, i) { const n = i(60); const s = i(10); t.exports = function (t, e, i, r, o) { const a = this.pipeline; const h = a._tempMatrix1; const l = a._tempMatrix2; const u = a._tempMatrix3; t.setPipeline(a), l.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), h.copyFrom(r.matrix), o ? (h.multiplyWithOffset(o, -r.scrollX * e.scrollFactorX, -r.scrollY * e.scrollFactorY), l.e = e.x, l.f = e.y) : (l.e -= r.scrollX * e.scrollFactorX, l.f -= r.scrollY * e.scrollFactorY), h.multiply(l, u); const c = e._displayOriginX; const d = e._displayOriginY; const f = r.alpha * e.alpha; if (e.isFilled) { const p = a.fillTint; const g = s.getTintAppendFloatAlphaAndSwap(e.fillColor, e.fillAlpha * f); p.TL = g, p.TR = g, p.BL = g, p.BR = g, a.batchFillRect(-c, -d, e.width, e.height); }e.isStroked && n(a, e, f, c, d); }; }, function (t, e, i) { let n = i(1); let s = i(1); n = i(777), s = i(776), t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e, i) { const n = i(30); const s = i(36); const r = i(22); t.exports = function (t, e, i, o, a) { const h = t.currentContext; if (r(t, h, e, o, a)) { const l = e._displayOriginX; const u = e._displayOriginY; const c = e.pathData; let d = c.length - 1; const f = c[0] - l; const p = c[1] - u; h.beginPath(), h.moveTo(f, p), e.closePath || (d -= 2); for (let g = 2; g < d; g += 2) { const v = c[g] - l; const y = c[g + 1] - u; h.lineTo(v, y); }h.closePath(), e.isFilled && (n(h, e), h.fill()), e.isStroked && (s(h, e), h.stroke()); } }; }, function (t, e, i) { const n = i(82); const s = i(60); t.exports = function (t, e, i, r, o) { const a = this.pipeline; const h = a._tempMatrix1; const l = a._tempMatrix2; const u = a._tempMatrix3; t.setPipeline(a), l.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), h.copyFrom(r.matrix), o ? (h.multiplyWithOffset(o, -r.scrollX * e.scrollFactorX, -r.scrollY * e.scrollFactorY), l.e = e.x, l.f = e.y) : (l.e -= r.scrollX * e.scrollFactorX, l.f -= r.scrollY * e.scrollFactorY), h.multiply(l, u); const c = e._displayOriginX; const d = e._displayOriginY; const f = r.alpha * e.alpha; e.isFilled && n(a, u, e, f, c, d), e.isStroked && s(a, e, f, c, d); }; }, function (t, e, i) { let n = i(1); let s = i(1); n = i(780), s = i(779), t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e, i) { const n = i(36); const s = i(22); t.exports = function (t, e, i, r, o) { const a = t.currentContext; if (s(t, a, e, r, o)) { const h = e._displayOriginX; const l = e._displayOriginY; e.isStroked && (n(a, e), a.beginPath(), a.moveTo(e.geom.x1 - h, e.geom.y1 - l), a.lineTo(e.geom.x2 - h, e.geom.y2 - l), a.stroke()); } }; }, function (t, e, i) { const n = i(10); t.exports = function (t, e, i, s, r) { const o = this.pipeline; const a = o._tempMatrix1; const h = o._tempMatrix2; t.setPipeline(o), h.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), a.copyFrom(s.matrix), r ? (a.multiplyWithOffset(r, -s.scrollX * e.scrollFactorX, -s.scrollY * e.scrollFactorY), h.e = e.x, h.f = e.y) : (h.e -= s.scrollX * e.scrollFactorX, h.f -= s.scrollY * e.scrollFactorY); const l = e._displayOriginX; const u = e._displayOriginY; const c = s.alpha * e.alpha; if (e.isStroked) { const d = o.strokeTint; const f = n.getTintAppendFloatAlphaAndSwap(e.strokeColor, e.strokeAlpha * c); d.TL = f, d.TR = f, d.BL = f, d.BR = f; const p = e._startWidth; const g = e._endWidth; o.setTexture2D(), o.batchLine(e.geom.x1 - l, e.geom.y1 - u, e.geom.x2 - l, e.geom.y2 - u, p, g, 1, 0, !1, h, a); } }; }, function (t, e, i) { let n = i(1); let s = i(1); n = i(783), s = i(782), t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e, i) { const n = i(30); const s = i(22); t.exports = function (t, e, i, r, o) { const a = t.currentContext; if (s(t, a, e, r, o) && e.isFilled) { const h = e.width; const l = e.height; const u = h / 2; const c = h / e.projection; const d = e.isReversed; e.showTop && d && (n(a, e, e.fillTop), a.beginPath(), a.moveTo(-u, -l), a.lineTo(0, -c - l), a.lineTo(u, -l), a.lineTo(0, c - l), a.fill()), e.showLeft && (n(a, e, e.fillLeft), a.beginPath(), d ? (a.moveTo(-u, -l), a.lineTo(0, c), a.lineTo(0, c - l)) : (a.moveTo(-u, 0), a.lineTo(0, c), a.lineTo(0, c - l)), a.fill()), e.showRight && (n(a, e, e.fillRight), a.beginPath(), d ? (a.moveTo(u, -l), a.lineTo(0, c), a.lineTo(0, c - l)) : (a.moveTo(u, 0), a.lineTo(0, c), a.lineTo(0, c - l)), a.fill()); } }; }, function (t, e, i) { const n = i(10); t.exports = function (t, e, i, s, r) { const o = this.pipeline; const a = o._tempMatrix1; const h = o._tempMatrix2; const l = o._tempMatrix3; t.setPipeline(o), h.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), a.copyFrom(s.matrix), r ? (a.multiplyWithOffset(r, -s.scrollX * e.scrollFactorX, -s.scrollY * e.scrollFactorY), h.e = e.x, h.f = e.y) : (h.e -= s.scrollX * e.scrollFactorX, h.f -= s.scrollY * e.scrollFactorY), a.multiply(h, l); const u = e.width; const c = e.height; const d = u / 2; const f = u / e.projection; const p = e.isReversed; const g = s.alpha * e.alpha; if (e.isFilled) { let v; let y; let m; let x; let w; let b; let T; if (e.showTop && p) { v = n.getTintAppendFloatAlphaAndSwap(e.fillTop, g), y = l.getX(-d, -c), m = l.getY(-d, -c), x = l.getX(0, -f - c), w = l.getY(0, -f - c), b = l.getX(d, -c), T = l.getY(d, -c); const S = l.getX(0, f - c); const _ = l.getY(0, f - c); o.setTexture2D(), o.batchQuad(y, m, x, w, b, T, S, _, 0, 0, 1, 1, v, v, v, v, 2); }e.showLeft && (v = n.getTintAppendFloatAlphaAndSwap(e.fillLeft, g), p ? (y = l.getX(-d, -c), m = l.getY(-d, -c), x = l.getX(0, f), w = l.getY(0, f), b = l.getX(0, f - c), T = l.getY(0, f - c)) : (y = l.getX(-d, 0), m = l.getY(-d, 0), x = l.getX(0, f), w = l.getY(0, f), b = l.getX(0, f - c), T = l.getY(0, f - c)), o.batchTri(y, m, x, w, b, T, 0, 0, 1, 1, v, v, v, 2)), e.showRight && (v = n.getTintAppendFloatAlphaAndSwap(e.fillRight, g), p ? (y = l.getX(d, -c), m = l.getY(d, -c), x = l.getX(0, f), w = l.getY(0, f), b = l.getX(0, f - c), T = l.getY(0, f - c)) : (y = l.getX(d, 0), m = l.getY(d, 0), x = l.getX(0, f), w = l.getY(0, f), b = l.getX(0, f - c), T = l.getY(0, f - c)), o.setTexture2D(), o.batchTri(y, m, x, w, b, T, 0, 0, 1, 1, v, v, v, 2)); } }; }, function (t, e, i) { let n = i(1); let s = i(1); n = i(786), s = i(785), t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e, i) { const n = i(30); const s = i(22); t.exports = function (t, e, i, r, o) { const a = t.currentContext; if (s(t, a, e, r, o) && e.isFilled) { const h = e.width; const l = e.height; const u = h / 2; const c = h / e.projection; e.showTop && (n(a, e, e.fillTop), a.beginPath(), a.moveTo(-u, -l), a.lineTo(0, -c - l), a.lineTo(u, -l), a.lineTo(u, -1), a.lineTo(0, c - 1), a.lineTo(-u, -1), a.lineTo(-u, -l), a.fill()), e.showLeft && (n(a, e, e.fillLeft), a.beginPath(), a.moveTo(-u, 0), a.lineTo(0, c), a.lineTo(0, c - l), a.lineTo(-u, -l), a.lineTo(-u, 0), a.fill()), e.showRight && (n(a, e, e.fillRight), a.beginPath(), a.moveTo(u, 0), a.lineTo(0, c), a.lineTo(0, c - l), a.lineTo(u, -l), a.lineTo(u, 0), a.fill()); } }; }, function (t, e, i) { const n = i(10); t.exports = function (t, e, i, s, r) { const o = this.pipeline; const a = o._tempMatrix1; const h = o._tempMatrix2; const l = o._tempMatrix3; t.setPipeline(o), h.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), a.copyFrom(s.matrix), r ? (a.multiplyWithOffset(r, -s.scrollX * e.scrollFactorX, -s.scrollY * e.scrollFactorY), h.e = e.x, h.f = e.y) : (h.e -= s.scrollX * e.scrollFactorX, h.f -= s.scrollY * e.scrollFactorY), a.multiply(h, l); let u; let c; let d; let f; let p; let g; let v; let y; let m; const x = e.width; const w = e.height; const b = x / 2; const T = x / e.projection; const S = s.alpha * e.alpha; e.isFilled && (e.showTop && (u = n.getTintAppendFloatAlphaAndSwap(e.fillTop, S), c = l.getX(-b, -w), d = l.getY(-b, -w), f = l.getX(0, -T - w), p = l.getY(0, -T - w), g = l.getX(b, -w), v = l.getY(b, -w), y = l.getX(0, T - w), m = l.getY(0, T - w), o.setTexture2D(), o.batchQuad(c, d, f, p, g, v, y, m, 0, 0, 1, 1, u, u, u, u, 2)), e.showLeft && (u = n.getTintAppendFloatAlphaAndSwap(e.fillLeft, S), c = l.getX(-b, 0), d = l.getY(-b, 0), f = l.getX(0, T), p = l.getY(0, T), g = l.getX(0, T - w), v = l.getY(0, T - w), y = l.getX(-b, -w), m = l.getY(-b, -w), o.setTexture2D(), o.batchQuad(c, d, f, p, g, v, y, m, 0, 0, 1, 1, u, u, u, u, 2)), e.showRight && (u = n.getTintAppendFloatAlphaAndSwap(e.fillRight, S), c = l.getX(b, 0), d = l.getY(b, 0), f = l.getX(0, T), p = l.getY(0, T), g = l.getX(0, T - w), v = l.getY(0, T - w), y = l.getX(b, -w), m = l.getY(b, -w), o.setTexture2D(), o.batchQuad(c, d, f, p, g, v, y, m, 0, 0, 1, 1, u, u, u, u, 2))); }; }, function (t, e, i) { let n = i(1); let s = i(1); n = i(789), s = i(788), t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e, i) { const n = i(30); const s = i(36); const r = i(22); t.exports = function (t, e, i, o, a) { const h = t.currentContext; if (r(t, h, e, o, a)) { const l = e._displayOriginX; const u = e._displayOriginY; e.isFilled && (n(h, e), h.fillRect(-l, -u, e.width, e.height)), e.isStroked && (s(h, e), h.beginPath(), h.rect(-l, -u, e.width, e.height), h.stroke()); } }; }, function (t, e, i) { const n = i(10); t.exports = function (t, e, i, s, r) { const o = this.pipeline; const a = o._tempMatrix1; const h = o._tempMatrix2; const l = o._tempMatrix3; t.setPipeline(o), h.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), a.copyFrom(s.matrix), r ? (a.multiplyWithOffset(r, -s.scrollX * e.scrollFactorX, -s.scrollY * e.scrollFactorY), h.e = e.x, h.f = e.y) : (h.e -= s.scrollX * e.scrollFactorX, h.f -= s.scrollY * e.scrollFactorY), a.multiply(h, l), l.translate(-e._displayOriginX, -e._displayOriginY); let u; let c; const d = s.alpha * e.alpha; const f = e.width; const p = e.height; const g = e.cellWidth; const v = e.cellHeight; const y = Math.ceil(f / g); const m = Math.ceil(p / v); let x = g; let w = v; let b = g - (y * g - f); let T = v - (m * v - p); const S = e.showCells; const _ = e.showAltCells; const A = e.showOutline; let C = 0; let M = 0; let P = 0; let E = 0; let k = 0; if (A && (x--, w--, b === g && b--, T === v && T--), S && e.fillAlpha > 0) for (u = o.fillTint, c = n.getTintAppendFloatAlphaAndSwap(e.fillColor, e.fillAlpha * d), u.TL = c, u.TR = c, u.BL = c, u.BR = c, M = 0; M < m; M++) for (_ && (P = M % 2), C = 0; C < y; C++)_ && P ? P = 0 : (P++, E = C < y - 1 ? x : b, k = M < m - 1 ? w : T, o.setTexture2D(), o.batchFillRect(C * g, M * v, E, k)); if (_ && e.altFillAlpha > 0) for (u = o.fillTint, c = n.getTintAppendFloatAlphaAndSwap(e.altFillColor, e.altFillAlpha * d), u.TL = c, u.TR = c, u.BL = c, u.BR = c, M = 0; M < m; M++) for (_ && (P = M % 2), C = 0; C < y; C++)!_ || P ? (P = 0, E = C < y - 1 ? x : b, k = M < m - 1 ? w : T, o.setTexture2D(), o.batchFillRect(C * g, M * v, E, k)) : P = 1; if (A && e.outlineFillAlpha > 0) { const L = o.strokeTint; const F = n.getTintAppendFloatAlphaAndSwap(e.outlineFillColor, e.outlineFillAlpha * d); for (L.TL = F, L.TR = F, L.BL = F, L.BR = F, C = 1; C < y; C++) { const R = C * g; o.setTexture2D(), o.batchLine(R, 0, R, p, 1, 1, 1, 0, !1); } for (M = 1; M < m; M++) { const O = M * v; o.setTexture2D(), o.batchLine(0, O, f, O, 1, 1, 1, 0, !1); } } }; }, function (t, e, i) { let n = i(1); let s = i(1); n = i(792), s = i(791), t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e, i) { const n = i(30); const s = i(36); const r = i(22); t.exports = function (t, e, i, o, a) { const h = t.currentContext; if (r(t, h, e, o, a)) { const l = e._displayOriginX; const u = e._displayOriginY; const c = e.pathData; let d = c.length - 1; const f = c[0] - l; const p = c[1] - u; h.beginPath(), h.moveTo(f, p), e.closePath || (d -= 2); for (let g = 2; g < d; g += 2) { const v = c[g] - l; const y = c[g + 1] - u; h.lineTo(v, y); }h.closePath(), e.isFilled && (n(h, e), h.fill()), e.isStroked && (s(h, e), h.stroke()); } }; }, function (t, e, i) { const n = i(82); const s = i(60); t.exports = function (t, e, i, r, o) { const a = this.pipeline; const h = a._tempMatrix1; const l = a._tempMatrix2; const u = a._tempMatrix3; t.setPipeline(a), l.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), h.copyFrom(r.matrix), o ? (h.multiplyWithOffset(o, -r.scrollX * e.scrollFactorX, -r.scrollY * e.scrollFactorY), l.e = e.x, l.f = e.y) : (l.e -= r.scrollX * e.scrollFactorX, l.f -= r.scrollY * e.scrollFactorY), h.multiply(l, u); const c = e._displayOriginX; const d = e._displayOriginY; const f = r.alpha * e.alpha; e.isFilled && n(a, u, e, f, c, d), e.isStroked && s(a, e, f, c, d); }; }, function (t, e, i) { let n = i(1); let s = i(1); n = i(795), s = i(794), t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e, i) { const n = i(30); const s = i(36); const r = i(22); t.exports = function (t, e, i, o, a) { const h = t.currentContext; if (r(t, h, e, o, a)) { const l = e._displayOriginX + e._curveBounds.x; const u = e._displayOriginY + e._curveBounds.y; const c = e.pathData; let d = c.length - 1; const f = c[0] - l; const p = c[1] - u; h.beginPath(), h.moveTo(f, p), e.closePath || (d -= 2); for (let g = 2; g < d; g += 2) { const v = c[g] - l; const y = c[g + 1] - u; h.lineTo(v, y); }e.closePath && h.closePath(), e.isFilled && (n(h, e), h.fill()), e.isStroked && (s(h, e), h.stroke()); } }; }, function (t, e, i) { const n = i(82); const s = i(60); t.exports = function (t, e, i, r, o) { const a = this.pipeline; const h = a._tempMatrix1; const l = a._tempMatrix2; const u = a._tempMatrix3; t.setPipeline(a), l.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), h.copyFrom(r.matrix), o ? (h.multiplyWithOffset(o, -r.scrollX * e.scrollFactorX, -r.scrollY * e.scrollFactorY), l.e = e.x, l.f = e.y) : (l.e -= r.scrollX * e.scrollFactorX, l.f -= r.scrollY * e.scrollFactorY), h.multiply(l, u); const c = e._displayOriginX + e._curveBounds.x; const d = e._displayOriginY + e._curveBounds.y; const f = r.alpha * e.alpha; e.isFilled && n(a, u, e, f, c, d), e.isStroked && s(a, e, f, c, d); }; }, function (t, e, i) { let n = i(1); let s = i(1); n = i(798), s = i(797), t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e, i) { const n = i(31); const s = i(30); const r = i(36); const o = i(22); t.exports = function (t, e, i, a, h) { const l = t.currentContext; if (o(t, l, e, a, h)) { const u = e.radius; l.beginPath(), l.arc(u - e.originX * (2 * u), u - e.originY * (2 * u), u, n(e._startAngle), n(e._endAngle), e.anticlockwise), e.closePath && l.closePath(), e.isFilled && (s(l, e), l.fill()), e.isStroked && (r(l, e), l.stroke()); } }; }, function (t, e, i) { const n = i(82); const s = i(60); t.exports = function (t, e, i, r, o) { const a = this.pipeline; const h = a._tempMatrix1; const l = a._tempMatrix2; const u = a._tempMatrix3; t.setPipeline(a), l.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), h.copyFrom(r.matrix), o ? (h.multiplyWithOffset(o, -r.scrollX * e.scrollFactorX, -r.scrollY * e.scrollFactorY), l.e = e.x, l.f = e.y) : (l.e -= r.scrollX * e.scrollFactorX, l.f -= r.scrollY * e.scrollFactorY), h.multiply(l, u); const c = e._displayOriginX; const d = e._displayOriginY; const f = r.alpha * e.alpha; e.isFilled && n(a, u, e, f, c, d), e.isStroked && s(a, e, f, c, d); }; }, function (t, e, i) { let n = i(1); let s = i(1); n = i(801), s = i(800), t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e) { t.exports = function (t, e, i, n, s) { e.updateCanvas(), t.batchSprite(e, e.frame, n, s); }; }, function (t, e, i) { const n = i(10); t.exports = function (t, e, i, s, r) { e.updateCanvas(); const o = n.getTintAppendFloatAlpha; this.pipeline.batchTexture(e, e.fillPattern, e.displayFrame.width * e.tileScaleX, e.displayFrame.height * e.tileScaleY, e.x, e.y, e.width, e.height, e.scaleX, e.scaleY, e.rotation, e.flipX, e.flipY, e.scrollFactorX, e.scrollFactorY, e.originX * e.width, e.originY * e.height, 0, 0, e.width, e.height, o(e._tintTL, s.alpha * e._alphaTL), o(e._tintTR, s.alpha * e._alphaTR), o(e._tintBL, s.alpha * e._alphaBL), o(e._tintBR, s.alpha * e._alphaBR), e._isTinted && e.tintFill, e.tilePositionX % e.displayFrame.width / e.displayFrame.width, e.tilePositionY % e.displayFrame.height / e.displayFrame.height, s, r); }; }, function (t, e, i) { let n = i(1); let s = i(1); n = i(804), s = i(803), t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e, i) { const n = i(24); t.exports = function (t) { const e = n.create(this); const i = e.getContext('2d'); t.syncFont(e, i); const s = Math.ceil(i.measureText(t.testString).width * t.baselineX); let r = s; const o = 2 * r; r = r * t.baselineY | 0, e.width = s, e.height = o, i.fillStyle = '#f00', i.fillRect(0, 0, s, o), i.font = t._font, i.textBaseline = 'alphabetic', i.fillStyle = '#000', i.fillText(t.testString, 0, r); const a = { ascent: 0, descent: 0, fontSize: 0 }; if (!i.getImageData(0, 0, s, o)) return a.ascent = r, a.descent = r + 6, a.fontSize = a.ascent + a.descent, n.remove(e), a; let h; let l; const u = i.getImageData(0, 0, s, o).data; const c = u.length; const d = 4 * s; let f = 0; let p = !1; for (h = 0; h < r; h++) { for (l = 0; l < d; l += 4) if (u[f + l] !== 255) { p = !0; break; } if (p) break; f += d; } for (a.ascent = r - h, f = c - d, p = !1, h = o; h > r; h--) { for (l = 0; l < d; l += 4) if (u[f + l] !== 255) { p = !0; break; } if (p) break; f -= d; } return a.descent = h - r, a.fontSize = a.ascent + a.descent, n.remove(e), a; }; }, function (t, e, i) {
  const n = i(0); const s = i(12); const r = i(4); const o = i(806); const a = {
    fontFamily: ['fontFamily', 'Courier'], fontSize: ['fontSize', '16px'], fontStyle: ['fontStyle', ''], backgroundColor: ['backgroundColor', null], color: ['color', '#fff'], stroke: ['stroke', '#fff'], strokeThickness: ['strokeThickness', 0], shadowOffsetX: ['shadow.offsetX', 0], shadowOffsetY: ['shadow.offsetY', 0], shadowColor: ['shadow.color', '#000'], shadowBlur: ['shadow.blur', 0], shadowStroke: ['shadow.stroke', !1], shadowFill: ['shadow.fill', !1], align: ['align', 'left'], maxLines: ['maxLines', 0], fixedWidth: ['fixedWidth', 0], fixedHeight: ['fixedHeight', 0], resolution: ['resolution', 0], rtl: ['rtl', !1], testString: ['testString', '|Mqgy'], baselineX: ['baselineX', 1.2], baselineY: ['baselineY', 1.4], wordWrapWidth: ['wordWrap.width', null], wordWrapCallback: ['wordWrap.callback', null], wordWrapCallbackScope: ['wordWrap.callbackScope', null], wordWrapUseAdvanced: ['wordWrap.useAdvancedWrap', !1],
  }; const h = new n({
    initialize(t, e) { this.parent = t, this.fontFamily, this.fontSize, this.fontStyle, this.backgroundColor, this.color, this.stroke, this.strokeThickness, this.shadowOffsetX, this.shadowOffsetY, this.shadowColor, this.shadowBlur, this.shadowStroke, this.shadowFill, this.align, this.maxLines, this.fixedWidth, this.fixedHeight, this.resolution, this.rtl, this.testString, this.baselineX, this.baselineY, this._font, this.setStyle(e, !1, !0); const i = r(e, 'metrics', !1); this.metrics = i ? { ascent: r(i, 'ascent', 0), descent: r(i, 'descent', 0), fontSize: r(i, 'fontSize', 0) } : o(this); }, setStyle(t, e, i) { for (const n in void 0 === e && (e = !0), void 0 === i && (i = !1), t && t.hasOwnProperty('fontSize') && typeof t.fontSize === 'number' && (t.fontSize = `${t.fontSize.toString()}px`), a) { const o = i ? a[n][1] : this[n]; this[n] = n === 'wordWrapCallback' || n === 'wordWrapCallbackScope' ? r(t, a[n][0], o) : s(t, a[n][0], o); } const h = r(t, 'font', null); this._font = h === null ? [this.fontStyle, this.fontSize, this.fontFamily].join(' ').trim() : h; const l = r(t, 'fill', null); return l !== null && (this.color = l), e ? this.update(!0) : this.parent; }, syncFont(t, e) { e.font = this._font; }, syncStyle(t, e) { e.textBaseline = 'alphabetic', e.fillStyle = this.color, e.strokeStyle = this.stroke, e.lineWidth = this.strokeThickness, e.lineCap = 'round', e.lineJoin = 'round'; }, syncShadow(t, e) { e ? (t.shadowOffsetX = this.shadowOffsetX, t.shadowOffsetY = this.shadowOffsetY, t.shadowColor = this.shadowColor, t.shadowBlur = this.shadowBlur) : (t.shadowOffsetX = 0, t.shadowOffsetY = 0, t.shadowColor = 0, t.shadowBlur = 0); }, update(t) { return t && (this._font = [this.fontStyle, this.fontSize, this.fontFamily].join(' ').trim(), this.metrics = o(this)), this.parent.updateText(); }, setFont(t) { let e = t; let i = ''; let n = ''; return typeof t !== 'string' && (e = r(t, 'fontFamily', 'Courier'), i = r(t, 'fontSize', '16px'), n = r(t, 'fontStyle', '')), e === this.fontFamily && i === this.fontSize && n === this.fontStyle || (this.fontFamily = e, this.fontSize = i, this.fontStyle = n, this.update(!0)), this.parent; }, setFontFamily(t) { return this.fontFamily !== t && (this.fontFamily = t, this.update(!0)), this.parent; }, setFontStyle(t) { return this.fontStyle !== t && (this.fontStyle = t, this.update(!0)), this.parent; }, setFontSize(t) { return typeof t === 'number' && (t = `${t.toString()}px`), this.fontSize !== t && (this.fontSize = t, this.update(!0)), this.parent; }, setTestString(t) { return this.testString = t, this.update(!0); }, setFixedSize(t, e) { return this.fixedWidth = t, this.fixedHeight = e, t && (this.parent.width = t), e && (this.parent.height = e), this.update(!1); }, setBackgroundColor(t) { return this.backgroundColor = t, this.update(!1); }, setFill(t) { return this.color = t, this.update(!1); }, setColor(t) { return this.color = t, this.update(!1); }, setResolution(t) { return this.resolution = t, this.update(!1); }, setStroke(t, e) { return void 0 === e && (e = this.strokeThickness), void 0 === t && this.strokeThickness !== 0 ? (this.strokeThickness = 0, this.update(!0)) : this.stroke === t && this.strokeThickness === e || (this.stroke = t, this.strokeThickness = e, this.update(!0)), this.parent; }, setShadow(t, e, i, n, s, r) { return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = '#000'), void 0 === n && (n = 0), void 0 === s && (s = !1), void 0 === r && (r = !0), this.shadowOffsetX = t, this.shadowOffsetY = e, this.shadowColor = i, this.shadowBlur = n, this.shadowStroke = s, this.shadowFill = r, this.update(!1); }, setShadowOffset(t, e) { return void 0 === t && (t = 0), void 0 === e && (e = t), this.shadowOffsetX = t, this.shadowOffsetY = e, this.update(!1); }, setShadowColor(t) { return void 0 === t && (t = '#000'), this.shadowColor = t, this.update(!1); }, setShadowBlur(t) { return void 0 === t && (t = 0), this.shadowBlur = t, this.update(!1); }, setShadowStroke(t) { return this.shadowStroke = t, this.update(!1); }, setShadowFill(t) { return this.shadowFill = t, this.update(!1); }, setWordWrapWidth(t, e) { return void 0 === e && (e = !1), this.wordWrapWidth = t, this.wordWrapUseAdvanced = e, this.update(!1); }, setWordWrapCallback(t, e) { return void 0 === e && (e = null), this.wordWrapCallback = t, this.wordWrapCallbackScope = e, this.update(!1); }, setAlign(t) { return void 0 === t && (t = 'left'), this.align = t, this.update(!1); }, setMaxLines(t) { return void 0 === t && (t = 0), this.maxLines = t, this.update(!1); }, getTextMetrics() { const t = this.metrics; return { ascent: t.ascent, descent: t.descent, fontSize: t.fontSize }; }, toJSON() { const t = {}; for (const e in a)t[e] = this[e]; return t.metrics = this.getTextMetrics(), t; }, destroy() { this.parent = void 0; },
  }); t.exports = h;
}, function (t, e) { t.exports = function (t, e, i, n, s) { e.text !== '' && t.batchSprite(e, e.frame, n, s); }; }, function (t, e, i) { const n = i(10); t.exports = function (t, e, i, s, r) { if (e.text !== '') { const o = e.frame; const a = o.width; const h = o.height; const l = n.getTintAppendFloatAlpha; this.pipeline.batchTexture(e, o.glTexture, a, h, e.x, e.y, a / e.style.resolution, h / e.style.resolution, e.scaleX, e.scaleY, e.rotation, e.flipX, e.flipY, e.scrollFactorX, e.scrollFactorY, e.displayOriginX, e.displayOriginY, 0, 0, a, h, l(e._tintTL, s.alpha * e._alphaTL), l(e._tintTR, s.alpha * e._alphaTR), l(e._tintBL, s.alpha * e._alphaBL), l(e._tintBR, s.alpha * e._alphaBR), e._isTinted && e.tintFill, 0, 0, s, r); } }; }, function (t, e, i) { let n = i(1); let s = i(1); n = i(809), s = i(808), t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e) {
  t.exports = function (t, e, i) {
    const n = t.canvas; const s = t.context; const r = t.style; const o = []; let a = 0; let h = i.length; r.maxLines > 0 && r.maxLines < i.length && (h = r.maxLines), r.syncFont(n, s); for (let l = 0; l < h; l++) { let u = r.strokeThickness; u += s.measureText(i[l]).width, r.wordWrap && (u -= s.measureText(' ').width), o[l] = Math.ceil(u), a = Math.max(a, o[l]); } const c = e.fontSize + r.strokeThickness; let d = c * h; const f = t.lineSpacing; return i.length > 1 && (d += f * (i.length - 1)), {
      width: a, height: d, lines: h, lineWidths: o, lineSpacing: f, lineHeight: c,
    };
  };
}, function (t, e, i) {
  const n = i(4); t.exports = function (t, e) {
    const i = e.width; const s = e.height; const r = Math.floor(i / 2); const o = Math.floor(s / 2); const a = n(e, 'chars', ''); if (a !== '') {
      const h = n(e, 'image', ''); const l = n(e, 'offset.x', 0); const u = n(e, 'offset.y', 0); const c = n(e, 'spacing.x', 0); const d = n(e, 'spacing.y', 0); const f = n(e, 'lineSpacing', 0); let p = n(e, 'charsPerRow', null); p === null && (p = t.sys.textures.getFrame(h).width / i) > a.length && (p = a.length); for (var g = l, v = u, y = {
          retroFont: !0, font: h, size: i, lineHeight: s + f, chars: {},
        }, m = 0, x = 0; x < a.length; x++) {
        const w = a.charCodeAt(x); y.chars[w] = {
          x: g, y: v, width: i, height: s, centerX: r, centerY: o, xOffset: 0, yOffset: 0, xAdvance: i, data: {}, kerning: {},
        }, ++m === p ? (m = 0, g = l, v += s + d) : g += i + c;
      } return { data: y, frame: null, texture: h };
    }
  };
}, function (t, e) {
  t.exports = {
    TEXT_SET1: " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~", TEXT_SET2: " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ", TEXT_SET3: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ', TEXT_SET4: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789', TEXT_SET5: "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,/() '!?-*:0123456789", TEXT_SET6: "ABCDEFGHIJKLMNOPQRSTUVWXYZ!?:;0123456789\"(),-.' ", TEXT_SET7: "AGMSY+:4BHNTZ!;5CIOU.?06DJPV,(17EKQW\")28FLRX-'39", TEXT_SET8: '0123456789 .ABCDEFGHIJKLMNOPQRSTUVWXYZ', TEXT_SET9: "ABCDEFGHIJKLMNOPQRSTUVWXYZ()-0123456789.:,'\"?!", TEXT_SET10: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', TEXT_SET11: "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,\"-+!?()':;0123456789",
  };
}, function (t, e, i) { const n = i(813); const s = i(20); let r = { Parse: i(812) }; r = s(!1, r, n), t.exports = r; }, function (t, e) { t.exports = function (t, e, i, n, s) { t.batchSprite(e, e.frame, n, s); }; }, function (t, e, i) { const n = i(10); t.exports = function (t, e, i, s, r) { const o = e.frame; const a = o.width; const h = o.height; const l = n.getTintAppendFloatAlpha; this.pipeline.batchTexture(e, o.glTexture, a, h, e.x, e.y, a, h, e.scaleX, e.scaleY, e.rotation, e.flipX, !e.flipY, e.scrollFactorX, e.scrollFactorY, e.displayOriginX, e.displayOriginY, 0, 0, a, h, l(e._tintTL, s.alpha * e._alphaTL), l(e._tintTR, s.alpha * e._alphaTR), l(e._tintBL, s.alpha * e._alphaBL), l(e._tintBR, s.alpha * e._alphaBR), e._isTinted && e.tintFill, 0, 0, s, r), t.setBlankTexture(!0); }; }, function (t, e, i) { let n = i(1); let s = i(1); n = i(816), s = i(815), t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e, i) { t.exports = { DeathZone: i(301), EdgeZone: i(300), RandomZone: i(297) }; }, function (t, e) { t.exports = function (t, e, i, n, s) { const r = e.emitters.list; const o = r.length; if (o !== 0) { const a = t._tempMatrix1.copyFrom(n.matrix); const h = t._tempMatrix2; const l = t._tempMatrix3; const u = t._tempMatrix4.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY); a.multiply(u); const c = n.roundPixels; const d = t.currentContext; d.save(); for (let f = 0; f < o; f++) { const p = r[f]; const g = p.alive; const v = g.length; if (p.visible && v !== 0) { let y = n.scrollX * p.scrollFactorX; let m = n.scrollY * p.scrollFactorY; s && (a.multiplyWithOffset(s, -y, -m), y = 0, m = 0), d.globalCompositeOperation = t.blendModes[p.blendMode]; for (let x = 0; x < v; x++) { const w = g[x]; const b = w.alpha * n.alpha; if (!(b <= 0)) { const T = w.frame; const S = T.canvasData; let _ = -T.halfWidth; let A = -T.halfHeight; l.applyITRS(0, 0, w.rotation, w.scaleX, w.scaleY), l.e = w.x - y, l.f = w.y - m, a.multiply(l, h), d.globalAlpha = b, d.save(), h.copyToContext(d), c && (_ |= 0, A |= 0), d.drawImage(T.source.image, S.x, S.y, S.width, S.height, _, A, S.width, S.height), d.restore(); } } } }d.restore(); } }; }, function (t, e, i) { const n = i(10); t.exports = function (t, e, i, s, r) { const o = e.emitters.list; const a = o.length; if (a !== 0) { const h = this.pipeline; const l = h._tempMatrix1.copyFrom(s.matrix); const u = h._tempMatrix2; const c = h._tempMatrix3; const d = h._tempMatrix4.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY); l.multiply(d), t.setPipeline(h); const f = s.roundPixels; const p = e.defaultFrame.glTexture; const g = n.getTintAppendFloatAlphaAndSwap; h.setTexture2D(p, 0); for (let v = 0; v < a; v++) { const y = o[v]; const m = y.alive; const x = m.length; if (y.visible && x !== 0) { let w = s.scrollX * y.scrollFactorX; let b = s.scrollY * y.scrollFactorY; r && (l.multiplyWithOffset(r, -w, -b), w = 0, b = 0), t.setBlendMode(y.blendMode) && h.setTexture2D(p, 0); for (let T = 0; T < x; T++) { const S = m[T]; const _ = S.alpha * s.alpha; if (!(_ <= 0)) { const A = S.frame; const C = -A.halfWidth; const M = -A.halfHeight; const P = C + A.width; const E = M + A.height; c.applyITRS(0, 0, S.rotation, S.scaleX, S.scaleY), c.e = S.x - w, c.f = S.y - b, l.multiply(c, u); let k = u.getX(C, M); let L = u.getY(C, M); let F = u.getX(C, E); let R = u.getY(C, E); let O = u.getX(P, E); let D = u.getY(P, E); let B = u.getX(P, M); let I = u.getY(P, M); f && (k |= 0, L |= 0, F |= 0, R |= 0, O |= 0, D |= 0, B |= 0, I |= 0); const Y = g(S.tint, _); h.batchQuad(k, L, F, R, O, D, B, I, A.u0, A.v0, A.u1, A.v1, Y, Y, Y, Y, 0) && h.setTexture2D(p, 0); } } } } } }; }, function (t, e, i) { let n = i(1); let s = i(1); n = i(820), s = i(819), t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e, i) {
  const n = i(0); const s = i(299); const r = i(86); const o = i(2); const a = i(53); const h = new n({
    initialize(t, e, i, n) { void 0 === n && (n = !1), this.propertyKey = e, this.propertyValue = i, this.defaultValue = i, this.steps = 0, this.counter = 0, this.start = 0, this.end = 0, this.ease, this.emitOnly = n, this.onEmit = this.defaultEmit, this.onUpdate = this.defaultUpdate, this.loadConfig(t); }, loadConfig(t, e) { void 0 === t && (t = {}), e && (this.propertyKey = e), this.propertyValue = o(t, this.propertyKey, this.defaultValue), this.setMethods(), this.emitOnly && (this.onUpdate = this.defaultUpdate); }, toJSON() { return this.propertyValue; }, onChange(t) { return this.propertyValue = t, this.setMethods(); }, setMethods() { const t = this.propertyValue; const e = typeof t; if (e === 'number') this.onEmit = this.staticValueEmit, this.onUpdate = this.staticValueUpdate; else if (Array.isArray(t)) this.onEmit = this.randomStaticValueEmit; else if (e === 'function') this.emitOnly ? this.onEmit = t : this.onUpdate = t; else if (e === 'object' && (this.has(t, 'random') || this.hasBoth(t, 'start', 'end') || this.hasBoth(t, 'min', 'max'))) { this.start = this.has(t, 'start') ? t.start : t.min, this.end = this.has(t, 'end') ? t.end : t.max; const i = this.hasBoth(t, 'min', 'max') || this.has(t, 'random'); if (i) { const n = t.random; Array.isArray(n) && (this.start = n[0], this.end = n[1]), this.onEmit = this.randomRangedValueEmit; } if (this.has(t, 'steps')) this.steps = t.steps, this.counter = this.start, this.onEmit = this.steppedEmit; else { const s = this.has(t, 'ease') ? t.ease : 'Linear'; this.ease = r(s), i || (this.onEmit = this.easedValueEmit), this.onUpdate = this.easeValueUpdate; } } else e === 'object' && this.hasEither(t, 'onEmit', 'onUpdate') && (this.has(t, 'onEmit') && (this.onEmit = t.onEmit), this.has(t, 'onUpdate') && (this.onUpdate = t.onUpdate)); return this; }, has(t, e) { return t.hasOwnProperty(e); }, hasBoth(t, e, i) { return t.hasOwnProperty(e) && t.hasOwnProperty(i); }, hasEither(t, e, i) { return t.hasOwnProperty(e) || t.hasOwnProperty(i); }, defaultEmit(t, e, i) { return i; }, defaultUpdate(t, e, i, n) { return n; }, staticValueEmit() { return this.propertyValue; }, staticValueUpdate() { return this.propertyValue; }, randomStaticValueEmit() { const t = Math.floor(Math.random() * this.propertyValue.length); return this.propertyValue[t]; }, randomRangedValueEmit(t, e) { const i = s(this.start, this.end); return t && t.data[e] && (t.data[e].min = i), i; }, steppedEmit() { const t = this.counter; const e = this.counter + (this.end - this.start) / this.steps; return this.counter = a(e, this.start, this.end), t; }, easedValueEmit(t, e) { if (t && t.data[e]) { const i = t.data[e]; i.min = this.start, i.max = this.end; } return this.start; }, easeValueUpdate(t, e, i) { const n = t.data[e]; return (n.max - n.min) * this.ease(i) + n.min; },
  }); t.exports = h;
}, function (t, e, i) {
  t.exports = {
    GravityWell: i(304), Particle: i(303), ParticleEmitter: i(302), ParticleEmitterManager: i(155), Zones: i(818),
  };
}, function (t, e) { t.exports = function (t, e, i, n, s) { t.batchSprite(e, e.frame, n, s); }; }, function (t, e) { t.exports = function (t, e, i, n, s) { this.pipeline.batchSprite(e, n, s); }; }, function (t, e, i) { let n = i(1); let s = i(1); n = i(825), s = i(824), t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e) { t.exports = function (t, e, i, n, s) { t.batchSprite(e, e.frame, n, s); }; }, function (t, e) { t.exports = function (t, e, i, n, s) { this.pipeline.batchSprite(e, n, s); }; }, function (t, e, i) { let n = i(1); let s = i(1); n = i(828), s = i(827), t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e, i) { const n = i(157); const s = i(10); const r = function (t, e, i) { this.x = t, this.y = e, this.width = i; }; const o = function (t, e, i) { this.points = [], this.pointsLength = 1, this.points[0] = new r(t, e, i); }; const a = []; t.exports = function (t, e, i, h, l) { if (e.commandBuffer.length !== 0) { const u = this.pipeline; const c = u._tempMatrix1; const d = u._tempMatrix2; const f = u._tempMatrix4; t.setPipeline(u), f.loadIdentity(), d.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), c.copyFrom(h.matrix), l ? (c.multiplyWithOffset(l, -h.scrollX * e.scrollFactorX, -h.scrollY * e.scrollFactorY), d.e = e.x, d.f = e.y, c.multiply(d)) : (d.e -= h.scrollX * e.scrollFactorX, d.f -= h.scrollY * e.scrollFactorY, c.multiply(d)); for (let p = e.commandBuffer, g = h.alpha * e.alpha, v = 1, y = u.fillTint, m = u.strokeTint, x = 0, w = 0, b = 0, T = 2 * Math.PI, S = [], _ = 0, A = !1, C = null, M = s.getTintAppendFloatAlphaAndSwap, P = t.blankTexture.glTexture, E = 0; E < p.length; E++) switch (p[E]) { case n.BEGIN_PATH: S.length = 0, C = null, A = !0; break; case n.CLOSE_PATH: A = !1, C && C.points.length && C.points.push(C.points[0]); break; case n.FILL_PATH: for (_ = 0; _ < S.length; _++)u.setTexture2D(P), u.batchFillPath(S[_].points, f, c); break; case n.STROKE_PATH: for (_ = 0; _ < S.length; _++)u.setTexture2D(P), u.batchStrokePath(S[_].points, v, A, f, c); break; case n.LINE_STYLE: v = p[++E]; var k = M(p[++E], p[++E] * g); m.TL = k, m.TR = k, m.BL = k, m.BR = k; break; case n.FILL_STYLE: var L = M(p[++E], p[++E] * g); y.TL = L, y.TR = L, y.BL = L, y.BR = L; break; case n.GRADIENT_FILL_STYLE: var F = p[++E] * g; y.TL = M(p[++E], F), y.TR = M(p[++E], F), y.BL = M(p[++E], F), y.BR = M(p[++E], F); break; case n.GRADIENT_LINE_STYLE: v = p[++E]; var R = p[++E] * g; m.TL = M(p[++E], R), m.TR = M(p[++E], R), m.BL = M(p[++E], R), m.BR = M(p[++E], R); break; case n.ARC: var O = 0; var D = p[++E]; var B = p[++E]; var I = p[++E]; var Y = p[++E]; var X = p[++E]; var z = p[++E]; var N = p[++E]; for (X -= Y, z ? X < -T ? X = -T : X > 0 && (X = X % T - T) : X > T ? X = T : X < 0 && (X = T + X % T), C === null && (C = new o(D + Math.cos(Y) * I, B + Math.sin(Y) * I, v), S.push(C), O += 0.01); O < 1 + N;)b = X * O + Y, x = D + Math.cos(b) * I, w = B + Math.sin(b) * I, C.points.push(new r(x, w, v)), O += 0.01; b = X + Y, x = D + Math.cos(b) * I, w = B + Math.sin(b) * I, C.points.push(new r(x, w, v)); break; case n.FILL_RECT: u.setTexture2D(P), u.batchFillRect(p[++E], p[++E], p[++E], p[++E], f, c); break; case n.FILL_TRIANGLE: u.setTexture2D(P), u.batchFillTriangle(p[++E], p[++E], p[++E], p[++E], p[++E], p[++E], f, c); break; case n.STROKE_TRIANGLE: u.setTexture2D(P), u.batchStrokeTriangle(p[++E], p[++E], p[++E], p[++E], p[++E], p[++E], v, f, c); break; case n.LINE_TO: C !== null ? C.points.push(new r(p[++E], p[++E], v)) : (C = new o(p[++E], p[++E], v), S.push(C)); break; case n.MOVE_TO: C = new o(p[++E], p[++E], v), S.push(C); break; case n.SAVE: a.push(f.copyToArray()); break; case n.RESTORE: f.copyFromArray(a.pop()); break; case n.TRANSLATE: D = p[++E], B = p[++E], f.translate(D, B); break; case n.SCALE: D = p[++E], B = p[++E], f.scale(D, B); break; case n.ROTATE: f.rotate(p[++E]); break; case n.SET_TEXTURE: var U = p[++E]; var V = p[++E]; u.currentFrame = U, u.setTexture2D(U.glTexture, 0), u.tintEffect = V, P = U.glTexture; break; case n.CLEAR_TEXTURE: u.currentFrame = t.blankTexture, u.tintEffect = 2, P = t.blankTexture.glTexture; } } }; }, function (t, e, i) { let n = i(1); let s = i(1); n = i(830), s = i(305), s = i(305), t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e, i) {
  const n = i(22); t.exports = function (t, e, i, s, r) {
    const o = e.text; const a = o.length; const h = t.currentContext; if (a !== 0 && n(t, h, e, s, r)) {
      const l = e.frame; const u = e.displayCallback; const c = s.scrollX * e.scrollFactorX; const d = s.scrollY * e.scrollFactorY; const f = e.fontData.chars; const p = e.fontData.lineHeight; let g = 0; let v = 0; let y = 0; let m = 0; let x = null; let w = 0; let b = 0; let T = 0; let S = 0; let _ = 0; let A = 0; let C = null; let M = 0; const P = e.frame.source.image; const E = l.cutX; const k = l.cutY; let L = 0; let F = e.fontSize / e.fontData.size; e.cropWidth > 0 && e.cropHeight > 0 && (h.save(), h.beginPath(), h.rect(0, 0, e.cropWidth, e.cropHeight), h.clip()); for (let R = 0; R < a; ++R) {
        if (F = e.fontSize / e.fontData.size, L = 0, (m = o.charCodeAt(R)) !== 10) {
          if (x = f[m]) {
            if (w = E + x.x, b = k + x.y, T = x.width, S = x.height, _ = y + x.xOffset + g - e.scrollX, A = x.yOffset + v - e.scrollY, C !== null) { const O = x.kerning[M]; _ += void 0 !== O ? O : 0; } if (u) {
              const D = u({
                tint: {
                  topLeft: 0, topRight: 0, bottomLeft: 0, bottomRight: 0,
                },
                index: R,
                charCode: m,
                x: _,
                y: A,
                scale: F,
                rotation: 0,
                data: x.data,
              }); _ = D.x, A = D.y, F = D.scale, L = D.rotation;
            }_ *= F, A *= F, _ -= c, A -= d, s.roundPixels && (_ |= 0, A |= 0), h.save(), h.translate(_, A), h.rotate(L), h.scale(F, F), h.drawImage(P, w, b, T, S, 0, 0, T, S), h.restore(), g += x.xAdvance, y += 1, C = x, M = m;
          }
        } else g = 0, y = 0, v += p, C = null;
      } e.cropWidth > 0 && e.cropHeight > 0 && h.restore(), h.restore();
    }
  };
}, function (t, e, i) { const n = i(10); t.exports = function (t, e, i, s, r) { const o = e.text; const a = o.length; if (a !== 0) { const h = this.pipeline; t.setPipeline(h, e); const l = e.cropWidth > 0 || e.cropHeight > 0; l && (h.flush(), t.pushScissor(e.x, e.y, e.cropWidth * e.scaleX, e.cropHeight * e.scaleY)); const u = h._tempMatrix1; const c = h._tempMatrix2; const d = h._tempMatrix3; const f = h._tempMatrix4; c.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), u.copyFrom(s.matrix), r ? (u.multiplyWithOffset(r, -s.scrollX * e.scrollFactorX, -s.scrollY * e.scrollFactorY), c.e = e.x, c.f = e.y, u.multiply(c, d)) : (c.e -= s.scrollX * e.scrollFactorX, c.f -= s.scrollY * e.scrollFactorY, u.multiply(c, d)); const p = e.frame; const g = p.glTexture; const v = p.cutX; const y = p.cutY; const m = g.width; const x = g.height; const w = e._isTinted && e.tintFill; let b = n.getTintAppendFloatAlpha(e._tintTL, s.alpha * e._alphaTL); let T = n.getTintAppendFloatAlpha(e._tintTR, s.alpha * e._alphaTR); let S = n.getTintAppendFloatAlpha(e._tintBL, s.alpha * e._alphaBL); let _ = n.getTintAppendFloatAlpha(e._tintBR, s.alpha * e._alphaBR); h.setTexture2D(g, 0); let A; let C; let M = 0; let P = 0; let E = 0; let k = 0; const L = e.letterSpacing; let F = 0; let R = 0; let O = 0; let D = 0; const B = e.scrollX; const I = e.scrollY; const Y = e.fontData; const X = Y.chars; const z = Y.lineHeight; let N = e.fontSize / Y.size; let U = 0; const V = e._align; let G = 0; let W = 0; e.getTextBounds(!1); const H = e._bounds.lines; V === 1 ? W = (H.longest - H.lengths[0]) / 2 : V === 2 && (W = H.longest - H.lengths[0]); for (let j = s.roundPixels, q = e.displayCallback, K = e.callbackData, J = 0; J < a; J++) if ((E = o.charCodeAt(J)) !== 10) { if (A = X[E]) { F = v + A.x, R = y + A.y, O = A.width, D = A.height; let Z = A.xOffset + M - B; let Q = A.yOffset + P - I; if (C !== null) { const $ = A.kerning[k]; Z += void 0 !== $ ? $ : 0; } if (M += A.xAdvance + L, C = A, k = E, O !== 0 && D !== 0 && E !== 32) { if (N = e.fontSize / e.fontData.size, U = 0, q) { K.color = 0, K.tint.topLeft = b, K.tint.topRight = T, K.tint.bottomLeft = S, K.tint.bottomRight = _, K.index = J, K.charCode = E, K.x = Z, K.y = Q, K.scale = N, K.rotation = U, K.data = A.data; const tt = q(K); Z = tt.x, Q = tt.y, N = tt.scale, U = tt.rotation, tt.color ? (b = tt.color, T = tt.color, S = tt.color, _ = tt.color) : (b = tt.tint.topLeft, T = tt.tint.topRight, S = tt.tint.bottomLeft, _ = tt.tint.bottomRight), b = n.getTintAppendFloatAlpha(b, s.alpha * e._alphaTL), T = n.getTintAppendFloatAlpha(T, s.alpha * e._alphaTR), S = n.getTintAppendFloatAlpha(S, s.alpha * e._alphaBL), _ = n.getTintAppendFloatAlpha(_, s.alpha * e._alphaBR); }Z *= N, Q *= N, Z -= e.displayOriginX, Q -= e.displayOriginY, Z += W, f.applyITRS(Z, Q, U, N, N), d.multiply(f, c); const et = F / m; const it = R / x; const nt = (F + O) / m; const st = (R + D) / x; const rt = O; const ot = D; let at = c.e; let ht = c.f; let lt = ot * c.c + c.e; let ut = ot * c.d + c.f; let ct = rt * c.a + ot * c.c + c.e; let dt = rt * c.b + ot * c.d + c.f; let ft = rt * c.a + c.e; let pt = rt * c.b + c.f; j && (at |= 0, ht |= 0, lt |= 0, ut |= 0, ct |= 0, dt |= 0, ft |= 0, pt |= 0), h.batchQuad(at, ht, lt, ut, ct, dt, ft, pt, et, it, nt, st, b, T, S, _, w); } } } else G++, V === 1 ? W = (H.longest - H.lengths[G]) / 2 : V === 2 && (W = H.longest - H.lengths[G]), M = 0, P += z, C = null; l && (h.flush(), t.popScissor()); } }; }, function (t, e, i) { let n = i(1); let s = i(1); n = i(833), s = i(832), t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e) { t.exports = function (t, e, i, n, s) { const r = e.list; if (r.length !== 0) { const o = e.localTransform; s ? (o.loadIdentity(), o.multiply(s), o.translate(e.x, e.y), o.rotate(e.rotation), o.scale(e.scaleX, e.scaleY)) : o.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY); const a = e.blendMode !== -1; a || t.setBlendMode(0); for (let h = e._alpha, l = e.scrollFactorX, u = e.scrollFactorY, c = 0; c < r.length; c++) { const d = r[c]; if (d.willRender(n)) { const f = d._alpha; const p = d._blendMode; const g = d.scrollFactorX; const v = d.scrollFactorY; d.setScrollFactor(g * l, v * u), d.setAlpha(f * h), a && d.setBlendMode(e._blendMode), d.renderCanvas(t, d, i, n, o), d.setAlpha(f), d.setScrollFactor(g, v), d.setBlendMode(p); } } } }; }, function (t, e) { t.exports = function (t, e, i, n, s) { const r = e.list; if (r.length !== 0) { const o = e.localTransform; s ? (o.loadIdentity(), o.multiply(s), o.translate(e.x, e.y), o.rotate(e.rotation), o.scale(e.scaleX, e.scaleY)) : o.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY); const a = e.blendMode !== -1; a || t.setBlendMode(0); for (let h = e._alpha, l = e.scrollFactorX, u = e.scrollFactorY, c = 0; c < r.length; c++) { const d = r[c]; if (d.willRender(n)) { const f = d._alpha; const p = d.scrollFactorX; const g = d.scrollFactorY; a || d.blendMode === t.currentBlendMode || t.setBlendMode(d.blendMode), d.setScrollFactor(p * l, g * u), d.setAlpha(f * h), d.renderWebGL(t, d, i, n, o), d.setAlpha(f), d.setScrollFactor(p, g); } } } }; }, function (t, e, i) { let n = i(1); let s = i(1); n = i(836), s = i(835), t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e, i) {
  const n = new (i(0))({
    initialize(t, e, i, n, s) { this.parent = t, this.x = e, this.y = i, this.frame = n, this.data = {}, this._visible = s, this._alpha = 1, this.flipX = !1, this.flipY = !1; }, setFrame(t) { return this.frame = void 0 === t ? this.parent.frame : this.parent.texture.get(t), this; }, resetFlip() { return this.flipX = !1, this.flipY = !1, this; }, reset(t, e, i) { return this.x = t, this.y = e, this.flipX = !1, this.flipY = !1, this._alpha = 1, this._visible = !0, this.parent.dirty = !0, i && this.setFrame(i), this; }, setFlipX(t) { return this.flipX = t, this; }, setFlipY(t) { return this.flipY = t, this; }, setFlip(t, e) { return this.flipX = t, this.flipY = e, this; }, setVisible(t) { return this.visible = t, this; }, setAlpha(t) { return this.alpha = t, this; }, destroy() { this.parent.dirty = !0, this.parent.children.remove(this), this.parent = void 0, this.frame = void 0, this.data = void 0; }, visible: { get() { return this._visible; }, set(t) { this._visible = t, this.parent.dirty = !0; } }, alpha: { get() { return this._alpha; }, set(t) { this._alpha = t, this.parent.dirty = !0; } },
  }); t.exports = n;
}, function (t, e) { t.exports = function (t, e, i, n, s) { const r = e.getRenderList(); if (r.length !== 0) { const o = t.currentContext; const a = n.alpha * e.alpha; if (a !== 0) { o.globalCompositeOperation = t.blendModes[e.blendMode]; const h = e.x - n.scrollX * e.scrollFactorX; const l = e.y - n.scrollY * e.scrollFactorY; o.save(), s && s.copyToContext(o); for (let u = n.roundPixels, c = 0; c < r.length; c++) { const d = r[c]; const f = d.flipX || d.flipY; const p = d.frame; const g = p.canvasData; let v = p.x; let { y } = p; let m = 1; let x = 1; const w = d.alpha * a; w !== 0 && (o.globalAlpha = w, f ? (d.flipX && (m = -1, v -= g.width), d.flipY && (x = -1, y -= g.height), o.save(), o.translate(d.x + h, d.y + l), o.scale(m, x), o.drawImage(p.source.image, g.x, g.y, g.width, g.height, v, y, g.width, g.height), o.restore()) : (u && (v |= 0, y |= 0), o.drawImage(p.source.image, g.x, g.y, g.width, g.height, v + d.x + h, y + d.y + l, g.width, g.height))); }o.restore(); } } }; }, function (t, e, i) { const n = i(10); t.exports = function (t, e, i, s, r) { const o = e.getRenderList(); if (o.length !== 0) { const a = this.pipeline; t.setPipeline(a, e); let h = s.scrollX * e.scrollFactorX; let l = s.scrollY * e.scrollFactorY; const u = a._tempMatrix1; u.copyFrom(s.matrix), r && (u.multiplyWithOffset(r, -h, -l), h = 0, l = 0); for (let c = e.x - h, d = e.y - l, f = -1, p = s.alpha * e.alpha, g = s.roundPixels, v = 0; v < o.length; v++) { const y = o[v]; const m = y.frame; const x = y.alpha * p; if (x !== 0) { let w = m.width; let b = m.height; let T = c + y.x + m.x; let S = d + y.y + m.y; y.flipX && (w *= -1, T += m.width), y.flipY && (b *= -1, S += m.height); const _ = T + w; const A = S + b; let C = u.getX(T, S); let M = u.getY(T, S); let P = u.getX(_, A); let E = u.getY(_, A); const k = n.getTintAppendFloatAlpha(16777215, x); m.sourceIndex !== f && (a.setTexture2D(m.glTexture, 0), f = m.sourceIndex), g && (C |= 0, M |= 0, P |= 0, E |= 0), a.batchQuad(C, M, C, E, P, E, P, M, m.u0, m.v0, m.u1, m.v1, k, k, k, k, !1) && (f = -1); } } } }; }, function (t, e, i) { let n = i(1); let s = i(1); n = i(840), s = i(839), t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e, i) { const n = i(22); t.exports = function (t, e, i, s, r) { const o = e._text; const a = o.length; const h = t.currentContext; if (a !== 0 && n(t, h, e, s, r)) { const l = e.frame; const u = e.fontData.chars; const c = e.fontData.lineHeight; const d = e._letterSpacing; let f = 0; let p = 0; let g = 0; let v = null; let y = 0; let m = 0; let x = 0; let w = 0; let b = 0; let T = 0; let S = null; let _ = 0; const A = e.frame.source.image; const C = l.cutX; const M = l.cutY; const P = e._fontSize / e.fontData.size; const E = e._align; let k = 0; let L = 0; e.getTextBounds(!1); const F = e._bounds.lines; E === 1 ? L = (F.longest - F.lengths[0]) / 2 : E === 2 && (L = F.longest - F.lengths[0]), h.translate(-e.displayOriginX, -e.displayOriginY); for (let R = s.roundPixels, O = 0; O < a; O++) if ((g = o.charCodeAt(O)) !== 10) { if (v = u[g]) { if (y = C + v.x, m = M + v.y, x = v.width, w = v.height, b = v.xOffset + f, T = v.yOffset + p, S !== null) { const D = v.kerning[_]; b += void 0 !== D ? D : 0; }b *= P, T *= P, b += L, f += v.xAdvance + d, S = v, _ = g, x !== 0 && w !== 0 && g !== 32 && (R && (b |= 0, T |= 0), h.save(), h.translate(b, T), h.scale(P, P), h.drawImage(A, y, m, x, w, 0, 0, x, w), h.restore()); } } else k++, E === 1 ? L = (F.longest - F.lengths[k]) / 2 : E === 2 && (L = F.longest - F.lengths[k]), f = 0, p += c, S = null; h.restore(); } }; }, function (t, e, i) { const n = i(10); t.exports = function (t, e, i, s, r) { const o = e._text; const a = o.length; if (a !== 0) { const h = this.pipeline; t.setPipeline(h, e); const l = h._tempMatrix1; const u = h._tempMatrix2; const c = h._tempMatrix3; u.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), l.copyFrom(s.matrix), r ? (l.multiplyWithOffset(r, -s.scrollX * e.scrollFactorX, -s.scrollY * e.scrollFactorY), u.e = e.x, u.f = e.y, l.multiply(u, c)) : (u.e -= s.scrollX * e.scrollFactorX, u.f -= s.scrollY * e.scrollFactorY, l.multiply(u, c)); const d = e.frame; const f = d.glTexture; const p = d.cutX; const g = d.cutY; const v = f.width; const y = f.height; const m = e._isTinted && e.tintFill; const x = n.getTintAppendFloatAlpha(e._tintTL, s.alpha * e._alphaTL); const w = n.getTintAppendFloatAlpha(e._tintTR, s.alpha * e._alphaTR); const b = n.getTintAppendFloatAlpha(e._tintBL, s.alpha * e._alphaBL); const T = n.getTintAppendFloatAlpha(e._tintBR, s.alpha * e._alphaBR); h.setTexture2D(f, 0); let S; let _; let A = 0; let C = 0; let M = 0; let P = 0; const E = e._letterSpacing; let k = 0; let L = 0; let F = 0; let R = 0; const O = e.fontData; const D = O.chars; const B = O.lineHeight; const I = e._fontSize / O.size; const Y = e._align; let X = 0; let z = 0; e.getTextBounds(!1); const N = e._bounds.lines; Y === 1 ? z = (N.longest - N.lengths[0]) / 2 : Y === 2 && (z = N.longest - N.lengths[0]); for (let U = s.roundPixels, V = 0; V < a; V++) if ((M = o.charCodeAt(V)) !== 10) { if (S = D[M]) { k = p + S.x, L = g + S.y, F = S.width, R = S.height; let G = S.xOffset + A; let W = S.yOffset + C; if (_ !== null) { const H = S.kerning[P]; G += void 0 !== H ? H : 0; } if (A += S.xAdvance + E, _ = S, P = M, F !== 0 && R !== 0 && M !== 32) { G *= I, W *= I, G -= e.displayOriginX, W -= e.displayOriginY; const j = k / v; const q = L / y; const K = (k + F) / v; const J = (L + R) / y; const Z = (G += z) + F * I; const Q = W + R * I; let $ = c.getX(G, W); let tt = c.getY(G, W); let et = c.getX(G, Q); let it = c.getY(G, Q); let nt = c.getX(Z, Q); let st = c.getY(Z, Q); let rt = c.getX(Z, W); let ot = c.getY(Z, W); U && ($ |= 0, tt |= 0, et |= 0, it |= 0, nt |= 0, st |= 0, rt |= 0, ot |= 0), h.batchQuad($, tt, et, it, nt, st, rt, ot, j, q, K, J, x, w, b, T, m); } } } else X++, Y === 1 ? z = (N.longest - N.lengths[X]) / 2 : Y === 2 && (z = N.longest - N.lengths[X]), A = 0, C += B, _ = null; } }; }, function (t, e, i) { let n = i(1); let s = i(1); n = i(843), s = i(842), t.exports = { renderWebGL: n, renderCanvas: s }; }, function (t, e, i) { const n = i(310); t.exports = function (t, e, i, s, r, o, a) { const h = t.sys.textures.getFrame(i, s); const l = t.sys.cache.xml.get(r); if (h && l) { const u = n(l, o, a, h); return t.sys.cache.bitmapFont.add(e, { data: u, texture: i, frame: s }), !0; } return !1; }; }, function (t, e) {
  t.exports = function (t, e, i) {
    void 0 === i && (i = {
      local: {
        x: 0, y: 0, width: 0, height: 0,
      },
      global: {
        x: 0, y: 0, width: 0, height: 0,
      },
      lines: { shortest: 0, longest: 0, lengths: null },
    }); for (var n = t.text, s = n.length, r = Number.MAX_VALUE, o = Number.MAX_VALUE, a = 0, h = 0, l = t.fontData.chars, u = t.fontData.lineHeight, c = t.letterSpacing, d = 0, f = 0, p = 0, g = null, v = 0, y = 0, m = t.fontSize / t.fontData.size, x = m * t.scaleX, w = m * t.scaleY, b = null, T = 0, S = [], _ = Number.MAX_VALUE, A = 0, C = 0, M = 0, P = 0; P < s; P++) if ((p = n.charCodeAt(P)) !== 10) { if (g = l[p]) { if (v = d, y = f, b !== null) { const E = g.kerning[T]; v += void 0 !== E ? E : 0; }r > v && (r = v), o > y && (o = y); const k = v + g.xAdvance; const L = y + u; a < k && (a = k), h < L && (h = L), d += g.xAdvance + c, b = g, T = p, M = k * m; } } else d = 0, f += u, b = null, S[C] = M, M > A && (A = M), M < _ && (_ = M), C++, M = 0; S[C] = M, M > A && (A = M), M < _ && (_ = M); const F = i.local; const R = i.global; const O = i.lines; return F.x = r * m, F.y = o * m, F.width = a * m, F.height = h * m, R.x = t.x - t.displayOriginX + r * x, R.y = t.y - t.displayOriginY + o * w, R.width = a * x, R.height = h * w, O.shortest = _, O.longest = A, O.lengths = S, e && (F.x = Math.round(F.x), F.y = Math.round(F.y), F.width = Math.round(F.width), F.height = Math.round(F.height), R.x = Math.round(R.x), R.y = Math.round(R.y), R.width = Math.round(R.width), R.height = Math.round(R.height), O.shortest = Math.round(_), O.longest = Math.round(A)), i;
  };
}, function (t, e, i) {
  const n = i(0); const s = i(15); const r = new n({
    initialize(t) { this.scene = t, this.systems = t.sys, this._list = [], this._pendingInsertion = [], this._pendingRemoval = [], t.sys.events.once('boot', this.boot, this), t.sys.events.on('start', this.start, this); }, boot() { this.systems.events.once('destroy', this.destroy, this); }, start() { const t = this.systems.events; t.on('preupdate', this.preUpdate, this), t.on('update', this.update, this), t.once('shutdown', this.shutdown, this); }, add(t) { return this._list.indexOf(t) === -1 && this._pendingInsertion.indexOf(t) === -1 && this._pendingInsertion.push(t), t; }, preUpdate() { const t = this._pendingRemoval.length; const e = this._pendingInsertion.length; if (t !== 0 || e !== 0) { let i; let n; for (i = 0; i < t; i++) { n = this._pendingRemoval[i]; const s = this._list.indexOf(n); s > -1 && this._list.splice(s, 1); } this._list = this._list.concat(this._pendingInsertion.splice(0)), this._pendingRemoval.length = 0, this._pendingInsertion.length = 0; } }, update(t, e) { for (let i = 0; i < this._list.length; i++) { const n = this._list[i]; n.active && n.preUpdate.call(n, t, e); } }, remove(t) { const e = this._list.indexOf(t); return e !== -1 && this._list.splice(e, 1), t; }, removeAll() { for (let t = this._list.length; t--;) this.remove(this._list[t]); return this; }, shutdown() { for (var t = this._list.length; t--;) this._list[t].destroy(!0); for (t = this._pendingRemoval.length; t--;) this._pendingRemoval[t].destroy(!0); for (t = this._pendingInsertion.length; t--;) this._pendingInsertion[t].destroy(!0); this._list.length = 0, this._pendingRemoval.length = 0, this._pendingInsertion.length = 0; const e = this.systems.events; e.off('preupdate', this.preUpdate, this), e.off('update', this.update, this), e.off('shutdown', this.shutdown, this); }, destroy() { this.shutdown(), this.scene.sys.events.off('start', this.start, this), this.scene = null, this.systems = null; }, length: { get() { return this._list.length; } },
  }); s.register('UpdateList', r, 'updateList'), t.exports = r;
}, function (t, e) { t.exports = function (t, e, i) { if (e !== i) { const n = t.indexOf(e); const s = t.indexOf(i); if (n < 0 || s < 0) throw new Error('Supplied items must be elements of the same array'); return t[n] = i, t[s] = e, t; } }; }, function (t, e, i) { const n = i(62); t.exports = function (t, e, i, s, r) { if (void 0 === s && (s = 0), void 0 === r && (r = t.length), n(t, s, r)) for (let o = s; o < r; o++) { const a = t[o]; a.hasOwnProperty(e) && (a[e] = i); } return t; }; }, function (t, e) { t.exports = function (t, e) { const i = t.indexOf(e); return i !== -1 && i > 0 && (t.splice(i, 1), t.unshift(e)), e; }; }, function (t, e) { t.exports = function (t, e, i) { const n = t.indexOf(e); const s = t.indexOf(i); return n !== -1 && s === -1 && (t[n] = i, !0); }; }, function (t, e, i) { const n = i(91); t.exports = function (t, e, i) { void 0 === e && (e = 0), void 0 === i && (i = t.length); const s = e + Math.floor(Math.random() * i); return n(t, s); }; }, function (t, e, i) { const n = i(62); t.exports = function (t, e, i, s, r) { if (void 0 === e && (e = 0), void 0 === i && (i = t.length), void 0 === r && (r = t), n(t, e, i)) { const o = i - e; const a = t.splice(e, o); if (s) for (let h = 0; h < a.length; h++) { const l = a[h]; s.call(r, l); } return a; } return []; }; }, function (t, e, i) { const n = i(91); t.exports = function (t, e, i, s) { if (void 0 === s && (s = t), e < 0 || e > t.length - 1) throw new Error('Index out of bounds'); const r = n(t, e); return i && i.call(s, r), r; }; }, function (t, e, i) { const n = i(314); t.exports = function (t, e, i) { void 0 === t && (t = 0), void 0 === e && (e = null), void 0 === i && (i = 1), e === null && (e = t, t = 0); for (var s = [], r = Math.max(n((e - t) / (i || 1)), 0), o = 0; o < r; o++)s.push(t), t += i; return s; }; }, function (t, e) { t.exports = function (t, e, i, n) { for (var s = [], r = t; r <= e; r++) if (i || n) { let o = i ? i + r.toString() : r.toString(); n && (o = o.concat(n)), s.push(o); } else s.push(r); return s; }; }, function (t, e) { t.exports = function (t, e) { const i = t.indexOf(e); if (i !== -1 && i < t.length - 2) { const n = t[i + 1]; const s = t.indexOf(n); t[i] = n, t[s] = e; } return t; }; }, function (t, e) { t.exports = function (t, e, i) { const n = t.indexOf(e); if (n === -1 || i < 0 || i >= t.length) throw new Error('Supplied index out of bounds'); return n !== i && (t.splice(n, 1), t.splice(i, 0, e)), e; }; }, function (t, e) { t.exports = function (t, e) { const i = t.indexOf(e); if (i > 0) { const n = t[i - 1]; const s = t.indexOf(n); t[i] = n, t[s] = e; } return t; }; }, function (t, e, i) { const n = i(62); t.exports = function (t, e, i, s, r) { if (void 0 === s && (s = 0), void 0 === r && (r = t.length), n(t, s, r)) for (let o = s; o < r; o++) { const a = t[o]; if (!e || e && void 0 === i && a.hasOwnProperty(e) || e && void 0 !== i && a[e] === i) return a; } return null; }; }, function (t, e, i) { const n = i(62); t.exports = function (t, e, i, s, r) { void 0 === s && (s = 0), void 0 === r && (r = t.length); const o = []; if (n(t, s, r)) for (let a = s; a < r; a++) { const h = t[a]; (!e || e && void 0 === i && h.hasOwnProperty(e) || e && void 0 !== i && h[e] === i) && o.push(h); } return o; }; }, function (t, e, i) { const n = i(62); t.exports = function (t, e, i, s, r) { if (void 0 === s && (s = 0), void 0 === r && (r = t.length), n(t, s, r)) { let o; const a = [null]; for (o = 5; o < arguments.length; o++)a.push(arguments[o]); for (o = s; o < r; o++)a[0] = t[o], e.apply(i, a); } return t; }; }, function (t, e) { t.exports = function (t, e, i) { let n; const s = [null]; for (n = 3; n < arguments.length; n++)s.push(arguments[n]); for (n = 0; n < t.length; n++)s[0] = t[n], e.apply(i, s); return t; }; }, function (t, e, i) { const n = i(62); t.exports = function (t, e, i, s, r) { void 0 === s && (s = 0), void 0 === r && (r = t.length); let o = 0; if (n(t, s, r)) for (let a = s; a < r; a++)t[a][e] === i && o++; return o; }; }, function (t, e) { t.exports = function (t, e) { const i = t.indexOf(e); return i !== -1 && i < t.length && (t.splice(i, 1), t.push(e)), e; }; }, function (t, e) { t.exports = function (t, e, i, n, s, r) { if (void 0 === i && (i = 0), void 0 === r && (r = t), n > 0) { var o = n - t.length; if (o <= 0) return null; } if (!Array.isArray(e)) return t.indexOf(e) === -1 ? (t.splice(i, 0, e), s && s.call(r, e), e) : null; for (var a = e.length - 1; a >= 0;)t.indexOf(e[a]) !== -1 && e.pop(), a--; if ((a = e.length) === 0) return null; n > 0 && a > o && (e.splice(o), a = o); for (let h = a - 1; h >= 0; h--) { const l = e[h]; t.splice(i, 0, l), s && s.call(r, l); } return e; }; }, function (t, e) { t.exports = function (t, e, i, n, s) { if (void 0 === s && (s = t), i > 0) { var r = i - t.length; if (r <= 0) return null; } if (!Array.isArray(e)) return t.indexOf(e) === -1 ? (t.push(e), n && n.call(s, e), e) : null; for (var o = e.length - 1; o >= 0;)t.indexOf(e[o]) !== -1 && e.pop(), o--; if ((o = e.length) === 0) return null; i > 0 && o > r && (e.splice(r), o = r); for (let a = 0; a < o; a++) { const h = e[a]; t.push(h), n && n.call(s, h); } return e; }; }, function (t, e, i) { const n = i(111); t.exports = function (t) { return n(t, -90); }; }, function (t, e, i) { const n = i(111); t.exports = function (t) { return n(t, 90); }; }, function (t, e, i) { const n = i(111); t.exports = function (t) { return n(t, 180); }; }, function (t, e) { t.exports = function (t) { return t.reverse(); }; }, function (t, e) { t.exports = function (t) { for (let e = 0; e < t.length; e++)t[e].reverse(); return t; }; }, function (t, e, i) { const n = i(179); const s = i(163); t.exports = function (t) { let e = ''; if (!s(t)) return e; for (let i = 0; i < t.length; i++) { for (let r = 0; r < t[i].length; r++) { const o = t[i][r].toString(); e += o !== 'undefined' ? n(o, 2) : '?', r < t[i].length - 1 && (e += ' |'); } if (i < t.length - 1) { e += '\n'; for (let a = 0; a < t[i].length; a++)e += '---', a < t[i].length - 1 && (e += '+'); e += '\n'; } } return e; }; }, function (t, e, i) {
  t.exports = {
    CheckMatrix: i(163), MatrixToString: i(873), ReverseColumns: i(872), ReverseRows: i(871), Rotate180: i(870), RotateLeft: i(869), RotateMatrix: i(111), RotateRight: i(868), TransposeMatrix: i(315),
  };
}, function (t, e, i) {
  const n = i(0); const s = i(112); const r = i(15); const o = i(110); const a = new n({
    Extends: s, initialize(t) { s.call(this, t), this.sortChildrenFlag = !1, this.scene = t, this.systems = t.sys, t.sys.events.once('boot', this.boot, this), t.sys.events.on('start', this.start, this); }, boot() { this.systems.events.once('destroy', this.destroy, this); }, start() { this.systems.events.once('shutdown', this.shutdown, this); }, queueDepthSort() { this.sortChildrenFlag = !0; }, depthSort() { this.sortChildrenFlag && (o.inplace(this.list, this.sortByDepth), this.sortChildrenFlag = !1); }, sortByDepth(t, e) { return t._depth - e._depth; }, sortGameObjects(t) { return void 0 === t && (t = this.list), this.scene.sys.depthSort(), t.sort(this.sortIndexHandler.bind(this)); }, getTopGameObject(t) { return this.sortGameObjects(t), t[t.length - 1]; }, getChildren() { return this.list; }, shutdown() { for (let t = this.list.length; t--;) this.list[t].destroy(!0); this.list.length = 0, this.systems.events.off('shutdown', this.shutdown, this); }, destroy() { this.shutdown(), this.scene.sys.events.off('start', this.start, this), this.scene = null, this.systems = null; },
  }); r.register('DisplayList', a, 'displayList'), t.exports = a;
}, function (t, e, i) {
  const n = {
    DisplayList: i(875),
    GameObjectCreator: i(13),
    GameObjectFactory: i(5),
    UpdateList: i(847),
    Components: i(14),
    BuildGameObject: i(28),
    BuildGameObjectAnimation: i(311),
    GameObject: i(19),
    BitmapText: i(109),
    Blitter: i(161),
    Container: i(160),
    DynamicBitmapText: i(159),
    Graphics: i(158),
    Group: i(88),
    Image: i(87),
    Particles: i(823),
    PathFollower: i(296),
    RenderTexture: i(154),
    RetroFont: i(814),
    Sprite: i(61),
    Text: i(153),
    TileSprite: i(152),
    Zone: i(125),
    Shape: i(27),
    Arc: i(293),
    Curve: i(292),
    Ellipse: i(291),
    Grid: i(290),
    IsoBox: i(289),
    IsoTriangle: i(288),
    Line: i(287),
    Polygon: i(286),
    Rectangle: i(281),
    Star: i(280),
    Triangle: i(279),
    Factories: {
      Blitter: i(769), Container: i(768), DynamicBitmapText: i(767), Graphics: i(766), Group: i(765), Image: i(764), Particles: i(763), PathFollower: i(762), RenderTexture: i(761), Sprite: i(760), StaticBitmapText: i(759), Text: i(758), TileSprite: i(757), Zone: i(756), Arc: i(755), Curve: i(754), Ellipse: i(753), Grid: i(752), IsoBox: i(751), IsoTriangle: i(750), Line: i(749), Polygon: i(748), Rectangle: i(747), Star: i(746), Triangle: i(745),
    },
    Creators: {
      Blitter: i(744), Container: i(743), DynamicBitmapText: i(742), Graphics: i(741), Group: i(740), Image: i(739), Particles: i(738), RenderTexture: i(737), Sprite: i(736), StaticBitmapText: i(735), Text: i(734), TileSprite: i(733), Zone: i(732),
    },
  }; n.Mesh = i(108), n.Quad = i(149), n.Factories.Mesh = i(728), n.Factories.Quad = i(727), n.Creators.Mesh = i(726), n.Creators.Quad = i(725), n.Light = i(276), i(275), i(724), t.exports = n;
}, function (t, e) { t.exports = function (t) { let e; const i = t.events; void 0 !== document.hidden ? e = 'visibilitychange' : ['webkit', 'moz', 'ms'].forEach((t) => { void 0 !== document[`${t}Hidden`] && (document.hidden = function () { return document[`${t}Hidden`]; }, e = `${t}visibilitychange`); }); e && document.addEventListener(e, (t) => { document.hidden || t.type === 'pause' ? i.emit('hidden') : i.emit('visible'); }, !1), window.onblur = function () { i.emit('blur'); }, window.onfocus = function () { i.emit('focus'); }, window.focus && t.config.autoFocus && (window.focus(), t.canvas.addEventListener('mousedown', () => { window.focus(); }, { passive: !0 })), t.canvas && (t.canvas.onmouseout = function () { t.isOver = !1, i.emit('mouseout'); }, t.canvas.onmouseover = function () { t.isOver = !0, i.emit('mouseover'); }); }; }, function (t, e, i) {
  const n = i(0); const s = i(4); const r = i(1); const o = i(341); const a = new n({
    initialize(t, e) { this.game = t, this.raf = new o(), this.started = !1, this.running = !1, this.minFps = s(e, 'min', 5), this.targetFps = s(e, 'target', 60), this._min = 1e3 / this.minFps, this._target = 1e3 / this.targetFps, this.actualFps = this.targetFps, this.nextFpsUpdate = 0, this.framesThisSecond = 0, this.callback = r, this.forceSetTimeOut = s(e, 'forceSetTimeOut', !1), this.time = 0, this.startTime = 0, this.lastTime = 0, this.frame = 0, this.inFocus = !0, this._pauseTime = 0, this._coolDown = 0, this.delta = 0, this.deltaIndex = 0, this.deltaHistory = [], this.deltaSmoothingMax = s(e, 'deltaHistory', 10), this.panicMax = s(e, 'panicMax', 120), this.rawDelta = 0; }, blur() { this.inFocus = !1; }, focus() { this.inFocus = !0, this.resetDelta(); }, pause() { this._pauseTime = window.performance.now(); }, resume() { this.resetDelta(), this.startTime += this.time - this._pauseTime; }, resetDelta() { const t = window.performance.now(); this.time = t, this.lastTime = t, this.nextFpsUpdate = t + 1e3, this.framesThisSecond = 0, this.frame = 0; for (let e = 0; e < this.deltaSmoothingMax; e++) this.deltaHistory[e] = Math.min(this._target, this.deltaHistory[e]); this.delta = 0, this.deltaIndex = 0, this._coolDown = this.panicMax; }, start(t) { if (this.started) return this; this.started = !0, this.running = !0; for (let e = 0; e < this.deltaSmoothingMax; e++) this.deltaHistory[e] = this._target; this.resetDelta(), this.startTime = window.performance.now(), this.callback = t, this.raf.start(this.step.bind(this), this.forceSetTimeOut); }, step(t) { this.frame++; let e = t - this.lastTime; e < 0 && (e = 0), this.rawDelta = e; const i = this.deltaIndex; const n = this.deltaHistory; const s = this.deltaSmoothingMax; let r = e; (this._coolDown > 0 || !this.inFocus) && (this._coolDown--, r = Math.min(r, this._target)), r > this._min && (r = n[i], r = Math.min(r, this._min)), n[i] = r, this.deltaIndex++, this.deltaIndex > s && (this.deltaIndex = 0); for (var o = 0, a = 0; a < s; a++)o += n[a]; o /= s, this.delta = o, this.time += this.rawDelta, t > this.nextFpsUpdate && (this.actualFps = 0.25 * this.framesThisSecond + 0.75 * this.actualFps, this.nextFpsUpdate = t + 1e3, this.framesThisSecond = 0), this.framesThisSecond++; const h = o / this._target; this.callback(t, o, h), this.lastTime = t; }, tick() { this.step(window.performance.now()); }, sleep() { this.running && (this.raf.stop(), this.running = !1); }, wake(t) { this.running ? this.sleep() : t && (this.startTime += -this.lastTime + (this.lastTime = window.performance.now())), this.raf.start(this.step.bind(this), this.useRAF), this.running = !0, this.step(window.performance.now()); }, stop() { return this.running = !1, this.started = !1, this.raf.stop(), this; }, destroy() { this.stop(), this.callback = r, this.raf = null, this.game = null; },
  }); t.exports = a;
}, function (t, e) {
  let i = 0; const n = function (t, e, n, s) { const r = i - s.y - s.height; t.add(n, e, s.x, r, s.width, s.height); }; t.exports = function (t, e, s) {
    const r = t.source[e]; t.add('__BASE', e, 0, 0, r.width, r.height), i = r.height; for (var o = s.split('\n'), a = /^[ ]*(- )*(\w+)+[: ]+(.*)/, h = '', l = '', u = {
        x: 0, y: 0, width: 0, height: 0,
      }, c = 0; c < o.length; c++) {
      const d = o[c].match(a); if (d) {
        const f = d[1] === '- '; const p = d[2]; const g = d[3]; if (f && (l !== h && (n(t, e, l, u), h = l), u = {
          x: 0, y: 0, width: 0, height: 0,
        }), p !== 'name') switch (p) { case 'x': case 'y': case 'width': case 'height': u[p] = parseInt(g, 10); } else l = g;
      }
    } return l !== h && n(t, e, l, u), t;
  };
}, function (t, e, i) { const n = i(2); t.exports = function (t, e, i) { const s = n(i, 'frameWidth', null); const r = n(i, 'frameHeight', s); if (!s) throw new Error('TextureManager.SpriteSheetFromAtlas: Invalid frameWidth given.'); let o; let a = n(i, 'startFrame', 0); const h = n(i, 'endFrame', -1); const l = n(i, 'margin', 0); const u = n(i, 'spacing', 0); const c = e.cutX; const d = e.cutY; const f = e.cutWidth; const p = e.cutHeight; const g = e.realWidth; const v = e.realHeight; const y = Math.floor((g - l + u) / (s + u)); const m = Math.floor((v - l + u) / (r + u)); let x = y * m; const w = e.x; const b = s - w; const T = s - (g - f - w); const S = e.y; const _ = r - S; const A = r - (v - p - S); (a > x || a < -x) && (a = 0), a < 0 && (a = x + a), h !== -1 && (x = a + (h + 1)); for (let C = l, M = l, P = 0, E = e.sourceIndex, k = 0; k < m; k++) { for (var L = k === 0, F = k === m - 1, R = 0; R < y; R++) { const O = R === 0; const D = R === y - 1; if (o = t.add(P, E, c + C, d + M, s, r), O || L || D || F) { const B = O ? w : 0; const I = L ? S : 0; let Y = s; let X = r; O ? Y = b : D && (Y = T), L ? X = _ : F && (X = A), o.cutWidth = Y, o.cutHeight = X, o.setTrim(s, r, B, I, Y, X); }C += u, C += O ? b : D || s, P++; }C = l, M += u, M += L ? _ : F ? A : r; } return t; }; }, function (t, e, i) { const n = i(2); t.exports = function (t, e, i, s, r, o, a) { const h = n(a, 'frameWidth', null); const l = n(a, 'frameHeight', h); if (h === null) throw new Error('TextureManager.SpriteSheet: Invalid frameWidth given.'); const u = t.source[e]; t.add('__BASE', e, 0, 0, u.width, u.height); let c = n(a, 'startFrame', 0); const d = n(a, 'endFrame', -1); const f = n(a, 'margin', 0); const p = n(a, 'spacing', 0); let g = Math.floor((r - f + p) / (h + p)) * Math.floor((o - f + p) / (l + p)); g === 0 && console.warn('SpriteSheet frame dimensions will result in zero frames.'), (c > g || c < -g) && (c = 0), c < 0 && (c = g + c), d !== -1 && (g = c + (d + 1)); for (let v = f, y = f, m = 0, x = 0, w = 0; w < g; w++) { m = 0, x = 0; const b = v + h; const T = y + l; b > r && (m = b - r), T > o && (x = T - o), t.add(w, e, i + v, s + y, h - m, l - x), (v += h + p) + h > r && (v = f, y += l + p); } return t; }; }, function (t, e, i) { const n = i(63); t.exports = function (t, e, i) { if (i.frames) { const s = t.source[e]; t.add('__BASE', e, 0, 0, s.width, s.height); let r; const o = i.frames; for (const a in o) { const h = o[a]; r = t.add(a, e, h.frame.x, h.frame.y, h.frame.w, h.frame.h), h.trimmed && r.setTrim(h.sourceSize.w, h.sourceSize.h, h.spriteSourceSize.x, h.spriteSourceSize.y, h.spriteSourceSize.w, h.spriteSourceSize.h), h.rotated && (r.rotated = !0, r.updateUVsInverted()), r.customData = n(h); } for (const l in i)l !== 'frames' && (Array.isArray(i[l]) ? t.customData[l] = i[l].slice(0) : t.customData[l] = i[l]); return t; }console.warn("Invalid Texture Atlas JSON Hash given, missing 'frames' Object"); }; }, function (t, e, i) { const n = i(63); t.exports = function (t, e, i) { if (i.frames || i.textures) { const s = t.source[e]; t.add('__BASE', e, 0, 0, s.width, s.height); for (var r, o = Array.isArray(i.textures) ? i.textures[e].frames : i.frames, a = 0; a < o.length; a++) { const h = o[a]; r = t.add(h.filename, e, h.frame.x, h.frame.y, h.frame.w, h.frame.h), h.trimmed && r.setTrim(h.sourceSize.w, h.sourceSize.h, h.spriteSourceSize.x, h.spriteSourceSize.y, h.spriteSourceSize.w, h.spriteSourceSize.h), h.rotated && (r.rotated = !0, r.updateUVsInverted()), h.anchor && (r.customPivot = !0, r.pivotX = h.anchor.x, r.pivotY = h.anchor.y), r.customData = n(h); } for (const l in i)l !== 'frames' && (Array.isArray(i[l]) ? t.customData[l] = i[l].slice(0) : t.customData[l] = i[l]); return t; }console.warn('Invalid Texture Atlas JSON Array'); }; }, function (t, e) { t.exports = function (t, e) { const i = t.source[e]; return t.add('__BASE', e, 0, 0, i.width, i.height), t; }; }, function (t, e) { t.exports = function (t, e) { const i = t.source[e]; return t.add('__BASE', e, 0, 0, i.width, i.height), t; }; }, function (t, e) { t.exports = function (t, e, i) { if (i.getElementsByTagName('TextureAtlas')) { const n = t.source[e]; t.add('__BASE', e, 0, 0, n.width, n.height); for (var s, r = i.getElementsByTagName('SubTexture'), o = 0; o < r.length; o++) { const a = r[o].attributes; const h = a.name.value; const l = parseInt(a.x.value, 10); const u = parseInt(a.y.value, 10); const c = parseInt(a.width.value, 10); const d = parseInt(a.height.value, 10); if (s = t.add(h, e, l, u, c, d), a.frameX) { const f = Math.abs(parseInt(a.frameX.value, 10)); const p = Math.abs(parseInt(a.frameY.value, 10)); const g = parseInt(a.frameWidth.value, 10); const v = parseInt(a.frameHeight.value, 10); s.setTrim(c, d, f, p, g, v); } } return t; }console.warn('Invalid Texture Atlas XML given'); }; }, function (t, e, i) {
  const n = i(0); const s = i(37); const r = i(117); const o = i(165); const a = new n({
    Extends: o, initialize(t, e, i, n, s) { o.call(this, t, e, i, n, s), this.add('__BASE', 0, 0, 0, n, s), this._source = this.frames.__BASE.source, this.canvas = this._source.image, this.context = this.canvas.getContext('2d'), this.width = n, this.height = s, this.imageData = this.context.getImageData(0, 0, n, s), this.data = null, this.imageData && (this.data = this.imageData.data), this.pixels = null, this.buffer, this.data && (this.imageData.data.buffer ? (this.buffer = this.imageData.data.buffer, this.pixels = new Uint32Array(this.buffer)) : window.ArrayBuffer ? (this.buffer = new ArrayBuffer(this.imageData.data.length), this.pixels = new Uint32Array(this.buffer)) : this.pixels = this.imageData.data); }, update() { return this.imageData = this.context.getImageData(0, 0, this.width, this.height), this.data = this.imageData.data, this.imageData.data.buffer ? (this.buffer = this.imageData.data.buffer, this.pixels = new Uint32Array(this.buffer)) : window.ArrayBuffer ? (this.buffer = new ArrayBuffer(this.imageData.data.length), this.pixels = new Uint32Array(this.buffer)) : this.pixels = this.imageData.data, this; }, draw(t, e, i) { return this.context.drawImage(i, t, e), this.update(); }, getPixel(t, e, i) { i || (i = new s()); let n = ~~(t + e * this.width); n *= 4; const r = this.data[n]; const o = this.data[++n]; const a = this.data[++n]; const h = this.data[++n]; return i.setTo(r, o, a, h); }, refresh() { return this._source.update(), this; }, getCanvas() { return this.canvas; }, getContext() { return this.context; }, clear() { return this.context.clearRect(0, 0, this.width, this.height), this.update(); }, setSize(t, e) { return void 0 === e && (e = t), t === this.width && e === this.height || (this.canvas.width = t, this.canvas.height = e, this._source.width = t, this._source.height = e, this._source.isPowerOf2 = r(t, e), this.frames.__BASE.setSize(t, e, 0, 0), this.refresh()), this; },
  }); t.exports = a;
}, function (t, e, i) {
  t.exports = {
    game: 'game', anims: 'anims', cache: 'cache', plugins: 'plugins', registry: 'registry', sound: 'sound', textures: 'textures', events: 'events', cameras: 'cameras', add: 'add', make: 'make', scenePlugin: 'scene', displayList: 'children', lights: 'lights', data: 'data', input: 'input', load: 'load', time: 'time', tweens: 'tweens', arcadePhysics: 'physics', impactPhysics: 'impact', matterPhysics: 'matter',
  };
}, function (t, e, i) { const n = i(2); t.exports = function (t) { const e = t.plugins.getDefaultScenePlugins(); const i = n(t.settings, 'plugins', !1); return Array.isArray(i) ? i : e || []; }; }, function (t, e, i) { const n = i(2); const s = i(327); t.exports = function (t) { const e = t.game.config.defaultPhysicsSystem; const i = n(t.settings, 'physics', !1); if (e || i) { const r = []; if (e && r.push(s(`${e}Physics`)), i) for (let o in i)o = s(o.concat('Physics')), r.indexOf(o) === -1 && r.push(o); return r; } }; }, function (t, e, i) { const n = i(26); t.exports = function (t) { const e = t.config; if (!e.hideBanner) { let i = 'WebGL'; e.renderType === n.CANVAS ? i = 'Canvas' : e.renderType === n.HEADLESS && (i = 'Headless'); let s; const r = e.audio; const o = t.device.audio; if (s = !o.webAudio || r && r.disableWebAudio ? r && r.noAudio || !o.webAudio && !o.audioData ? 'No Audio' : 'HTML5 Audio' : 'Web Audio', t.device.browser.ie)window.console && console.log(`Phaser v${n.VERSION} / https://phaser.io`); else { let a; let h = ''; const l = [h]; Array.isArray(e.bannerBackgroundColor) ? (e.bannerBackgroundColor.forEach((t) => { h = h.concat('%c '), l.push(`background: ${t}`), a = t; }), l[l.length - 1] = `color: ${e.bannerTextColor}; background: ${a}`) : (h = h.concat('%c '), l.push(`color: ${e.bannerTextColor}; background: ${e.bannerBackgroundColor}`)), l.push('background: #fff'), e.gameTitle && (h = h.concat(e.gameTitle), e.gameVersion && (h = h.concat(` v${e.gameVersion}`)), e.hidePhaser || (h = h.concat(' / '))), e.hidePhaser || (h = h.concat(`Phaser v${n.VERSION} (${i} | ${s})`)), h = h.concat(` %c ${e.gameURL}`), l[0] = h, console.log.apply(console, l); } } }; }, function (t, e) { t.exports = ['#define SHADER_NAME PHASER_TEXTURE_TINT_VS', '', 'precision mediump float;', '', 'uniform mat4 uProjectionMatrix;', 'uniform mat4 uViewMatrix;', 'uniform mat4 uModelMatrix;', '', 'attribute vec2 inPosition;', 'attribute vec2 inTexCoord;', 'attribute float inTintEffect;', 'attribute vec4 inTint;', '', 'varying vec2 outTexCoord;', 'varying float outTintEffect;', 'varying vec4 outTint;', '', 'void main ()', '{', '    gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(inPosition, 1.0, 1.0);', '', '    outTexCoord = inTexCoord;', '    outTint = inTint;', '    outTintEffect = inTintEffect;', '}', '', ''].join('\n'); }, function (t, e) { t.exports = ['#define SHADER_NAME PHASER_TEXTURE_TINT_FS', '', 'precision mediump float;', '', 'uniform sampler2D uMainSampler;', '', 'varying vec2 outTexCoord;', 'varying float outTintEffect;', 'varying vec4 outTint;', '', 'void main()', '{', '    vec4 texture = texture2D(uMainSampler, outTexCoord);', '    vec4 texel = vec4(outTint.rgb * outTint.a, outTint.a);', '    vec4 color = texture;', '', '    if (outTintEffect == 0.0)', '    {', '        //  Multiply texture tint', '        color = texture * texel;', '    }', '    else if (outTintEffect == 1.0)', '    {', '        //  Solid color + texture alpha', '        color.rgb = mix(texture.rgb, outTint.rgb * outTint.a, texture.a);', '        color.a = texture.a * texel.a;', '    }', '    else if (outTintEffect == 2.0)', '    {', '        //  Solid color, no texture', '        color = texel;', '    }', '', '    gl_FragColor = color;', '}', ''].join('\n'); }, function (t, e) {
  const i = {
    modelMatrixDirty: !1, viewMatrixDirty: !1, projectionMatrixDirty: !1, modelMatrix: null, viewMatrix: null, projectionMatrix: null, mvpInit() { return this.modelMatrixDirty = !0, this.viewMatrixDirty = !0, this.projectionMatrixDirty = !0, this.modelMatrix = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]), this.viewMatrix = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]), this.projectionMatrix = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]), this; }, mvpUpdate() { const t = this.program; return this.modelMatrixDirty && (this.renderer.setMatrix4(t, 'uModelMatrix', !1, this.modelMatrix), this.modelMatrixDirty = !1), this.viewMatrixDirty && (this.renderer.setMatrix4(t, 'uViewMatrix', !1, this.viewMatrix), this.viewMatrixDirty = !1), this.projectionMatrixDirty && (this.renderer.setMatrix4(t, 'uProjectionMatrix', !1, this.projectionMatrix), this.projectionMatrixDirty = !1), this; }, modelIdentity() { const t = this.modelMatrix; return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this.modelMatrixDirty = !0, this; }, modelScale(t, e, i) { const n = this.modelMatrix; return n[0] *= t, n[1] *= t, n[2] *= t, n[3] *= t, n[4] *= e, n[5] *= e, n[6] *= e, n[7] *= e, n[8] *= i, n[9] *= i, n[10] *= i, n[11] *= i, this.modelMatrixDirty = !0, this; }, modelTranslate(t, e, i) { const n = this.modelMatrix; return n[12] = n[0] * t + n[4] * e + n[8] * i + n[12], n[13] = n[1] * t + n[5] * e + n[9] * i + n[13], n[14] = n[2] * t + n[6] * e + n[10] * i + n[14], n[15] = n[3] * t + n[7] * e + n[11] * i + n[15], this.modelMatrixDirty = !0, this; }, modelRotateX(t) { const e = this.modelMatrix; const i = Math.sin(t); const n = Math.cos(t); const s = e[4]; const r = e[5]; const o = e[6]; const a = e[7]; const h = e[8]; const l = e[9]; const u = e[10]; const c = e[11]; return e[4] = s * n + h * i, e[5] = r * n + l * i, e[6] = o * n + u * i, e[7] = a * n + c * i, e[8] = h * n - s * i, e[9] = l * n - r * i, e[10] = u * n - o * i, e[11] = c * n - a * i, this.modelMatrixDirty = !0, this; }, modelRotateY(t) { const e = this.modelMatrix; const i = Math.sin(t); const n = Math.cos(t); const s = e[0]; const r = e[1]; const o = e[2]; const a = e[3]; const h = e[8]; const l = e[9]; const u = e[10]; const c = e[11]; return e[0] = s * n - h * i, e[1] = r * n - l * i, e[2] = o * n - u * i, e[3] = a * n - c * i, e[8] = s * i + h * n, e[9] = r * i + l * n, e[10] = o * i + u * n, e[11] = a * i + c * n, this.modelMatrixDirty = !0, this; }, modelRotateZ(t) { const e = this.modelMatrix; const i = Math.sin(t); const n = Math.cos(t); const s = e[0]; const r = e[1]; const o = e[2]; const a = e[3]; const h = e[4]; const l = e[5]; const u = e[6]; const c = e[7]; return e[0] = s * n + h * i, e[1] = r * n + l * i, e[2] = o * n + u * i, e[3] = a * n + c * i, e[4] = h * n - s * i, e[5] = l * n - r * i, e[6] = u * n - o * i, e[7] = c * n - a * i, this.modelMatrixDirty = !0, this; }, viewIdentity() { const t = this.viewMatrix; return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this.viewMatrixDirty = !0, this; }, viewScale(t, e, i) { const n = this.viewMatrix; return n[0] *= t, n[1] *= t, n[2] *= t, n[3] *= t, n[4] *= e, n[5] *= e, n[6] *= e, n[7] *= e, n[8] *= i, n[9] *= i, n[10] *= i, n[11] *= i, this.viewMatrixDirty = !0, this; }, viewTranslate(t, e, i) { const n = this.viewMatrix; return n[12] = n[0] * t + n[4] * e + n[8] * i + n[12], n[13] = n[1] * t + n[5] * e + n[9] * i + n[13], n[14] = n[2] * t + n[6] * e + n[10] * i + n[14], n[15] = n[3] * t + n[7] * e + n[11] * i + n[15], this.viewMatrixDirty = !0, this; }, viewRotateX(t) { const e = this.viewMatrix; const i = Math.sin(t); const n = Math.cos(t); const s = e[4]; const r = e[5]; const o = e[6]; const a = e[7]; const h = e[8]; const l = e[9]; const u = e[10]; const c = e[11]; return e[4] = s * n + h * i, e[5] = r * n + l * i, e[6] = o * n + u * i, e[7] = a * n + c * i, e[8] = h * n - s * i, e[9] = l * n - r * i, e[10] = u * n - o * i, e[11] = c * n - a * i, this.viewMatrixDirty = !0, this; }, viewRotateY(t) { const e = this.viewMatrix; const i = Math.sin(t); const n = Math.cos(t); const s = e[0]; const r = e[1]; const o = e[2]; const a = e[3]; const h = e[8]; const l = e[9]; const u = e[10]; const c = e[11]; return e[0] = s * n - h * i, e[1] = r * n - l * i, e[2] = o * n - u * i, e[3] = a * n - c * i, e[8] = s * i + h * n, e[9] = r * i + l * n, e[10] = o * i + u * n, e[11] = a * i + c * n, this.viewMatrixDirty = !0, this; }, viewRotateZ(t) { const e = this.viewMatrix; const i = Math.sin(t); const n = Math.cos(t); const s = e[0]; const r = e[1]; const o = e[2]; const a = e[3]; const h = e[4]; const l = e[5]; const u = e[6]; const c = e[7]; return e[0] = s * n + h * i, e[1] = r * n + l * i, e[2] = o * n + u * i, e[3] = a * n + c * i, e[4] = h * n - s * i, e[5] = l * n - r * i, e[6] = u * n - o * i, e[7] = c * n - a * i, this.viewMatrixDirty = !0, this; }, viewLoad2D(t) { const e = this.viewMatrix; return e[0] = t[0], e[1] = t[1], e[2] = 0, e[3] = 0, e[4] = t[2], e[5] = t[3], e[6] = 0, e[7] = 0, e[8] = t[4], e[9] = t[5], e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this.viewMatrixDirty = !0, this; }, viewLoad(t) { const e = this.viewMatrix; return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], this.viewMatrixDirty = !0, this; }, projIdentity() { const t = this.projectionMatrix; return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this.projectionMatrixDirty = !0, this; }, projOrtho(t, e, i, n, s, r) { const o = this.projectionMatrix; const a = 1 / (t - e); const h = 1 / (i - n); const l = 1 / (s - r); return o[0] = -2 * a, o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[5] = -2 * h, o[6] = 0, o[7] = 0, o[8] = 0, o[9] = 0, o[10] = 2 * l, o[11] = 0, o[12] = (t + e) * a, o[13] = (n + i) * h, o[14] = (r + s) * l, o[15] = 1, this.projectionMatrixDirty = !0, this; }, projPersp(t, e, i, n) { const s = this.projectionMatrix; const r = 1 / Math.tan(t / 2); const o = 1 / (i - n); return s[0] = r / e, s[1] = 0, s[2] = 0, s[3] = 0, s[4] = 0, s[5] = r, s[6] = 0, s[7] = 0, s[8] = 0, s[9] = 0, s[10] = (n + i) * o, s[11] = -1, s[12] = 0, s[13] = 0, s[14] = 2 * n * i * o, s[15] = 0, this.projectionMatrixDirty = !0, this; },
  }; t.exports = i;
}, function (t, e) { t.exports = ['#define SHADER_NAME PHASER_FORWARD_DIFFUSE_FS', '', 'precision mediump float;', '', 'struct Light', '{', '    vec2 position;', '    vec3 color;', '    float intensity;', '    float radius;', '};', '', 'const int kMaxLights = %LIGHT_COUNT%;', '', 'uniform vec4 uCamera; /* x, y, rotation, zoom */', 'uniform vec2 uResolution;', 'uniform sampler2D uMainSampler;', 'uniform sampler2D uNormSampler;', 'uniform vec3 uAmbientLightColor;', 'uniform Light uLights[kMaxLights];', '', 'varying vec2 outTexCoord;', 'varying vec4 outTint;', '', 'void main()', '{', '    vec3 finalColor = vec3(0.0, 0.0, 0.0);', '    vec4 color = texture2D(uMainSampler, outTexCoord) * vec4(outTint.rgb * outTint.a, outTint.a);', '    vec3 normalMap = texture2D(uNormSampler, outTexCoord).rgb;', '    vec3 normal = normalize(vec3(normalMap * 2.0 - 1.0));', '    vec2 res = vec2(min(uResolution.x, uResolution.y)) * uCamera.w;', '', '    for (int index = 0; index < kMaxLights; ++index)', '    {', '        Light light = uLights[index];', '        vec3 lightDir = vec3((light.position.xy / res) - (gl_FragCoord.xy / res), 0.1);', '        vec3 lightNormal = normalize(lightDir);', '        float distToSurf = length(lightDir) * uCamera.w;', '        float diffuseFactor = max(dot(normal, lightNormal), 0.0);', '        float radius = (light.radius / res.x * uCamera.w) * uCamera.w;', '        float attenuation = clamp(1.0 - distToSurf * distToSurf / (radius * radius), 0.0, 1.0);', '        vec3 diffuse = light.color * diffuseFactor;', '        finalColor += (attenuation * diffuse) * light.intensity;', '    }', '', '    vec4 colorOutput = vec4(uAmbientLightColor + finalColor, 1.0);', '    gl_FragColor = color * vec4(colorOutput.rgb * colorOutput.a, colorOutput.a);', '', '}', ''].join('\n'); }, function (t, e) { t.exports = ['#define SHADER_NAME PHASER_BITMAP_MASK_VS', '', 'precision mediump float;', '', 'attribute vec2 inPosition;', '', 'void main()', '{', '    gl_Position = vec4(inPosition, 0.0, 1.0);', '}', ''].join('\n'); }, function (t, e) { t.exports = ['#define SHADER_NAME PHASER_BITMAP_MASK_FS', '', 'precision mediump float;', '', 'uniform vec2 uResolution;', 'uniform sampler2D uMainSampler;', 'uniform sampler2D uMaskSampler;', 'uniform bool uInvertMaskAlpha;', '', 'void main()', '{', '    vec2 uv = gl_FragCoord.xy / uResolution;', '    vec4 mainColor = texture2D(uMainSampler, uv);', '    vec4 maskColor = texture2D(uMaskSampler, uv);', '    float alpha = mainColor.a;', '', '    if (!uInvertMaskAlpha)', '    {', '        alpha *= (maskColor.a);', '    }', '    else', '    {', '        alpha *= (1.0 - maskColor.a);', '    }', '', '    gl_FragColor = vec4(mainColor.rgb * alpha, alpha);', '}', ''].join('\n'); }, function (t, e, i) { const n = i(348); const s = i(24); const r = i(26); const o = i(168); t.exports = function (t) { let e; let a; const h = t.config; if (h.renderType !== r.HEADLESS) if (h.renderType === r.CANVAS || h.renderType !== r.CANVAS && !o.webGL) { if (!o.canvas) throw new Error('Cannot create Canvas or WebGL context, aborting.'); h.renderType = r.CANVAS; } else h.renderType = r.WEBGL; h.antialias || s.disableSmoothing(), h.canvas ? (t.canvas = h.canvas, t.canvas.width = t.config.width, t.canvas.height = t.config.height) : t.canvas = s.create(t, h.width * h.resolution, h.height * h.resolution, h.renderType), h.canvasStyle && (t.canvas.style = h.canvasStyle), h.antialias || n.setCrisp(t.canvas), t.canvas.style.width = `${(h.width * h.zoom).toString()}px`, t.canvas.style.height = `${(h.height * h.zoom).toString()}px`, h.renderType !== r.HEADLESS && (e = i(426), a = i(423), h.renderType === r.WEBGL ? t.renderer = new a(t) : (t.renderer = new e(t), t.context = t.renderer.gameContext)); }; }, function (t, e) {
  const i = {
    available: !1, cancel: '', keyboard: !1, request: '',
  }; t.exports = (function () { let t; const e = ['requestFullscreen', 'requestFullScreen', 'webkitRequestFullscreen', 'webkitRequestFullScreen', 'msRequestFullscreen', 'msRequestFullScreen', 'mozRequestFullScreen', 'mozRequestFullscreen']; const n = document.createElement('div'); for (t = 0; t < e.length; t++) if (n[e[t]]) { i.available = !0, i.request = e[t]; break; } const s = ['cancelFullScreen', 'exitFullscreen', 'webkitCancelFullScreen', 'webkitExitFullscreen', 'msCancelFullScreen', 'msExitFullscreen', 'mozCancelFullScreen', 'mozExitFullscreen']; if (i.available) for (t = 0; t < s.length; t++) if (document[s[t]]) { i.cancel = s[t]; break; } return window.Element && Element.ALLOW_KEYBOARD_INPUT && (i.keyboard = !0), i; }());
}, function (t, e) {
  const i = {
    h264Video: !1, hlsVideo: !1, mp4Video: !1, oggVideo: !1, vp9Video: !1, webmVideo: !1,
  }; t.exports = (function () { const t = document.createElement('video'); const e = !!t.canPlayType; try { e && (t.canPlayType('video/ogg; codecs="theora"').replace(/^no$/, '') && (i.oggVideo = !0), t.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(/^no$/, '') && (i.h264Video = !0, i.mp4Video = !0), t.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/^no$/, '') && (i.webmVideo = !0), t.canPlayType('video/webm; codecs="vp9"').replace(/^no$/, '') && (i.vp9Video = !0), t.canPlayType('application/x-mpegURL; codecs="avc1.42E01E"').replace(/^no$/, '') && (i.hlsVideo = !0)); } catch (t) {} return i; }());
}, function (t, e, i) {
  const n = i(118); const s = {
    audioData: !1, dolby: !1, m4a: !1, mp3: !1, ogg: !1, opus: !1, wav: !1, webAudio: !1, webm: !1,
  }; t.exports = (function () { s.audioData = !!window.Audio, s.webAudio = !(!window.AudioContext && !window.webkitAudioContext); const t = document.createElement('audio'); const e = !!t.canPlayType; try { if (e && (t.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, '') && (s.ogg = !0), (t.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, '') || t.canPlayType('audio/opus;').replace(/^no$/, '')) && (s.opus = !0), t.canPlayType('audio/mpeg;').replace(/^no$/, '') && (s.mp3 = !0), t.canPlayType('audio/wav; codecs="1"').replace(/^no$/, '') && (s.wav = !0), (t.canPlayType('audio/x-m4a;') || t.canPlayType('audio/aac;').replace(/^no$/, '')) && (s.m4a = !0), t.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, '') && (s.webm = !0), t.canPlayType('audio/mp4;codecs="ec-3"') !== '')) if (n.edge)s.dolby = !0; else if (n.safari && n.safariVersion >= 9 && /Mac OS X (\d+)_(\d+)/.test(navigator.userAgent)) { const i = parseInt(RegExp.$1, 10); const r = parseInt(RegExp.$2, 10); (i === 10 && r >= 11 || i > 10) && (s.dolby = !0); } } catch (t) {} return s; }());
}, function (t, e, i) {
  const n = i(92); const s = i(118); const r = {
    gamepads: !1, mspointer: !1, touch: !1, wheelEvent: null,
  }; t.exports = (('ontouchstart' in document.documentElement || navigator.maxTouchPoints && navigator.maxTouchPoints >= 1) && (r.touch = !0), (navigator.msPointerEnabled || navigator.pointerEnabled) && (r.mspointer = !0), navigator.getGamepads && (r.gamepads = !0), n.cocoonJS || ('onwheel' in window || s.ie && 'WheelEvent' in window ? r.wheelEvent = 'wheel' : 'onmousewheel' in window ? r.wheelEvent = 'mousewheel' : s.firefox && 'MouseScrollEvent' in window && (r.wheelEvent = 'DOMMouseScroll')), r);
}, function (t, e, i) { const n = i(0); const s = i(26); const r = i(340); const o = i(2); const a = i(4); const h = i(8); const l = i(16); const u = i(1); const c = i(167); const d = i(178); const f = new n({ initialize(t) { void 0 === t && (t = {}); this.width = a(t, 'width', 1024), this.height = a(t, 'height', 768), this.zoom = a(t, 'zoom', 1), this.resolution = a(t, 'resolution', 1), this.parent = a(t, 'parent', null), this.scaleMode = a(t, 'scaleMode', 0), this.expandParent = a(t, 'expandParent', !1), this.minWidth = a(t, 'minWidth', 0), this.maxWidth = a(t, 'maxWidth', 0), this.minHeight = a(t, 'minHeight', 0), this.maxHeight = a(t, 'maxHeight', 0); const e = a(t, 'scale', null); e && (this.width = a(e, 'width', this.width), this.height = a(e, 'height', this.height), this.zoom = a(e, 'zoom', this.zoom), this.resolution = a(e, 'resolution', this.resolution), this.parent = a(e, 'parent', this.parent), this.scaleMode = a(e, 'mode', this.scaleMode), this.expandParent = a(e, 'mode', this.expandParent), this.minWidth = a(e, 'min.width', this.minWidth), this.maxWidth = a(e, 'max.width', this.maxWidth), this.minHeight = a(e, 'min.height', this.minHeight), this.maxHeight = a(e, 'max.height', this.maxHeight)), this.renderType = a(t, 'type', s.AUTO), this.canvas = a(t, 'canvas', null), this.context = a(t, 'context', null), this.canvasStyle = a(t, 'canvasStyle', null), this.sceneConfig = a(t, 'scene', null), this.seed = a(t, 'seed', [(Date.now() * Math.random()).toString()]), l.RND.init(this.seed), this.gameTitle = a(t, 'title', ''), this.gameURL = a(t, 'url', 'https://phaser.io'), this.gameVersion = a(t, 'version', ''), this.autoFocus = a(t, 'autoFocus', !0), this.domCreateContainer = a(t, 'dom.createContainer', !1), this.domBehindCanvas = a(t, 'dom.behindCanvas', !1), this.inputKeyboard = a(t, 'input.keyboard', !0), this.inputKeyboardEventTarget = a(t, 'input.keyboard.target', window), this.inputMouse = a(t, 'input.mouse', !0), this.inputMouseEventTarget = a(t, 'input.mouse.target', null), this.inputMouseCapture = a(t, 'input.mouse.capture', !0), this.inputTouch = a(t, 'input.touch', r.input.touch), this.inputTouchEventTarget = a(t, 'input.touch.target', null), this.inputTouchCapture = a(t, 'input.touch.capture', !0), this.inputActivePointers = a(t, 'input.activePointers', 1), this.inputGamepad = a(t, 'input.gamepad', !1), this.inputGamepadEventTarget = a(t, 'input.gamepad.target', window), this.disableContextMenu = a(t, 'disableContextMenu', !1), this.audio = a(t, 'audio'), this.hideBanner = !1 === a(t, 'banner', null), this.hidePhaser = a(t, 'banner.hidePhaser', !1), this.bannerTextColor = a(t, 'banner.text', '#ffffff'), this.bannerBackgroundColor = a(t, 'banner.background', ['#ff0000', '#ffff00', '#00ff00', '#00ffff', '#000000']), this.gameTitle === '' && this.hidePhaser && (this.hideBanner = !0), this.fps = a(t, 'fps', null); const i = a(t, 'render', t); this.autoResize = a(i, 'autoResize', !0), this.antialias = a(i, 'antialias', !0), this.roundPixels = a(i, 'roundPixels', !1), this.pixelArt = a(i, 'pixelArt', !1), this.pixelArt && (this.antialias = !1, this.roundPixels = !0), this.transparent = a(i, 'transparent', !1), this.clearBeforeRender = a(i, 'clearBeforeRender', !0), this.premultipliedAlpha = a(i, 'premultipliedAlpha', !0), this.preserveDrawingBuffer = a(i, 'preserveDrawingBuffer', !1), this.failIfMajorPerformanceCaveat = a(i, 'failIfMajorPerformanceCaveat', !1), this.powerPreference = a(i, 'powerPreference', 'default'), this.batchSize = a(i, 'batchSize', 2e3), this.maxLights = a(i, 'maxLights', 10); const n = a(t, 'backgroundColor', 0); this.backgroundColor = d(n), n === 0 && this.transparent && (this.backgroundColor.alpha = 0), this.preBoot = a(t, 'callbacks.preBoot', u), this.postBoot = a(t, 'callbacks.postBoot', u), this.physics = a(t, 'physics', {}), this.defaultPhysicsSystem = a(this.physics, 'default', !1), this.loaderBaseURL = a(t, 'loader.baseURL', ''), this.loaderPath = a(t, 'loader.path', ''), this.loaderMaxParallelDownloads = a(t, 'loader.maxParallelDownloads', 32), this.loaderCrossOrigin = a(t, 'loader.crossOrigin', void 0), this.loaderResponseType = a(t, 'loader.responseType', ''), this.loaderAsync = a(t, 'loader.async', !0), this.loaderUser = a(t, 'loader.user', ''), this.loaderPassword = a(t, 'loader.password', ''), this.loaderTimeout = a(t, 'loader.timeout', 0), this.installGlobalPlugins = [], this.installScenePlugins = []; const f = a(t, 'plugins', null); let p = c.DefaultScene; f && (Array.isArray(f) ? this.defaultPlugins = f : h(f) && (this.installGlobalPlugins = o(f, 'global', []), this.installScenePlugins = o(f, 'scene', []), Array.isArray(f.default) ? p = f.default : Array.isArray(f.defaultMerge) && (p = p.concat(f.defaultMerge)))), this.defaultPlugins = p; const g = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAg'; this.defaultImage = a(t, 'images.default', `${g}AQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAABVJREFUeF7NwIEAAAAAgKD9qdeocAMAoAABm3DkcAAAAABJRU5ErkJggg==`), this.missingImage = a(t, 'images.missing', `${g}CAIAAAD8GO2jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ9JREFUeNq01ssOwyAMRFG46v//Mt1ESmgh+DFmE2GPOBARKb2NVjo+17PXLD8a1+pl5+A+wSgFygymWYHBb0FtsKhJDdZlncG2IzJ4ayoMDv20wTmSMzClEgbWYNTAkQ0Z+OJ+A/eWnAaR9+oxCF4Os0H8htsMUp+pwcgBBiMNnAwF8GqIgL2hAzaGFFgZauDPKABmowZ4GL369/0rwACp2yA/ttmvsQAAAABJRU5ErkJggg==`), window && (window.FORCE_WEBGL ? this.renderType = s.WEBGL : window.FORCE_CANVAS && (this.renderType = s.CANVAS)); } }); t.exports = f; }, function (t, e, i) {
  const n = i(169); const s = i(381); const r = i(379); const o = i(24); const a = i(0); const h = i(903); const l = i(898); const u = i(123); const c = i(891); const d = i(340); const f = i(344); const p = i(11); const g = i(338); const v = i(15); const y = i(331); const m = i(329); const x = i(325); const w = i(318); const b = i(878); const T = i(877); const S = new a({
    initialize(t) { this.config = new h(t), this.renderer = null, this.canvas = null, this.context = null, this.isBooted = !1, this.isRunning = !1, this.events = new p(), this.anims = new s(this), this.textures = new w(this), this.cache = new r(this), this.registry = new u(this), this.input = new g(this, this.config), this.scene = new m(this, this.config.sceneConfig), this.device = d, this.sound = x.create(this), this.loop = new b(this, this.config.fps), this.plugins = new y(this, this.config), this.pendingDestroy = !1, this.removeCanvas = !1, this.noReturn = !1, this.hasFocus = !1, this.isOver = !0, f(this.boot.bind(this)); }, boot() { v.hasCore('EventEmitter') ? (this.isBooted = !0, this.config.preBoot(this), l(this), c(this), n(this.canvas, this.config.parent), this.events.emit('boot'), this.events.once('texturesready', this.texturesReady, this)) : console.warn('Aborting. Core Plugins missing.'); }, texturesReady() { this.events.emit('ready'), this.start(); }, start() { this.isRunning = !0, this.config.postBoot(this), this.renderer ? this.loop.start(this.step.bind(this)) : this.loop.start(this.headlessStep.bind(this)), T(this); const t = this.events; t.on('hidden', this.onHidden, this), t.on('visible', this.onVisible, this), t.on('blur', this.onBlur, this), t.on('focus', this.onFocus, this); }, step(t, e) { if (this.pendingDestroy) return this.runDestroy(); const i = this.events; i.emit('prestep', t, e), i.emit('step', t, e), this.scene.update(t, e), i.emit('poststep', t, e); const n = this.renderer; n.preRender(), i.emit('prerender', n, t, e), this.scene.render(n), n.postRender(), i.emit('postrender', n, t, e); }, headlessStep(t, e) { const i = this.events; i.emit('prestep', t, e), i.emit('step', t, e), this.scene.update(t, e), i.emit('poststep', t, e), i.emit('prerender'), i.emit('postrender'); }, onHidden() { this.loop.pause(), this.events.emit('pause'); }, onVisible() { this.loop.resume(), this.events.emit('resume'); }, onBlur() { this.hasFocus = !1, this.loop.blur(); }, onFocus() { this.hasFocus = !0, this.loop.focus(); }, resize(t, e) { this.config.width = t, this.config.height = e, this.renderer.resize(t, e), this.input.resize(), this.scene.resize(t, e), this.events.emit('resize', t, e); }, destroy(t, e) { void 0 === e && (e = !1), this.pendingDestroy = !0, this.removeCanvas = t, this.noReturn = e; }, runDestroy() { this.events.emit('destroy'), this.events.removeAllListeners(), this.scene.destroy(), this.renderer && this.renderer.destroy(), this.removeCanvas && this.canvas && (o.remove(this.canvas), this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas)), this.loop.destroy(), this.pendingDestroy = !1; },
  }); t.exports = S;
}, function (t, e, i) {
  const n = i(0); const s = i(11); const r = i(15); const o = new n({
    Extends: s, initialize() { s.call(this); }, shutdown() { this.removeAllListeners(); }, destroy() { this.removeAllListeners(); },
  }); r.register('EventEmitter', o, 'events'), t.exports = o;
}, function (t, e, i) { t.exports = { EventEmitter: i(905) }; }, function (t, e) { let i; let n; const s = t.exports = {}; function r() { throw new Error('setTimeout has not been defined'); } function o() { throw new Error('clearTimeout has not been defined'); } function a(t) { if (i === setTimeout) return setTimeout(t, 0); if ((i === r || !i) && setTimeout) return i = setTimeout, setTimeout(t, 0); try { return i(t, 0); } catch (e) { try { return i.call(null, t, 0); } catch (e) { return i.call(this, t, 0); } } }!(function () { try { i = typeof setTimeout === 'function' ? setTimeout : r; } catch (t) { i = r; } try { n = typeof clearTimeout === 'function' ? clearTimeout : o; } catch (t) { n = o; } }()); let h; let l = []; let u = !1; let c = -1; function d() { u && h && (u = !1, h.length ? l = h.concat(l) : c = -1, l.length && f()); } function f() { if (!u) { const t = a(d); u = !0; for (let e = l.length; e;) { for (h = l, l = []; ++c < e;)h && h[c].run(); c = -1, e = l.length; }h = null, u = !1, (function (t) { if (n === clearTimeout) return clearTimeout(t); if ((n === o || !n) && clearTimeout) return n = clearTimeout, clearTimeout(t); try { n(t); } catch (e) { try { return n.call(null, t); } catch (e) { return n.call(this, t); } } }(t)); } } function p(t, e) { this.fun = t, this.array = e; } function g() {}s.nextTick = function (t) { const e = new Array(arguments.length - 1); if (arguments.length > 1) for (let i = 1; i < arguments.length; i++)e[i - 1] = arguments[i]; l.push(new p(t, e)), l.length !== 1 || u || a(f); }, p.prototype.run = function () { this.fun.apply(null, this.array); }, s.title = 'browser', s.browser = !0, s.env = {}, s.argv = [], s.version = '', s.versions = {}, s.on = g, s.addListener = g, s.once = g, s.off = g, s.removeListener = g, s.removeAllListeners = g, s.emit = g, s.prependListener = g, s.prependOnceListener = g, s.listeners = function (t) { return []; }, s.binding = function (t) { throw new Error('process.binding is not supported'); }, s.cwd = function () { return '/'; }, s.chdir = function (t) { throw new Error('process.chdir is not supported'); }, s.umask = function () { return 0; }; }, function (t, e, i) {
  const n = {
    AddToDOM: i(169), DOMContentLoaded: i(344), ParseXML: i(343), RemoveFromDOM: i(342), RequestAnimationFrame: i(341),
  }; t.exports = n;
}, function (t, e, i) { t.exports = { BitmapMask: i(394), GeometryMask: i(393) }; }, function (t, e, i) { const n = i(346); t.exports = function (t, e, i, s, r) { return void 0 === s && (s = 255), void 0 === r && (r = '#'), r === '#' ? `#${((1 << 24) + (t << 16) + (e << 8) + i).toString(16).slice(1)}` : `0x${n(s)}${n(t)}${n(e)}${n(i)}`; }; }, function (t, e, i) { const n = i(170); const s = i(37); t.exports = function (t, e) { return void 0 === t && (t = 0), void 0 === e && (e = 255), new s(n(t, e), n(t, e), n(t, e)); }; }, function (t, e, i) { const n = i(119); const s = function (t, e, i, s, r, o, a, h) { void 0 === a && (a = 100), void 0 === h && (h = 0); const l = h / a; return { r: n(t, s, l), g: n(e, r, l), b: n(i, o, l) }; }; t.exports = { RGBWithRGB: s, ColorWithRGB(t, e, i, n, r, o) { return void 0 === r && (r = 100), void 0 === o && (o = 0), s(t.r, t.g, t.b, e, i, n, r, o); }, ColorWithColor(t, e, i, n) { return void 0 === i && (i = 100), void 0 === n && (n = 0), s(t.r, t.g, t.b, e.r, e.g, e.b, i, n); } }; }, function (t, e, i) { const n = i(176); t.exports = function (t, e) { void 0 === t && (t = 1), void 0 === e && (e = 1); for (var i = [], s = 0; s <= 359; s++)i.push(n(s / 359, t, e)); return i; }; }, function (t, e, i) { const n = i(37); const s = i(345); t.exports = function (t, e, i) { let r = i; let o = i; let a = i; if (e !== 0) { const h = i < 0.5 ? i * (1 + e) : i + e - i * e; const l = 2 * i - h; r = s(l, h, t + 1 / 3), o = s(l, h, t), a = s(l, h, t - 1 / 3); } return (new n()).setGLTo(r, o, a, 1); }; }, function (t, e) {
  t.exports = function (t) {
    const e = {
      r: t >> 16 & 255, g: t >> 8 & 255, b: 255 & t, a: 255,
    }; return t > 16777215 && (e.a = t >>> 24), e;
  };
}, function (t, e) { t.exports = function (t, e) { void 0 === e && (e = 'none'); return ['-webkit-', '-khtml-', '-moz-', '-ms-', ''].forEach((i) => { t.style[`${i}user-select`] = e; }), t.style['-webkit-touch-callout'] = e, t.style['-webkit-tap-highlight-color'] = 'rgba(0, 0, 0, 0)', t; }; }, function (t, e) { t.exports = function (t, e) { return void 0 === e && (e = 'none'), t.style.msTouchAction = e, t.style['ms-touch-action'] = e, t.style['touch-action'] = e, t; }; }, function (t, e, i) {
  t.exports = {
    CanvasInterpolation: i(348), CanvasPool: i(24), Smoothing: i(120), TouchAction: i(917), UserSelect: i(916),
  };
}, function (t, e) { t.exports = function (t) { return t.height * t.originY; }; }, function (t, e) { t.exports = function (t) { return t.width * t.originX; }; }, function (t, e, i) {
  t.exports = {
    CenterOn: i(411), GetBottom: i(48), GetCenterX: i(75), GetCenterY: i(72), GetLeft: i(46), GetOffsetX: i(920), GetOffsetY: i(919), GetRight: i(44), GetTop: i(42), SetBottom: i(47), SetCenterX: i(74), SetCenterY: i(73), SetLeft: i(45), SetRight: i(43), SetTop: i(41),
  };
}, function (t, e, i) { const n = i(44); const s = i(42); const r = i(47); const o = i(43); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), o(t, n(e) + i), r(t, s(e) - a), t; }; }, function (t, e, i) { const n = i(46); const s = i(42); const r = i(47); const o = i(45); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), o(t, n(e) - i), r(t, s(e) - a), t; }; }, function (t, e, i) { const n = i(75); const s = i(42); const r = i(47); const o = i(74); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), o(t, n(e) + i), r(t, s(e) - a), t; }; }, function (t, e, i) { const n = i(44); const s = i(42); const r = i(45); const o = i(41); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), r(t, n(e) + i), o(t, s(e) - a), t; }; }, function (t, e, i) { const n = i(72); const s = i(44); const r = i(73); const o = i(45); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), o(t, s(e) + i), r(t, n(e) + a), t; }; }, function (t, e, i) { const n = i(48); const s = i(44); const r = i(47); const o = i(45); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), o(t, s(e) + i), r(t, n(e) + a), t; }; }, function (t, e, i) { const n = i(46); const s = i(42); const r = i(43); const o = i(41); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), r(t, n(e) - i), o(t, s(e) - a), t; }; }, function (t, e, i) { const n = i(72); const s = i(46); const r = i(73); const o = i(43); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), o(t, s(e) - i), r(t, n(e) + a), t; }; }, function (t, e, i) { const n = i(48); const s = i(46); const r = i(47); const o = i(43); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), o(t, s(e) - i), r(t, n(e) + a), t; }; }, function (t, e, i) { const n = i(48); const s = i(44); const r = i(43); const o = i(41); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), r(t, s(e) + i), o(t, n(e) + a), t; }; }, function (t, e, i) { const n = i(48); const s = i(46); const r = i(45); const o = i(41); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), r(t, s(e) - i), o(t, n(e) + a), t; }; }, function (t, e, i) { const n = i(48); const s = i(75); const r = i(74); const o = i(41); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), r(t, s(e) + i), o(t, n(e) + a), t; }; }, function (t, e, i) {
  t.exports = {
    BottomCenter: i(933), BottomLeft: i(932), BottomRight: i(931), LeftBottom: i(930), LeftCenter: i(929), LeftTop: i(928), RightBottom: i(927), RightCenter: i(926), RightTop: i(925), TopCenter: i(924), TopLeft: i(923), TopRight: i(922),
  };
}, function (t, e, i) {
  t.exports = {
    BottomCenter: i(415), BottomLeft: i(414), BottomRight: i(413), Center: i(412), LeftCenter: i(410), QuickSet: i(416), RightCenter: i(409), TopCenter: i(408), TopLeft: i(407), TopRight: i(406),
  };
}, function (t, e, i) { const n = i(193); const s = i(20); let r = { In: i(935), To: i(934) }; r = s(!1, r, n), t.exports = r; }, function (t, e, i) {
  t.exports = {
    Align: i(936), Bounds: i(921), Canvas: i(918), Color: i(347), Masks: i(909),
  };
}, function (t, e, i) {
  const n = i(0); const s = i(123); const r = i(15); const o = new n({
    Extends: s, initialize(t) { s.call(this, t, t.sys.events), this.scene = t, this.systems = t.sys, t.sys.events.once('boot', this.boot, this), t.sys.events.on('start', this.start, this); }, boot() { this.events = this.systems.events, this.events.once('destroy', this.destroy, this); }, start() { this.events.once('shutdown', this.shutdown, this); }, shutdown() { this.systems.events.off('shutdown', this.shutdown, this); }, destroy() { s.prototype.destroy.call(this), this.events.off('start', this.start, this), this.scene = null, this.systems = null; },
  }); r.register('DataManagerPlugin', o, 'data'), t.exports = o;
}, function (t, e, i) { t.exports = { DataManager: i(123), DataManagerPlugin: i(938) }; }, function (t, e, i) {
  const n = i(0); const s = i(3); const r = new n({
    initialize(t, e) { this.active = !1, this.p0 = new s(t, e); }, getPoint(t, e) { return void 0 === e && (e = new s()), e.copy(this.p0); }, getPointAt(t, e) { return this.getPoint(t, e); }, getResolution() { return 1; }, getLength() { return 0; }, toJSON() { return { type: 'MoveTo', points: [this.p0.x, this.p0.y] }; },
  }); t.exports = r;
}, function (t, e, i) {
  const n = i(0); const s = i(355); const r = i(353); const o = i(5); const a = i(352); const h = i(940); const l = i(351); const u = i(9); const c = i(349); const d = i(3); const f = new n({
    initialize(t, e) { void 0 === t && (t = 0), void 0 === e && (e = 0), this.name = '', this.curves = [], this.cacheLengths = [], this.autoClose = !1, this.startPoint = new d(), this._tmpVec2A = new d(), this._tmpVec2B = new d(), typeof t === 'object' ? this.fromJSON(t) : this.startPoint.set(t, e); },
    add(t) { return this.curves.push(t), this; },
    circleTo(t, e, i) { return void 0 === e && (e = !1), this.ellipseTo(t, t, 0, 360, e, i); },
    closePath() { const t = this.curves[0].getPoint(0); const e = this.curves[this.curves.length - 1].getPoint(1); return t.equals(e) || this.curves.push(new a(e, t)), this; },
    cubicBezierTo(t, e, i, n, r, o) { let a; let h; let l; const u = this.getEndPoint(); return t instanceof d ? (a = t, h = e, l = i) : (a = new d(i, n), h = new d(r, o), l = new d(t, e)), this.add(new s(u, a, h, l)); },
    quadraticBezierTo(t, e, i, n) { let s; let r; const o = this.getEndPoint(); return t instanceof d ? (s = t, r = e) : (s = new d(i, n), r = new d(t, e)), this.add(new l(o, s, r)); },
    draw(t, e) { for (let i = 0; i < this.curves.length; i++) { const n = this.curves[i]; n.active && n.draw(t, e); } return t; },
    ellipseTo(t, e, i, n, s, o) { const a = new r(0, 0, t, e, i, n, s, o); const h = this.getEndPoint(this._tmpVec2A); const l = a.getStartPoint(this._tmpVec2B); return h.subtract(l), a.x = h.x, a.y = h.y, this.add(a); },
    fromJSON(t) { this.curves = [], this.cacheLengths = [], this.startPoint.set(t.x, t.y), this.autoClose = t.autoClose; for (let e = 0; e < t.curves.length; e++) { const i = t.curves[e]; switch (i.type) { case 'LineCurve': this.add(a.fromJSON(i)); break; case 'EllipseCurve': this.add(r.fromJSON(i)); break; case 'SplineCurve': this.add(c.fromJSON(i)); break; case 'CubicBezierCurve': this.add(s.fromJSON(i)); break; case 'QuadraticBezierCurve': this.add(l.fromJSON(i)); } } return this; },
    getBounds(t, e) { void 0 === t && (t = new u()), void 0 === e && (e = 16), t.x = Number.MAX_VALUE, t.y = Number.MAX_VALUE; for (var i = new u(), n = Number.MIN_SAFE_INTEGER, s = Number.MIN_SAFE_INTEGER, r = 0; r < this.curves.length; r++) { const o = this.curves[r]; o.active && (o.getBounds(i, e), t.x = Math.min(t.x, i.x), t.y = Math.min(t.y, i.y), n = Math.max(n, i.right), s = Math.max(s, i.bottom)); } return t.right = n, t.bottom = s, t; },
    getCurveLengths() { if (this.cacheLengths.length === this.curves.length) return this.cacheLengths; for (var t = [], e = 0, i = 0; i < this.curves.length; i++)e += this.curves[i].getLength(), t.push(e); return this.cacheLengths = t, t; },
    getEndPoint(t) { return void 0 === t && (t = new d()), this.curves.length > 0 ? this.curves[this.curves.length - 1].getPoint(1, t) : t.copy(this.startPoint), t; },
    getLength() { const t = this.getCurveLengths(); return t[t.length - 1]; },
    getPoint(t, e) { void 0 === e && (e = new d()); for (let i = t * this.getLength(), n = this.getCurveLengths(), s = 0; s < n.length;) { if (n[s] >= i) { const r = n[s] - i; const o = this.curves[s]; const a = o.getLength(); const h = a === 0 ? 0 : 1 - r / a; return o.getPointAt(h, e); }s++; } return null; },
    getPoints(t) { void 0 === t && (t = 12); for (var e, i = [], n = 0; n < this.curves.length; n++) { const s = this.curves[n]; if (s.active) for (let r = s.getResolution(t), o = s.getPoints(r), a = 0; a < o.length; a++) { const h = o[a]; e && e.equals(h) || (i.push(h), e = h); } } return this.autoClose && i.length > 1 && !i[i.length - 1].equals(i[0]) && i.push(i[0]), i; },
    getRandomPoint(t) { return void 0 === t && (t = new d()), this.getPoint(Math.random(), t); },
    getSpacedPoints(t) { void 0 === t && (t = 40); for (var e = [], i = 0; i <= t; i++)e.push(this.getPoint(i / t)); return this.autoClose && e.push(e[0]), e; },
    getStartPoint(t) { return void 0 === t && (t = new d()), t.copy(this.startPoint); },
    lineTo(t, e) { t instanceof d ? this._tmpVec2B.copy(t) : this._tmpVec2B.set(t, e); const i = this.getEndPoint(this._tmpVec2A); return this.add(new a([i.x, i.y, this._tmpVec2B.x, this._tmpVec2B.y])); },
    splineTo(t) { return t.unshift(this.getEndPoint()), this.add(new c(t)); },
    moveTo(t, e) { return this.add(new h(t, e)); },
    toJSON() {
      for (var t = [], e = 0; e < this.curves.length; e++)t.push(this.curves[e].toJSON()); return {
        type: 'Path', x: this.startPoint.x, y: this.startPoint.y, autoClose: this.autoClose, curves: t,
      };
    },
    updateArcLengths() { this.cacheLengths = [], this.getCurveLengths(); },
    destroy() { this.curves.length = 0, this.cacheLengths.length = 0, this.startPoint = void 0; },
  }); o.register('path', (t, e) => new f(t, e)), t.exports = f;
}, function (t, e, i) {
  t.exports = {
    Path: i(941), CubicBezier: i(355), Curve: i(70), Ellipse: i(353), Line: i(352), QuadraticBezier: i(351), Spline: i(349),
  };
}, function (t, e) {
  t.exports = {
    0: '#000', 1: '#191028', 2: '#46af45', 3: '#a1d685', 4: '#453e78', 5: '#7664fe', 6: '#833129', 7: '#9ec2e8', 8: '#dc534b', 9: '#e18d79', A: '#d6b97b', B: '#e9d8a1', C: '#216c4b', D: '#d365c8', E: '#afaab9', F: '#fff',
  };
}, function (t, e) {
  t.exports = {
    0: '#000', 1: '#191028', 2: '#46af45', 3: '#a1d685', 4: '#453e78', 5: '#7664fe', 6: '#833129', 7: '#9ec2e8', 8: '#dc534b', 9: '#e18d79', A: '#d6b97b', B: '#e9d8a1', C: '#216c4b', D: '#d365c8', E: '#afaab9', F: '#f5f4eb',
  };
}, function (t, e) {
  t.exports = {
    0: '#000', 1: '#2234d1', 2: '#0c7e45', 3: '#44aacc', 4: '#8a3622', 5: '#5c2e78', 6: '#aa5c3d', 7: '#b5b5b5', 8: '#5e606e', 9: '#4c81fb', A: '#6cd947', B: '#7be2f9', C: '#eb8a60', D: '#e23d69', E: '#ffd93f', F: '#fff',
  };
}, function (t, e) {
  t.exports = {
    0: '#000', 1: '#fff', 2: '#8b4131', 3: '#7bbdc5', 4: '#8b41ac', 5: '#6aac41', 6: '#3931a4', 7: '#d5de73', 8: '#945a20', 9: '#5a4100', A: '#bd736a', B: '#525252', C: '#838383', D: '#acee8b', E: '#7b73de', F: '#acacac',
  };
}, function (t, e, i) {
  t.exports = {
    ARNE16: i(356), C64: i(946), CGA: i(945), JMP: i(944), MSX: i(943),
  };
}, function (t, e, i) { t.exports = { GenerateTexture: i(357), Palettes: i(947) }; }, function (t, e, i) {
  const n = i(378); const s = i(0); const r = i(2); const o = i(15); const a = i(39); const h = new s({
    initialize(t) { this.scene = t, this.systems = t.sys, this.roundPixels = t.sys.game.config.roundPixels, this.cameras = [], this.main, this.baseScale = 1, t.sys.events.once('boot', this.boot, this), t.sys.events.on('start', this.start, this); }, boot() { const t = this.systems; t.settings.cameras ? this.fromJSON(t.settings.cameras) : this.add(), this.main = this.cameras[0], this.systems.events.once('destroy', this.destroy, this); }, start() { if (!this.main) { const t = this.systems; t.settings.cameras ? this.fromJSON(t.settings.cameras) : this.add(), this.main = this.cameras[0]; } const e = this.systems.events; e.on('update', this.update, this), e.once('shutdown', this.shutdown, this); }, add(t, e, i, s, r, o) { void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = this.scene.sys.game.config.width), void 0 === s && (s = this.scene.sys.game.config.height), void 0 === r && (r = !1), void 0 === o && (o = ''); const a = new n(t, e, i, s); return a.setName(o), a.setScene(this.scene), a.setRoundPixels(this.roundPixels), a.id = this.getNextID(), this.cameras.push(a), r && (this.main = a), a; }, addExisting(t, e) { return void 0 === e && (e = !1), this.cameras.indexOf(t) === -1 ? (t.id = this.getNextID(), t.setRoundPixels(this.roundPixels), this.cameras.push(t), e && (this.main = t), t) : null; }, getNextID() { for (let t = this.cameras, e = 1, i = 0; i < 32; i++) { for (var n = !1, s = 0; s < t.length; s++) { const r = t[s]; r && r.id === e && (n = !0); } if (!n) return e; e <<= 1; } return 0; }, getTotal(t) { void 0 === t && (t = !1); for (var e = 0, i = this.cameras, n = 0; n < i.length; n++) { const s = i[n]; (!t || t && s.visible) && e++; } return e; }, fromJSON(t) { Array.isArray(t) || (t = [t]); for (let e = this.scene.sys.game.config.width, i = this.scene.sys.game.config.height, n = 0; n < t.length; n++) { const s = t[n]; const o = r(s, 'x', 0); const a = r(s, 'y', 0); const h = r(s, 'width', e); const l = r(s, 'height', i); const u = this.add(o, a, h, l); u.name = r(s, 'name', ''), u.zoom = r(s, 'zoom', 1), u.rotation = r(s, 'rotation', 0), u.scrollX = r(s, 'scrollX', 0), u.scrollY = r(s, 'scrollY', 0), u.roundPixels = r(s, 'roundPixels', !1), u.visible = r(s, 'visible', !0); const c = r(s, 'backgroundColor', !1); c && u.setBackgroundColor(c); const d = r(s, 'bounds', null); if (d) { const f = r(d, 'x', 0); const p = r(d, 'y', 0); const g = r(d, 'width', e); const v = r(d, 'height', i); u.setBounds(f, p, g, v); } } return this; }, getCamera(t) { for (let e = this.cameras, i = 0; i < e.length; i++) if (e[i].name === t) return e[i]; return null; }, getCamerasBelowPointer(t) { for (var e = this.cameras, i = t.x, n = t.y, s = [], r = 0; r < e.length; r++) { const o = e[r]; o.visible && o.inputEnabled && a(o, i, n) && s.unshift(o); } return s; }, remove(t, e) { void 0 === e && (e = !0), Array.isArray(t) || (t = [t]); for (var i = 0, n = this.cameras, s = 0; s < t.length; s++) { const r = n.indexOf(t[s]); r !== -1 && (e && n[r].destroy(), n.splice(r, 1), i++); } return !this.main && n[0] && (this.main = n[0]), i; }, render(t, e, i) { for (let n = this.scene, s = this.cameras, r = this.baseScale, o = t.config.resolution, a = 0; a < this.cameras.length; a++) { const h = s[a]; h.visible && h.alpha > 0 && (h.preRender(r, o), t.render(n, e, i, h)); } }, resetAll() { for (let t = 0; t < this.cameras.length; t++) this.cameras[t].destroy(); return this.cameras = [], this.main = this.add(), this.main; }, update(t, e) { for (let i = 0; i < this.cameras.length; i++) this.cameras[i].update(t, e); }, resize(t, e) { for (let i = 0; i < this.cameras.length; i++) this.cameras[i].setSize(t, e); }, shutdown() { this.main = void 0; for (let t = 0; t < this.cameras.length; t++) this.cameras[t].destroy(); this.cameras = []; const e = this.systems.events; e.off('update', this.update, this), e.off('shutdown', this.shutdown, this); }, destroy() { this.shutdown(), this.scene.sys.events.off('start', this.start, this), this.scene = null, this.systems = null; },
  }); o.register('CameraManager', h, 'cameras'), t.exports = h;
}, function (t, e, i) {
  const n = i(23); const s = i(0); const r = i(174); const o = new s({
    initialize(t) { this.camera = t, this.isRunning = !1, this.duration = 0, this.source = 1, this.destination = 1, this.ease, this.progress = 0, this._elapsed = 0, this._onUpdate, this._onUpdateScope; }, start(t, e, i, n, s, o) { void 0 === e && (e = 1e3), void 0 === i && (i = r.Linear), void 0 === n && (n = !1), void 0 === s && (s = null), void 0 === o && (o = this.camera.scene); const a = this.camera; return !n && this.isRunning ? a : (this.isRunning = !0, this.duration = e, this.progress = 0, this.source = a.zoom, this.destination = t, typeof i === 'string' && r.hasOwnProperty(i) ? this.ease = r[i] : typeof i === 'function' && (this.ease = i), this._elapsed = 0, this._onUpdate = s, this._onUpdateScope = o, this.camera.emit('camerazoomstart', this.camera, this, e, t), a); }, update(t, e) { this.isRunning && (this._elapsed += e, this.progress = n(this._elapsed / this.duration, 0, 1), this._elapsed < this.duration ? (this.camera.zoom = this.source + (this.destination - this.source) * this.ease(this.progress), this._onUpdate && this._onUpdate.call(this._onUpdateScope, this.camera, this.progress, this.camera.zoom)) : (this.camera.zoom = this.destination, this._onUpdate && this._onUpdate.call(this._onUpdateScope, this.camera, this.progress, this.destination), this.effectComplete())); }, effectComplete() { this._onUpdate = null, this._onUpdateScope = null, this.isRunning = !1, this.camera.emit('camerazoomcomplete', this.camera, this); }, reset() { this.isRunning = !1, this._onUpdate = null, this._onUpdateScope = null; }, destroy() { this.reset(), this.camera = null; },
  }); t.exports = o;
}, function (t, e, i) {
  const n = i(23); const s = i(0); const r = i(3); const o = new s({
    initialize(t) { this.camera = t, this.isRunning = !1, this.duration = 0, this.intensity = new r(), this.progress = 0, this._elapsed = 0, this._offsetX = 0, this._offsetY = 0, this._onUpdate, this._onUpdateScope; }, start(t, e, i, n, s) { return void 0 === t && (t = 100), void 0 === e && (e = 0.05), void 0 === i && (i = !1), void 0 === n && (n = null), void 0 === s && (s = this.camera.scene), !i && this.isRunning ? this.camera : (this.isRunning = !0, this.duration = t, this.progress = 0, typeof e === 'number' ? this.intensity.set(e) : this.intensity.set(e.x, e.y), this._elapsed = 0, this._offsetX = 0, this._offsetY = 0, this._onUpdate = n, this._onUpdateScope = s, this.camera.emit('camerashakestart', this.camera, this, t, e), this.camera); }, preRender() { this.isRunning && this.camera.matrix.translate(this._offsetX, this._offsetY); }, update(t, e) { if (this.isRunning) if (this._elapsed += e, this.progress = n(this._elapsed / this.duration, 0, 1), this._onUpdate && this._onUpdate.call(this._onUpdateScope, this.camera, this.progress), this._elapsed < this.duration) { const i = this.intensity; const s = this.camera._cw; const r = this.camera._ch; const o = this.camera.zoom; this._offsetX = (Math.random() * i.x * s * 2 - i.x * s) * o, this._offsetY = (Math.random() * i.y * r * 2 - i.y * r) * o, this.camera.roundPixels && (this._offsetX |= 0, this._offsetY |= 0); } else this.effectComplete(); }, effectComplete() { this._offsetX = 0, this._offsetY = 0, this._onUpdate = null, this._onUpdateScope = null, this.isRunning = !1, this.camera.emit('camerashakecomplete', this.camera, this); }, reset() { this.isRunning = !1, this._offsetX = 0, this._offsetY = 0, this._onUpdate = null, this._onUpdateScope = null; }, destroy() { this.reset(), this.camera = null, this.intensity = null; },
  }); t.exports = o;
}, function (t, e) { t.exports = function (t, e) { return void 0 === e && (e = 1), t <= 0 ? 0 : t >= 1 ? 1 : 1 / e * (1 + (e * t | 0)); }; }, function (t, e) { t.exports = function (t) { return t === 0 ? 0 : t === 1 ? 1 : 0.5 * (1 - Math.cos(Math.PI * t)); }; }, function (t, e) { t.exports = function (t) { return t === 0 ? 0 : t === 1 ? 1 : Math.sin(t * Math.PI / 2); }; }, function (t, e) { t.exports = function (t) { return t === 0 ? 0 : t === 1 ? 1 : 1 - Math.cos(t * Math.PI / 2); }; }, function (t, e) { t.exports = function (t) { return (t *= 2) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2); }; }, function (t, e) { t.exports = function (t) { return --t * t * t * t * t + 1; }; }, function (t, e) { t.exports = function (t) { return t * t * t * t * t; }; }, function (t, e) { t.exports = function (t) { return (t *= 2) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2); }; }, function (t, e) { t.exports = function (t) { return 1 - --t * t * t * t; }; }, function (t, e) { t.exports = function (t) { return t * t * t * t; }; }, function (t, e) { t.exports = function (t) { return (t *= 2) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1); }; }, function (t, e) { t.exports = function (t) { return t * (2 - t); }; }, function (t, e) { t.exports = function (t) { return t * t; }; }, function (t, e) { t.exports = function (t) { return t; }; }, function (t, e) { t.exports = function (t) { return (t *= 2) < 1 ? 0.5 * Math.pow(2, 10 * (t - 1)) : 0.5 * (2 - Math.pow(2, -10 * (t - 1))); }; }, function (t, e) { t.exports = function (t) { return 1 - Math.pow(2, -10 * t); }; }, function (t, e) { t.exports = function (t) { return Math.pow(2, 10 * (t - 1)) - 0.001; }; }, function (t, e) { t.exports = function (t, e, i) { if (void 0 === e && (e = 0.1), void 0 === i && (i = 0.1), t === 0) return 0; if (t === 1) return 1; let n = i / 4; return e < 1 ? e = 1 : n = i * Math.asin(1 / e) / (2 * Math.PI), (t *= 2) < 1 ? e * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - n) * (2 * Math.PI) / i) * -0.5 : e * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - n) * (2 * Math.PI) / i) * 0.5 + 1; }; }, function (t, e) { t.exports = function (t, e, i) { if (void 0 === e && (e = 0.1), void 0 === i && (i = 0.1), t === 0) return 0; if (t === 1) return 1; let n = i / 4; return e < 1 ? e = 1 : n = i * Math.asin(1 / e) / (2 * Math.PI), e * Math.pow(2, -10 * t) * Math.sin((t - n) * (2 * Math.PI) / i) + 1; }; }, function (t, e) { t.exports = function (t, e, i) { if (void 0 === e && (e = 0.1), void 0 === i && (i = 0.1), t === 0) return 0; if (t === 1) return 1; let n = i / 4; return e < 1 ? e = 1 : n = i * Math.asin(1 / e) / (2 * Math.PI), -e * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - n) * (2 * Math.PI) / i); }; }, function (t, e) { t.exports = function (t) { return (t *= 2) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2); }; }, function (t, e) { t.exports = function (t) { return --t * t * t + 1; }; }, function (t, e) { t.exports = function (t) { return t * t * t; }; }, function (t, e) { t.exports = function (t) { return (t *= 2) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1); }; }, function (t, e) { t.exports = function (t) { return Math.sqrt(1 - --t * t); }; }, function (t, e) { t.exports = function (t) { return 1 - Math.sqrt(1 - t * t); }; }, function (t, e) { t.exports = function (t) { let e = !1; return t < 0.5 ? (t = 1 - 2 * t, e = !0) : t = 2 * t - 1, t < 1 / 2.75 ? t *= 7.5625 * t : t = t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + 0.75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375 : 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375, e ? 0.5 * (1 - t) : 0.5 * t + 0.5; }; }, function (t, e) { t.exports = function (t) { return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + 0.75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375 : 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375; }; }, function (t, e) { t.exports = function (t) { return (t = 1 - t) < 1 / 2.75 ? 1 - 7.5625 * t * t : t < 2 / 2.75 ? 1 - (7.5625 * (t -= 1.5 / 2.75) * t + 0.75) : t < 2.5 / 2.75 ? 1 - (7.5625 * (t -= 2.25 / 2.75) * t + 0.9375) : 1 - (7.5625 * (t -= 2.625 / 2.75) * t + 0.984375); }; }, function (t, e) { t.exports = function (t, e) { void 0 === e && (e = 1.70158); const i = 1.525 * e; return (t *= 2) < 1 ? t * t * ((i + 1) * t - i) * 0.5 : 0.5 * ((t -= 2) * t * ((i + 1) * t + i) + 2); }; }, function (t, e) { t.exports = function (t, e) { return void 0 === e && (e = 1.70158), --t * t * ((e + 1) * t + e) + 1; }; }, function (t, e) { t.exports = function (t, e) { return void 0 === e && (e = 1.70158), t * t * ((e + 1) * t - e); }; }, function (t, e, i) {
  const n = i(23); const s = i(0); const r = i(3); const o = i(174); const a = new s({
    initialize(t) { this.camera = t, this.isRunning = !1, this.duration = 0, this.source = new r(), this.current = new r(), this.destination = new r(), this.ease, this.progress = 0, this._elapsed = 0, this._onUpdate, this._onUpdateScope; }, start(t, e, i, n, s, r, a) { void 0 === i && (i = 1e3), void 0 === n && (n = o.Linear), void 0 === s && (s = !1), void 0 === r && (r = null), void 0 === a && (a = this.camera.scene); const h = this.camera; return !s && this.isRunning ? h : (this.isRunning = !0, this.duration = i, this.progress = 0, this.source.set(h.scrollX, h.scrollY), this.destination.set(t, e), h.getScroll(t, e, this.current), typeof n === 'string' && o.hasOwnProperty(n) ? this.ease = o[n] : typeof n === 'function' && (this.ease = n), this._elapsed = 0, this._onUpdate = r, this._onUpdateScope = a, this.camera.emit('camerapanstart', this.camera, this, i, t, e), h); }, update(t, e) { if (this.isRunning) { this._elapsed += e; const i = n(this._elapsed / this.duration, 0, 1); this.progress = i; const s = this.camera; if (this._elapsed < this.duration) { const r = this.ease(i); s.getScroll(this.destination.x, this.destination.y, this.current); const o = this.source.x + (this.current.x - this.source.x) * r; const a = this.source.y + (this.current.y - this.source.y) * r; s.setScroll(o, a), this._onUpdate && this._onUpdate.call(this._onUpdateScope, s, i, o, a); } else s.centerOn(this.destination.x, this.destination.y), this._onUpdate && this._onUpdate.call(this._onUpdateScope, s, i, s.scrollX, s.scrollY), this.effectComplete(); } }, effectComplete() { this._onUpdate = null, this._onUpdateScope = null, this.isRunning = !1, this.camera.emit('camerapancomplete', this.camera, this); }, reset() { this.isRunning = !1, this._onUpdate = null, this._onUpdateScope = null; }, destroy() { this.reset(), this.camera = null, this.source = null, this.destination = null; },
  }); t.exports = a;
}, function (t, e, i) {
  const n = i(23); const s = new (i(0))({
    initialize(t) { this.camera = t, this.isRunning = !1, this.duration = 0, this.red = 0, this.green = 0, this.blue = 0, this.alpha = 0, this.progress = 0, this._elapsed = 0, this._onUpdate, this._onUpdateScope; }, start(t, e, i, n, s, r, o) { return void 0 === t && (t = 250), void 0 === e && (e = 255), void 0 === i && (i = 255), void 0 === n && (n = 255), void 0 === s && (s = !1), void 0 === r && (r = null), void 0 === o && (o = this.camera.scene), !s && this.isRunning ? this.camera : (this.isRunning = !0, this.duration = t, this.progress = 0, this.red = e, this.green = i, this.blue = n, this.alpha = 1, this._elapsed = 0, this._onUpdate = r, this._onUpdateScope = o, this.camera.emit('cameraflashstart', this.camera, this, t, e, i, n), this.camera); }, update(t, e) { this.isRunning && (this._elapsed += e, this.progress = n(this._elapsed / this.duration, 0, 1), this._onUpdate && this._onUpdate.call(this._onUpdateScope, this.camera, this.progress), this._elapsed < this.duration ? this.alpha = 1 - this.progress : this.effectComplete()); }, postRenderCanvas(t) { if (!this.isRunning) return !1; const e = this.camera; return t.fillStyle = `rgba(${this.red},${this.green},${this.blue},${this.alpha})`, t.fillRect(e._cx, e._cy, e._cw, e._ch), !0; }, postRenderWebGL(t, e) { if (!this.isRunning) return !1; const i = this.camera; const n = this.red / 255; const s = this.blue / 255; const r = this.green / 255; return t.drawFillRect(i._cx, i._cy, i._cw, i._ch, e(n, r, s, 1), this.alpha), !0; }, effectComplete() { this._onUpdate = null, this._onUpdateScope = null, this.isRunning = !1, this.camera.emit('cameraflashcomplete', this.camera, this); }, reset() { this.isRunning = !1, this._onUpdate = null, this._onUpdateScope = null; }, destroy() { this.reset(), this.camera = null; },
  }); t.exports = s;
}, function (t, e, i) {
  const n = i(23); const s = new (i(0))({
    initialize(t) { this.camera = t, this.isRunning = !1, this.isComplete = !1, this.direction = !0, this.duration = 0, this.red = 0, this.green = 0, this.blue = 0, this.alpha = 0, this.progress = 0, this._elapsed = 0, this._onUpdate, this._onUpdateScope; }, start(t, e, i, n, s, r, o, a) { if (void 0 === t && (t = !0), void 0 === e && (e = 1e3), void 0 === i && (i = 0), void 0 === n && (n = 0), void 0 === s && (s = 0), void 0 === r && (r = !1), void 0 === o && (o = null), void 0 === a && (a = this.camera.scene), !r && this.isRunning) return this.camera; this.isRunning = !0, this.isComplete = !1, this.duration = e, this.direction = t, this.progress = 0, this.red = i, this.green = n, this.blue = s, this.alpha = t ? Number.MIN_VALUE : 1, this._elapsed = 0, this._onUpdate = o, this._onUpdateScope = a; const h = t ? 'camerafadeoutstart' : 'camerafadeinstart'; return this.camera.emit(h, this.camera, this, e, i, n, s), this.camera; }, update(t, e) { this.isRunning && (this._elapsed += e, this.progress = n(this._elapsed / this.duration, 0, 1), this._onUpdate && this._onUpdate.call(this._onUpdateScope, this.camera, this.progress), this._elapsed < this.duration ? this.alpha = this.direction ? this.progress : 1 - this.progress : this.effectComplete()); }, postRenderCanvas(t) { if (!this.isRunning && !this.isComplete) return !1; const e = this.camera; return t.fillStyle = `rgba(${this.red},${this.green},${this.blue},${this.alpha})`, t.fillRect(e._cx, e._cy, e._cw, e._ch), !0; }, postRenderWebGL(t, e) { if (!this.isRunning && !this.isComplete) return !1; const i = this.camera; const n = this.red / 255; const s = this.blue / 255; const r = this.green / 255; return t.drawFillRect(i._cx, i._cy, i._cw, i._ch, e(n, r, s, 1), this.alpha), !0; }, effectComplete() { this._onUpdate = null, this._onUpdateScope = null, this.isRunning = !1, this.isComplete = !0; const t = this.direction ? 'camerafadeoutcomplete' : 'camerafadeincomplete'; this.camera.emit(t, this.camera, this); }, reset() { this.isRunning = !1, this.isComplete = !1, this._onUpdate = null, this._onUpdateScope = null; }, destroy() { this.reset(), this.camera = null; },
  }); t.exports = s;
}, function (t, e, i) { t.exports = { Camera: i(378), CameraManager: i(949), Effects: i(370) }; }, function (t, e, i) {
  const n = i(0); const s = i(4); const r = new n({
    initialize(t) { this.camera = s(t, 'camera', null), this.left = s(t, 'left', null), this.right = s(t, 'right', null), this.up = s(t, 'up', null), this.down = s(t, 'down', null), this.zoomIn = s(t, 'zoomIn', null), this.zoomOut = s(t, 'zoomOut', null), this.zoomSpeed = s(t, 'zoomSpeed', 0.01), this.accelX = 0, this.accelY = 0; const e = s(t, 'acceleration', null); typeof e === 'number' ? (this.accelX = e, this.accelY = e) : (this.accelX = s(t, 'acceleration.x', 0), this.accelY = s(t, 'acceleration.y', 0)), this.dragX = 0, this.dragY = 0; const i = s(t, 'drag', null); typeof i === 'number' ? (this.dragX = i, this.dragY = i) : (this.dragX = s(t, 'drag.x', 0), this.dragY = s(t, 'drag.y', 0)), this.maxSpeedX = 0, this.maxSpeedY = 0; const n = s(t, 'maxSpeed', null); typeof n === 'number' ? (this.maxSpeedX = n, this.maxSpeedY = n) : (this.maxSpeedX = s(t, 'maxSpeed.x', 0), this.maxSpeedY = s(t, 'maxSpeed.y', 0)), this._speedX = 0, this._speedY = 0, this._zoom = 0, this.active = this.camera !== null; }, start() { return this.active = this.camera !== null, this; }, stop() { return this.active = !1, this; }, setCamera(t) { return this.camera = t, this; }, update(t) { if (this.active) { void 0 === t && (t = 1); const e = this.camera; this._speedX > 0 ? (this._speedX -= this.dragX * t, this._speedX < 0 && (this._speedX = 0)) : this._speedX < 0 && (this._speedX += this.dragX * t, this._speedX > 0 && (this._speedX = 0)), this._speedY > 0 ? (this._speedY -= this.dragY * t, this._speedY < 0 && (this._speedY = 0)) : this._speedY < 0 && (this._speedY += this.dragY * t, this._speedY > 0 && (this._speedY = 0)), this.up && this.up.isDown ? (this._speedY += this.accelY, this._speedY > this.maxSpeedY && (this._speedY = this.maxSpeedY)) : this.down && this.down.isDown && (this._speedY -= this.accelY, this._speedY < -this.maxSpeedY && (this._speedY = -this.maxSpeedY)), this.left && this.left.isDown ? (this._speedX += this.accelX, this._speedX > this.maxSpeedX && (this._speedX = this.maxSpeedX)) : this.right && this.right.isDown && (this._speedX -= this.accelX, this._speedX < -this.maxSpeedX && (this._speedX = -this.maxSpeedX)), this.zoomIn && this.zoomIn.isDown ? this._zoom = -this.zoomSpeed : this.zoomOut && this.zoomOut.isDown ? this._zoom = this.zoomSpeed : this._zoom = 0, this._speedX !== 0 && (e.scrollX -= this._speedX * t | 0), this._speedY !== 0 && (e.scrollY -= this._speedY * t | 0), this._zoom !== 0 && (e.zoom += this._zoom, e.zoom < 0.1 && (e.zoom = 0.1)); } }, destroy() { this.camera = null, this.left = null, this.right = null, this.up = null, this.down = null, this.zoomIn = null, this.zoomOut = null; },
  }); t.exports = r;
}, function (t, e, i) {
  const n = i(0); const s = i(4); const r = new n({
    initialize(t) { this.camera = s(t, 'camera', null), this.left = s(t, 'left', null), this.right = s(t, 'right', null), this.up = s(t, 'up', null), this.down = s(t, 'down', null), this.zoomIn = s(t, 'zoomIn', null), this.zoomOut = s(t, 'zoomOut', null), this.zoomSpeed = s(t, 'zoomSpeed', 0.01), this.speedX = 0, this.speedY = 0; const e = s(t, 'speed', null); typeof e === 'number' ? (this.speedX = e, this.speedY = e) : (this.speedX = s(t, 'speed.x', 0), this.speedY = s(t, 'speed.y', 0)), this._zoom = 0, this.active = this.camera !== null; }, start() { return this.active = this.camera !== null, this; }, stop() { return this.active = !1, this; }, setCamera(t) { return this.camera = t, this; }, update(t) { if (this.active) { void 0 === t && (t = 1); const e = this.camera; this.up && this.up.isDown ? e.scrollY -= this.speedY * t | 0 : this.down && this.down.isDown && (e.scrollY += this.speedY * t | 0), this.left && this.left.isDown ? e.scrollX -= this.speedX * t | 0 : this.right && this.right.isDown && (e.scrollX += this.speedX * t | 0), this.zoomIn && this.zoomIn.isDown ? (e.zoom -= this.zoomSpeed, e.zoom < 0.1 && (e.zoom = 0.1)) : this.zoomOut && this.zoomOut.isDown && (e.zoom += this.zoomSpeed); } }, destroy() { this.camera = null, this.left = null, this.right = null, this.up = null, this.down = null, this.zoomIn = null, this.zoomOut = null; },
  }); t.exports = r;
}, function (t, e, i) { t.exports = { FixedKeyControl: i(989), SmoothedKeyControl: i(988) }; }, function (t, e, i) { t.exports = { Controls: i(990), Scene2D: i(987) }; }, function (t, e, i) { t.exports = { BaseCache: i(380), CacheManager: i(379) }; }, function (t, e, i) { t.exports = { Animation: i(384), AnimationFrame: i(382), AnimationManager: i(381) }; }, function (t, e, i) { const n = i(53); t.exports = function (t, e, i) { void 0 === i && (i = 0); for (let s = 0; s < t.length; s++) { const r = t[s]; r.x = n(r.x, e.left - i, e.right + i), r.y = n(r.y, e.top - i, e.bottom + i); } return t; }; }, function (t, e) { t.exports = function (t) { for (let e = 0; e < t.length; e++)t[e].visible = !t[e].visible; return t; }; }, function (t, e) { t.exports = function (t, e, i, n, s) { void 0 === s && (s = !1); let r; const o = Math.abs(n - i) / t.length; if (s) for (r = 0; r < t.length; r++)t[r][e] += r * o; else for (r = 0; r < t.length; r++)t[r][e] = r * o; return t; }; }, function (t, e, i) { const n = i(181); t.exports = function (t, e, i, s, r) { void 0 === r && (r = !1); let o; const a = Math.abs(s - i) / t.length; if (r) for (o = 0; o < t.length; o++)t[o][e] += n(o * a, i, s); else for (o = 0; o < t.length; o++)t[o][e] = n(o * a, i, s); return t; }; }, function (t, e, i) { const n = i(182); t.exports = function (t, e, i, s, r) { void 0 === r && (r = !1); let o; const a = Math.abs(s - i) / t.length; if (r) for (o = 0; o < t.length; o++)t[o][e] += n(o * a, i, s); else for (o = 0; o < t.length; o++)t[o][e] = n(o * a, i, s); return t; }; }, function (t, e, i) { const n = i(122); t.exports = function (t) { return n(t); }; }, function (t, e, i) { const n = i(3); t.exports = function (t, e, i, s, r) { let o; let a; let h; let l; let u; let c; if (void 0 === s && (s = 0), void 0 === r && (r = new n()), t.length > 1) if (s === 0) { const d = t.length - 1; for (o = t[d].x, a = t[d].y, h = d - 1; h >= 0; h--)l = (c = t[h]).x, u = c.y, c.x = o, c.y = a, o = l, a = u; t[d].x = e, t[d].y = i; } else { for (o = t[0].x, a = t[0].y, h = 1; h < t.length; h++)l = (c = t[h]).x, u = c.y, c.x = o, c.y = a, o = l, a = u; t[0].x = e, t[0].y = i; } else o = t[0].x, a = t[0].y, t[0].x = e, t[0].y = i; return r.x = o, r.y = a, r; }; }, function (t, e, i) { const n = i(25); t.exports = function (t, e, i, s, r) { return n(t, 'y', e, i, s, r); }; }, function (t, e, i) { const n = i(25); t.exports = function (t, e, i, s, r, o, a) { return void 0 !== i && i !== null || (i = e), n(t, 'x', e, s, o, a), n(t, 'y', i, r, o, a); }; }, function (t, e, i) { const n = i(25); t.exports = function (t, e, i, s, r) { return n(t, 'x', e, i, s, r); }; }, function (t, e, i) { const n = i(25); t.exports = function (t, e, i, s) { return n(t, 'visible', e, 0, i, s); }; }, function (t, e) { t.exports = function (t, e, i, n, s) { for (let r = 0; r < t.length; r++)t[r].setTint(e, i, n, s); return t; }; }, function (t, e, i) { const n = i(25); t.exports = function (t, e, i, s, r) { return n(t, 'scaleY', e, i, s, r); }; }, function (t, e, i) { const n = i(25); t.exports = function (t, e, i, s, r) { return n(t, 'scaleX', e, i, s, r); }; }, function (t, e, i) { const n = i(25); t.exports = function (t, e, i, s, r, o, a) { return void 0 !== i && i !== null || (i = e), n(t, 'scaleX', e, s, o, a), n(t, 'scaleY', i, r, o, a); }; }, function (t, e, i) { const n = i(25); t.exports = function (t, e, i, s, r) { return n(t, 'rotation', e, i, s, r); }; }, function (t, e, i) { const n = i(25); t.exports = function (t, e, i, s, r, o, a) { return void 0 !== i && i !== null || (i = e), n(t, 'originX', e, s, o, a), n(t, 'originY', i, r, o, a); }; }, function (t, e) { t.exports = function (t, e, i) { for (let n = 0; n < t.length; n++)t[n].setInteractive(e, i); return t; }; }, function (t, e, i) { const n = i(25); t.exports = function (t, e, i, s, r) { return n(t, 'depth', e, i, s, r); }; }, function (t, e, i) { const n = i(25); t.exports = function (t, e, i, s) { return n(t, 'blendMode', e, 0, i, s); }; }, function (t, e, i) { const n = i(25); t.exports = function (t, e, i, s, r) { return n(t, 'alpha', e, i, s, r); }; }, function (t, e, i) { const n = i(32); t.exports = function (t, e, i, s, r) { return n(t, 'scaleY', e, i, s, r); }; }, function (t, e, i) { const n = i(32); t.exports = function (t, e, i, s, r, o, a) { return void 0 !== i && i !== null || (i = e), n(t, 'scaleX', e, s, o, a), n(t, 'scaleY', i, r, o, a); }; }, function (t, e, i) { const n = i(32); t.exports = function (t, e, i, s, r) { return n(t, 'scaleX', e, i, s, r); }; }, function (t, e, i) { const n = i(183); t.exports = function (t, e, i, s) { const r = e.x; const o = e.y; if (s === 0) return t; for (let a = 0; a < t.length; a++)n(t[a], r, o, i, s); return t; }; }, function (t, e, i) { const n = i(183); const s = i(52); t.exports = function (t, e, i) { for (let r = e.x, o = e.y, a = 0; a < t.length; a++) { const h = t[a]; n(h, r, o, i, Math.max(1, s(h.x, h.y, r, o))); } return t; }; }, function (t, e, i) { const n = i(32); t.exports = function (t, e, i, s, r) { return n(t, 'rotation', e, i, s, r); }; }, function (t, e, i) { const n = i(184); t.exports = function (t, e) { for (let i = 0; i < t.length; i++)n(e, t[i]); return t; }; }, function (t, e, i) { const n = i(187); t.exports = function (t, e) { for (let i = 0; i < t.length; i++)n(e, t[i]); return t; }; }, function (t, e, i) { const n = i(188); t.exports = function (t, e) { for (let i = 0; i < t.length; i++)n(e, t[i]); return t; }; }, function (t, e, i) { const n = i(185); t.exports = function (t, e) { for (let i = 0; i < t.length; i++)n(e, t[i]); return t; }; }, function (t, e, i) { const n = i(191); t.exports = function (t, e) { for (let i = 0; i < t.length; i++)n(e, t[i]); return t; }; }, function (t, e) { t.exports = function (t, e, i) { for (let n = 0; n < t.length; n++)t[n].anims.play(e, i); return t; }; }, function (t, e, i) {
  const n = i(385); t.exports = function (t, e, i) {
    let s = n({
      x1: e.x1, y1: e.y1, x2: e.x2, y2: e.y2,
    }, i); const r = n({
      x1: e.x2, y1: e.y2, x2: e.x3, y2: e.y3,
    }, i); const o = n({
      x1: e.x3, y1: e.y3, x2: e.x1, y2: e.y1,
    }, i); s.pop(), r.pop(), o.pop(); for (let a = (s = s.concat(r, o)).length / t.length, h = 0, l = 0; l < t.length; l++) { const u = t[l]; const c = s[Math.floor(h)]; u.x = c.x, u.y = c.y, h += a; } return t;
  };
}, function (t, e, i) { const n = i(388); const s = i(387); const r = i(386); t.exports = function (t, e, i) { void 0 === i && (i = 0); const o = n(e, !1, t.length); i > 0 ? s(o, i) : i < 0 && r(o, Math.abs(i)); for (let a = 0; a < t.length; a++)t[a].x = o[a].x, t[a].y = o[a].y; return t; }; }, function (t, e, i) { const n = i(189); t.exports = function (t, e) { for (let i = n(e, t.length), s = 0; s < t.length; s++) { const r = t[s]; const o = i[s]; r.x = o.x, r.y = o.y; } return t; }; }, function (t, e) { t.exports = function (t, e, i, n) { void 0 === i && (i = 0), void 0 === n && (n = 6.28); for (let s = i, r = (n - i) / t.length, o = e.width / 2, a = e.height / 2, h = 0; h < t.length; h++)t[h].x = e.x + o * Math.cos(s), t[h].y = e.y + a * Math.sin(s), s += r; return t; }; }, function (t, e) { t.exports = function (t, e, i, n) { void 0 === i && (i = 0), void 0 === n && (n = 6.28); for (let s = i, r = (n - i) / t.length, o = 0; o < t.length; o++)t[o].x = e.x + e.radius * Math.cos(s), t[o].y = e.y + e.radius * Math.sin(s), s += r; return t; }; }, function (t, e, i) { const n = i(32); t.exports = function (t, e, i, s, r) { return n(t, 'y', e, i, s, r); }; }, function (t, e, i) { const n = i(32); t.exports = function (t, e, i, s, r, o, a) { return void 0 !== i && i !== null || (i = e), n(t, 'x', e, s, o, a), n(t, 'y', i, r, o, a); }; }, function (t, e, i) { const n = i(32); t.exports = function (t, e, i, s, r) { return n(t, 'x', e, i, s, r); }; }, function (t, e, i) { const n = i(32); t.exports = function (t, e, i, s, r) { return n(t, 'alpha', e, i, s, r); }; }, function (t, e) {
  const i = function (t) { return (t >> 16) + (65280 & t) + ((255 & t) << 16); }; const n = {
    _tintTL: 16777215, _tintTR: 16777215, _tintBL: 16777215, _tintBR: 16777215, _isTinted: !1, tintFill: !1, clearTint() { return this.setTint(16777215), this._isTinted = !1, this; }, setTint(t, e, n, s) { return void 0 === t && (t = 16777215), void 0 === e && (e = t, n = t, s = t), this._tintTL = i(t), this._tintTR = i(e), this._tintBL = i(n), this._tintBR = i(s), this._isTinted = !0, this.tintFill = !1, this; }, setTintFill(t, e, i, n) { return this.setTint(t, e, i, n), this.tintFill = !0, this; }, tintTopLeft: { get() { return this._tintTL; }, set(t) { this._tintTL = i(t), this._isTinted = !0; } }, tintTopRight: { get() { return this._tintTR; }, set(t) { this._tintTR = i(t), this._isTinted = !0; } }, tintBottomLeft: { get() { return this._tintBL; }, set(t) { this._tintBL = i(t), this._isTinted = !0; } }, tintBottomRight: { get() { return this._tintBR; }, set(t) { this._tintBR = i(t), this._isTinted = !0; } }, tint: { set(t) { this.setTint(t, t, t, t); } }, isTinted: { get() { return this._isTinted; } },
  }; t.exports = n;
}, function (t, e) {
  const i = {
    texture: null,
    frame: null,
    isCropped: !1,
    setCrop(t, e, i, n) { if (void 0 === t) this.isCropped = !1; else if (this.frame) { if (typeof t === 'number') this.frame.setCropUVs(this._crop, t, e, i, n, this.flipX, this.flipY); else { const s = t; this.frame.setCropUVs(this._crop, s.x, s.y, s.width, s.height, this.flipX, this.flipY); } this.isCropped = !0; } return this; },
    setTexture(t, e) { return this.texture = this.scene.sys.textures.get(t), this.setFrame(e); },
    setFrame(t, e, i) { return void 0 === e && (e = !0), void 0 === i && (i = !0), this.frame = this.texture.get(t), this.frame.cutWidth && this.frame.cutHeight ? this.renderFlags |= 8 : this.renderFlags &= -9, this._sizeComponent && e && this.setSizeToFrame(), this._originComponent && i && (this.frame.customPivot ? this.setOrigin(this.frame.pivotX, this.frame.pivotY) : this.updateDisplayOrigin()), this.isCropped && this.frame.updateCropUVs(this._crop, this.flipX, this.flipY), this; },
    resetCropObject() {
      return {
        u0: 0, v0: 0, u1: 0, v1: 0, width: 0, height: 0, x: 0, y: 0, flipX: !1, flipY: !1, cx: 0, cy: 0, cw: 0, ch: 0,
      };
    },
  }; t.exports = i;
}, function (t, e) {
  const i = {
    texture: null, frame: null, isCropped: !1, setTexture(t, e) { return this.texture = this.scene.sys.textures.get(t), this.setFrame(e); }, setFrame(t, e, i) { return void 0 === e && (e = !0), void 0 === i && (i = !0), this.frame = this.texture.get(t), this.frame.cutWidth && this.frame.cutHeight ? this.renderFlags |= 8 : this.renderFlags &= -9, this._sizeComponent && e && this.setSizeToFrame(), this._originComponent && i && (this.frame.customPivot ? this.setOrigin(this.frame.pivotX, this.frame.pivotY) : this.updateDisplayOrigin()), this; },
  }; t.exports = i;
}, function (t, e) {
  const i = {
    _sizeComponent: !0, width: 0, height: 0, displayWidth: { get() { return this.scaleX * this.frame.realWidth; }, set(t) { this.scaleX = t / this.frame.realWidth; } }, displayHeight: { get() { return this.scaleY * this.frame.realHeight; }, set(t) { this.scaleY = t / this.frame.realHeight; } }, setSizeToFrame(t) { return void 0 === t && (t = this.frame), this.width = t.realWidth, this.height = t.realHeight, this; }, setSize(t, e) { return this.width = t, this.height = e, this; }, setDisplaySize(t, e) { return this.displayWidth = t, this.displayHeight = e, this; },
  }; t.exports = i;
}, function (t, e, i) { const n = i(94); const s = { _scaleMode: n.DEFAULT, scaleMode: { get() { return this._scaleMode; }, set(t) { t !== n.LINEAR && t !== n.NEAREST || (this._scaleMode = t); } }, setScaleMode(t) { return this.scaleMode = t, this; } }; t.exports = s; }, function (t, e) {
  const i = {
    _originComponent: !0, originX: 0.5, originY: 0.5, _displayOriginX: 0, _displayOriginY: 0, displayOriginX: { get() { return this._displayOriginX; }, set(t) { this._displayOriginX = t, this.originX = t / this.width; } }, displayOriginY: { get() { return this._displayOriginY; }, set(t) { this._displayOriginY = t, this.originY = t / this.height; } }, setOrigin(t, e) { return void 0 === t && (t = 0.5), void 0 === e && (e = t), this.originX = t, this.originY = e, this.updateDisplayOrigin(); }, setOriginFromFrame() { return this.frame && this.frame.customPivot ? (this.originX = this.frame.pivotX, this.originY = this.frame.pivotY, this.updateDisplayOrigin()) : this.setOrigin(); }, setDisplayOrigin(t, e) { return void 0 === t && (t = 0), void 0 === e && (e = t), this.displayOriginX = t, this.displayOriginY = e, this; }, updateDisplayOrigin() { return this._displayOriginX = Math.round(this.originX * this.width), this._displayOriginY = Math.round(this.originY * this.height), this; },
  }; t.exports = i;
}, function (t, e, i) {
  const n = i(9); const s = i(396); const r = i(3); const o = {
    getCenter(t) { return void 0 === t && (t = new r()), t.x = this.x - this.displayWidth * this.originX + this.displayWidth / 2, t.y = this.y - this.displayHeight * this.originY + this.displayHeight / 2, t; }, getTopLeft(t, e) { (t || (t = new r()), void 0 === e && (e = !1), t.x = this.x - this.displayWidth * this.originX, t.y = this.y - this.displayHeight * this.originY, this.rotation !== 0 && s(t, this.x, this.y, this.rotation), e && this.parentContainer) && this.parentContainer.getBoundsTransformMatrix().transformPoint(t.x, t.y, t); return t; }, getTopRight(t, e) { (t || (t = new r()), void 0 === e && (e = !1), t.x = this.x - this.displayWidth * this.originX + this.displayWidth, t.y = this.y - this.displayHeight * this.originY, this.rotation !== 0 && s(t, this.x, this.y, this.rotation), e && this.parentContainer) && this.parentContainer.getBoundsTransformMatrix().transformPoint(t.x, t.y, t); return t; }, getBottomLeft(t, e) { (t || (t = new r()), void 0 === e && (e = !1), t.x = this.x - this.displayWidth * this.originX, t.y = this.y - this.displayHeight * this.originY + this.displayHeight, this.rotation !== 0 && s(t, this.x, this.y, this.rotation), e && this.parentContainer) && this.parentContainer.getBoundsTransformMatrix().transformPoint(t.x, t.y, t); return t; }, getBottomRight(t, e) { (t || (t = new r()), void 0 === e && (e = !1), t.x = this.x - this.displayWidth * this.originX + this.displayWidth, t.y = this.y - this.displayHeight * this.originY + this.displayHeight, this.rotation !== 0 && s(t, this.x, this.y, this.rotation), e && this.parentContainer) && this.parentContainer.getBoundsTransformMatrix().transformPoint(t.x, t.y, t); return t; }, getBounds(t) { let e; let i; let s; let r; let o; let a; let h; let l; if (void 0 === t && (t = new n()), this.parentContainer) { const u = this.parentContainer.getBoundsTransformMatrix(); this.getTopLeft(t), u.transformPoint(t.x, t.y, t), e = t.x, i = t.y, this.getTopRight(t), u.transformPoint(t.x, t.y, t), s = t.x, r = t.y, this.getBottomLeft(t), u.transformPoint(t.x, t.y, t), o = t.x, a = t.y, this.getBottomRight(t), u.transformPoint(t.x, t.y, t), h = t.x, l = t.y; } else this.getTopLeft(t), e = t.x, i = t.y, this.getTopRight(t), s = t.x, r = t.y, this.getBottomLeft(t), o = t.x, a = t.y, this.getBottomRight(t), h = t.x, l = t.y; return t.x = Math.min(e, s, o, h), t.y = Math.min(i, r, a, l), t.width = Math.max(e, s, o, h) - t.x, t.height = Math.max(i, r, a, l) - t.y, t; },
  }; t.exports = o;
}, function (t, e) {
  t.exports = {
    flipX: !1, flipY: !1, toggleFlipX() { return this.flipX = !this.flipX, this; }, toggleFlipY() { return this.flipY = !this.flipY, this; }, setFlipX(t) { return this.flipX = t, this; }, setFlipY(t) { return this.flipY = t, this; }, setFlip(t, e) { return this.flipX = t, this.flipY = e, this; }, resetFlip() { return this.flipX = !1, this.flipY = !1, this; },
  };
}, function (t, e) {
  const i = {
    texture: null,
    frame: null,
    isCropped: !1,
    setCrop(t, e, i, n) { if (void 0 === t) this.isCropped = !1; else if (this.frame) { if (typeof t === 'number') this.frame.setCropUVs(this._crop, t, e, i, n, this.flipX, this.flipY); else { const s = t; this.frame.setCropUVs(this._crop, s.x, s.y, s.width, s.height, this.flipX, this.flipY); } this.isCropped = !0; } return this; },
    resetCropObject() {
      return {
        u0: 0, v0: 0, u1: 0, v1: 0, width: 0, height: 0, x: 0, y: 0, flipX: !1, flipY: !1, cx: 0, cy: 0, cw: 0, ch: 0,
      };
    },
  }; t.exports = i;
}, function (t, e) {
  t.exports = {
    width: 0, height: 0, displayWidth: { get() { return this.scaleX * this.width; }, set(t) { this.scaleX = t / this.width; } }, displayHeight: { get() { return this.scaleY * this.height; }, set(t) { this.scaleY = t / this.height; } }, setSize(t, e) { return this.width = t, this.height = e, this; }, setDisplaySize(t, e) { return this.displayWidth = t, this.displayHeight = e, this; },
  };
}, function (t, e, i) { const n = i(416); const s = i(193); const r = i(2); const o = i(1); const a = new (i(125))({ sys: { queueDepthSort: o, events: { once: o } } }, 0, 0, 1, 1); t.exports = function (t, e) { void 0 === e && (e = {}); const i = r(e, 'width', -1); const o = r(e, 'height', -1); const h = r(e, 'cellWidth', 1); const l = r(e, 'cellHeight', h); const u = r(e, 'position', s.TOP_LEFT); const c = r(e, 'x', 0); const d = r(e, 'y', 0); let f = 0; let p = 0; const g = i * h; const v = o * l; a.setPosition(c, d), a.setSize(h, l); for (let y = 0; y < t.length; y++) if (n(t[y], a, u), i === -1)p += l, a.y += l, p === v && (p = 0, a.x += h, a.y = d); else if (o === -1)f += h, a.x += h, f === g && (f = 0, a.x = c, a.y += l); else if (f += h, a.x += h, f === g && (f = 0, p += l, a.x = c, a.y += l, p === v)) break; return t; }; }, function (t, e) { t.exports = function (t, e, i) { void 0 === i && (i = 0); for (let n = i; n < t.length; n++) { const s = t[n]; let r = !0; for (const o in e)s[o] !== e[o] && (r = !1); if (r) return s; } return null; }; }, function (t, e) { t.exports = function (t, e, i) { void 0 === i && (i = 0); for (let n = i; n < t.length; n++) { const s = t[n]; let r = !0; for (const o in e)s[o] !== e[o] && (r = !1); if (r) return s; } return null; }; }, function (t, e) { t.exports = function (t, e, i) { for (let n = 0; n < t.length; n++) { const s = t[n]; e.call(i, s); } return t; }; }, function (t, e, i) { const n = i(32); t.exports = function (t, e, i, s, r) { return n(t, 'angle', e, i, s, r); }; }, function (t, e) { if (typeof window.Uint32Array !== 'function' && typeof window.Uint32Array !== 'object') { const i = function (t) { const e = new Array(); window[t] = function (t) { if (typeof t === 'number') { Array.call(this, t), this.length = t; for (var e = 0; e < this.length; e++) this[e] = 0; } else { Array.call(this, t.length), this.length = t.length; for (e = 0; e < this.length; e++) this[e] = t[e]; } }, window[t].prototype = e, window[t].constructor = window[t]; }; i('Float32Array'), i('Uint32Array'), i('Uint16Array'), i('Int16Array'), i('ArrayBuffer'); } }, function (t, e, i) { (function (t) { if (Date.now && Date.prototype.getTime || (Date.now = function () { return (new Date()).getTime(); }), !t.performance || !t.performance.now) { const e = Date.now(); t.performance || (t.performance = {}), t.performance.now = function () { return Date.now() - e; }; } for (var i = Date.now(), n = ['ms', 'moz', 'webkit', 'o'], s = 0; s < n.length && !t.requestAnimationFrame; ++s)t.requestAnimationFrame = t[`${n[s]}RequestAnimationFrame`], t.cancelAnimationFrame = t[`${n[s]}CancelAnimationFrame`] || t[`${n[s]}CancelRequestAnimationFrame`]; t.requestAnimationFrame || (t.requestAnimationFrame = function (t) { if (typeof t !== 'function') throw new TypeError(`${t}is not a function`); const e = Date.now(); let n = 16 + i - e; return n < 0 && (n = 0), i = e, setTimeout(() => { i = Date.now(), t(performance.now()); }, n); }), t.cancelAnimationFrame || (t.cancelAnimationFrame = function (t) { clearTimeout(t); }); }).call(this, i(200)); }, function (t, e) { !(function () { if ('performance' in window == !1 && (window.performance = {}), Date.now = Date.now || function () { return (new Date()).getTime(); }, 'now' in window.performance == !1) { let t = Date.now(); performance.timing && performance.timing.navigationStart && (t = performance.timing.navigationStart), window.performance.now = function () { return Date.now() - t; }; } }()); }, function (t, e) { Math.trunc || (Math.trunc = function (t) { return t < 0 ? Math.ceil(t) : Math.floor(t); }); }, function (t, e) { window.console || (window.console = {}, window.console.log = window.console.assert = function () {}, window.console.warn = window.console.assert = function () {}); }, function (t, e) { !(function () { function t(t) { t && (t.setTargetAtTime || (t.setTargetAtTime = t.setTargetValueAtTime)); }window.hasOwnProperty('webkitAudioContext') && !window.hasOwnProperty('AudioContext') && (window.AudioContext = webkitAudioContext, AudioContext.prototype.hasOwnProperty('createGain') || (AudioContext.prototype.createGain = AudioContext.prototype.createGainNode), AudioContext.prototype.hasOwnProperty('createDelay') || (AudioContext.prototype.createDelay = AudioContext.prototype.createDelayNode), AudioContext.prototype.hasOwnProperty('createScriptProcessor') || (AudioContext.prototype.createScriptProcessor = AudioContext.prototype.createJavaScriptNode), AudioContext.prototype.hasOwnProperty('createPeriodicWave') || (AudioContext.prototype.createPeriodicWave = AudioContext.prototype.createWaveTable), AudioContext.prototype.internal_createGain = AudioContext.prototype.createGain, AudioContext.prototype.createGain = function () { const e = this.internal_createGain(); return t(e.gain), e; }, AudioContext.prototype.internal_createDelay = AudioContext.prototype.createDelay, AudioContext.prototype.createDelay = function (e) { const i = e ? this.internal_createDelay(e) : this.internal_createDelay(); return t(i.delayTime), i; }, AudioContext.prototype.internal_createBufferSource = AudioContext.prototype.createBufferSource, AudioContext.prototype.createBufferSource = function () { const e = this.internal_createBufferSource(); return e.start ? (e.internal_start = e.start, e.start = function (t, i, n) { void 0 !== n ? e.internal_start(t || 0, i, n) : e.internal_start(t || 0, i || 0); }) : e.start = function (t, e, i) { e || i ? this.noteGrainOn(t || 0, e, i) : this.noteOn(t || 0); }, e.stop ? (e.internal_stop = e.stop, e.stop = function (t) { e.internal_stop(t || 0); }) : e.stop = function (t) { this.noteOff(t || 0); }, t(e.playbackRate), e; }, AudioContext.prototype.internal_createDynamicsCompressor = AudioContext.prototype.createDynamicsCompressor, AudioContext.prototype.createDynamicsCompressor = function () { const e = this.internal_createDynamicsCompressor(); return t(e.threshold), t(e.knee), t(e.ratio), t(e.reduction), t(e.attack), t(e.release), e; }, AudioContext.prototype.internal_createBiquadFilter = AudioContext.prototype.createBiquadFilter, AudioContext.prototype.createBiquadFilter = function () { const e = this.internal_createBiquadFilter(); return t(e.frequency), t(e.detune), t(e.Q), t(e.gain), e; }, AudioContext.prototype.hasOwnProperty('createOscillator') && (AudioContext.prototype.internal_createOscillator = AudioContext.prototype.createOscillator, AudioContext.prototype.createOscillator = function () { const e = this.internal_createOscillator(); return e.start ? (e.internal_start = e.start, e.start = function (t) { e.internal_start(t || 0); }) : e.start = function (t) { this.noteOn(t || 0); }, e.stop ? (e.internal_stop = e.stop, e.stop = function (t) { e.internal_stop(t || 0); }) : e.stop = function (t) { this.noteOff(t || 0); }, e.setPeriodicWave || (e.setPeriodicWave = e.setWaveTable), t(e.frequency), t(e.detune), e; })), window.hasOwnProperty('webkitOfflineAudioContext') && !window.hasOwnProperty('OfflineAudioContext') && (window.OfflineAudioContext = webkitOfflineAudioContext); }()); }, function (t, e) { Array.isArray || (Array.isArray = function (t) { return Object.prototype.toString.call(t) === '[object Array]'; }); }, function (t, e) {
  Array.prototype.forEach || (Array.prototype.forEach = function (t) {
    if (void 0 === this || this === null) throw new TypeError(); const e = Object(this); const i = e.length >>> 0; if (typeof t !== 'function') throw new TypeError(); for (let n = arguments.length >= 2 ? arguments[1] : void 0, s = 0; s < i; s++)s in e && t.call(n, e[s], s, e);
  });
}, function (t, e, i) { i(1058), i(1057), i(1056), i(1055), i(1054), i(1053), i(1052), i(1051); }, function (t, e, i) {
  const n = i(126); const s = i(0); const r = i(33); const o = i(137); const a = i(1061); const h = i(11); const l = i(2); const u = i(4); const c = i(67); const d = i(195); const f = i(504); const p = i(499); const g = i(81); const v = new s({
    Extends: h,
    initialize(t, e) {
      h.call(this), this.scene = t, this.engine = a.create(e), this.localWorld = this.engine.world; const i = u(e, 'gravity', null); if (i && this.setGravity(i.x, i.y, i.scale), this.walls = {
        left: null, right: null, top: null, bottom: null,
      }, l(e, 'setBounds', !1)) { const n = e.setBounds; if (typeof n === 'boolean') this.setBounds(); else { const s = l(n, 'x', 0); const r = l(n, 'y', 0); const o = l(n, 'width', t.sys.game.config.width); const c = l(n, 'height', t.sys.game.config.height); const d = l(n, 'thickness', 64); const f = l(n, 'left', !0); const p = l(n, 'right', !0); const g = l(n, 'top', !0); const v = l(n, 'bottom', !0); this.setBounds(s, r, o, c, d, f, p, g, v); } } this.enabled = u(e, 'enabled', !0), this.correction = u(e, 'correction', 1), this.getDelta = u(e, 'getDelta', this.update60Hz), this.autoUpdate = u(e, 'autoUpdate', !0), this.drawDebug = u(e, 'debug', !1), this.debugGraphic, this.defaults = {
        debugShowBody: l(e, 'debugShowBody', !0), debugShowStaticBody: l(e, 'debugShowStaticBody', !0), debugShowVelocity: l(e, 'debugShowVelocity', !0), bodyDebugColor: l(e, 'debugBodyColor', 16711935), bodyDebugFillColor: l(e, 'bodyDebugFillColor', 14919651), staticBodyDebugColor: l(e, 'debugBodyColor', 255), velocityDebugColor: l(e, 'debugVelocityColor', 65280), debugShowJoint: l(e, 'debugShowJoint', !0), jointDebugColor: l(e, 'debugJointColor', 0), debugWireframes: l(e, 'debugWireframes', !0), debugShowInternalEdges: l(e, 'debugShowInternalEdges', !1), debugShowConvexHulls: l(e, 'debugShowConvexHulls', !1), debugConvexHullColor: l(e, 'debugConvexHullColor', 11184810), debugShowSleeping: l(e, 'debugShowSleeping', !1),
      }, this.drawDebug && this.createDebugGraphic(), this.setEventsProxy();
    },
    setEventsProxy() { const t = this; const e = this.engine; d.on(e, 'beforeUpdate', (e) => { t.emit('beforeupdate', e); }), d.on(e, 'afterUpdate', (e) => { t.emit('afterupdate', e); }), d.on(e, 'collisionStart', (e) => { let i; let n; const s = e.pairs; s.length > 0 && (i = s[0].bodyA, n = s[0].bodyB), t.emit('collisionstart', e, i, n); }), d.on(e, 'collisionActive', (e) => { let i; let n; const s = e.pairs; s.length > 0 && (i = s[0].bodyA, n = s[0].bodyB), t.emit('collisionactive', e, i, n); }), d.on(e, 'collisionEnd', (e) => { let i; let n; const s = e.pairs; s.length > 0 && (i = s[0].bodyA, n = s[0].bodyB), t.emit('collisionend', e, i, n); }); },
    setBounds(t, e, i, n, s, r, o, a, h) { return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = this.scene.sys.game.config.width), void 0 === n && (n = this.scene.sys.game.config.height), void 0 === s && (s = 128), void 0 === r && (r = !0), void 0 === o && (o = !0), void 0 === a && (a = !0), void 0 === h && (h = !0), this.updateWall(r, 'left', t - s, e, s, n), this.updateWall(o, 'right', t + i, e, s, n), this.updateWall(a, 'top', t, e - s, i, s), this.updateWall(h, 'bottom', t, e + n, i, s), this; },
    updateWall(t, e, i, n, s, r) { const o = this.walls[e]; t ? (o && p.remove(this.localWorld, o), i += s / 2, n += r / 2, this.walls[e] = this.create(i, n, s, r, { isStatic: !0, friction: 0, frictionStatic: 0 })) : (o && p.remove(this.localWorld, o), this.walls[e] = null); },
    createDebugGraphic() { const t = this.scene.sys.add.graphics({ x: 0, y: 0 }); return t.setDepth(Number.MAX_VALUE), this.debugGraphic = t, this.drawDebug = !0, t; },
    disableGravity() { return this.localWorld.gravity.x = 0, this.localWorld.gravity.y = 0, this.localWorld.gravity.scale = 0, this; },
    setGravity(t, e, i) { return void 0 === t && (t = 0), void 0 === e && (e = 1), this.localWorld.gravity.x = t, this.localWorld.gravity.y = e, void 0 !== i && (this.localWorld.gravity.scale = i), this; },
    create(t, e, i, s, r) { const o = n.rectangle(t, e, i, s, r); return p.add(this.localWorld, o), o; },
    add(t) { return p.add(this.localWorld, t), this; },
    remove(t, e) { const i = t.body ? t.body : t; return o.removeBody(this.localWorld, i, e), this; },
    removeConstraint(t, e) { return o.remove(this.localWorld, t, e), this; },
    convertTilemapLayer(t, e) { const i = t.layer; const n = t.getTilesWithin(0, 0, i.width, i.height, { isColliding: !0 }); return this.convertTiles(n, e), this; },
    convertTiles(t, e) { if (t.length === 0) return this; for (let i = 0; i < t.length; i++) new f(this, t[i], e); return this; },
    nextGroup(t) { return c.nextGroup(t); },
    nextCategory() { return c.nextCategory(); },
    pause() { return this.enabled = !1, this.emit('pause'), this; },
    resume() { return this.enabled = !0, this.emit('resume'), this; },
    update(t, e) { this.enabled && this.autoUpdate && a.update(this.engine, this.getDelta(t, e), this.correction); },
    step(t, e) { a.update(this.engine, t, e); },
    update60Hz() { return 1e3 / 60; },
    update30Hz() { return 1e3 / 30; },
    postUpdate() { if (this.drawDebug) { this.debugGraphic.clear(); const t = o.allBodies(this.localWorld); this.defaults.debugWireframes ? (this.defaults.debugShowConvexHulls && this.renderConvexHulls(t), this.renderWireframes(t)) : this.renderBodies(t), this.defaults.debugShowJoint && this.renderJoints(); } },
    renderConvexHulls(t) { const e = this.debugGraphic; e.lineStyle(1, this.defaults.debugConvexHullColor), e.beginPath(); for (let i = 0; i < t.length; i++) { const n = t[i]; if (n.render.visible && n.parts.length !== 1) { e.moveTo(n.vertices[0].x, n.vertices[0].y); for (let s = 1; s < n.vertices.length; s++)e.lineTo(n.vertices[s].x, n.vertices[s].y); e.lineTo(n.vertices[0].x, n.vertices[0].y); } }e.strokePath(); },
    renderWireframes(t) { const e = this.debugGraphic; const i = this.defaults.debugShowInternalEdges; e.lineStyle(1, this.defaults.bodyDebugColor), e.beginPath(); for (let n = 0; n < t.length; n++) { const s = t[n]; if (s.render.visible) for (let r = s.parts.length > 1 ? 1 : 0; r < s.parts.length; r++) { const o = s.parts[r]; const a = o.vertices.length; e.moveTo(o.vertices[0].x, o.vertices[0].y); for (let h = 1; h < a; h++)!o.vertices[h - 1].isInternal || i ? e.lineTo(o.vertices[h].x, o.vertices[h].y) : e.moveTo(o.vertices[h].x, o.vertices[h].y), o.vertices[h].isInternal && !i && e.moveTo(o.vertices[(h + 1) % a].x, o.vertices[(h + 1) % a].y); e.lineTo(o.vertices[0].x, o.vertices[0].y); } }e.strokePath(); },
    renderBodies(t) { let e; let i; let n; let s; const r = this.debugGraphic; const o = this.defaults.debugShowInternalEdges || !this.defaults.debugWireframes; const a = this.defaults.debugShowSleeping; const h = this.defaults.debugWireframes; for (n = 0; n < t.length; n++) if ((e = t[n]).render.visible) for (s = e.parts.length > 1 ? 1 : 0; s < e.parts.length; s++) if ((i = e.parts[s]).render.visible) { if (a && e.isSleeping ? (r.lineStyle(1, this.defaults.bodyDebugColor, 0.5 * i.render.opacity), r.fillStyle(this.defaults.bodyDebugColor, 0.5 * i.render.opacity)) : (r.lineStyle(1, this.defaults.bodyDebugColor, i.render.opacity), r.fillStyle(this.defaults.bodyDebugColor, i.render.opacity)), i.circleRadius)r.beginPath(), r.arc(i.position.x, i.position.y, i.circleRadius, 0, 2 * Math.PI); else { r.beginPath(), r.moveTo(i.vertices[0].x, i.vertices[0].y); for (let l = i.vertices.length, u = 1; u < l; u++)!i.vertices[u - 1].isInternal || o ? r.lineTo(i.vertices[u].x, i.vertices[u].y) : r.moveTo(i.vertices[u].x, i.vertices[u].y), i.vertices[u].isInternal && !o && r.moveTo(i.vertices[(u + 1) % i.vertices.length].x, i.vertices[(u + 1) % i.vertices.length].y); r.lineTo(i.vertices[0].x, i.vertices[0].y), r.closePath(); }h ? r.strokePath() : r.fillPath(); } },
    renderJoints() { const t = this.debugGraphic; t.lineStyle(2, this.defaults.jointDebugColor); for (let e = o.allConstraints(this.localWorld), i = 0; i < e.length; i++) { const n = e[i]; if (n.render.visible && n.pointA && n.pointB) { n.render.lineWidth && t.lineStyle(n.render.lineWidth, r.colorToNumber(n.render.strokeStyle)); var s; var a; const h = n.bodyA; const l = n.bodyB; if (s = h ? g.add(h.position, n.pointA) : n.pointA, n.render.type === 'pin')t.beginPath(), t.arc(s.x, s.y, 3, 0, 2 * Math.PI), t.closePath(); else { if (a = l ? g.add(l.position, n.pointB) : n.pointB, t.beginPath(), t.moveTo(s.x, s.y), n.render.type === 'spring') for (var u, c = g.sub(a, s), d = g.perp(g.normalise(c)), f = Math.ceil(r.clamp(n.length / 5, 12, 20)), p = 1; p < f; p += 1)u = p % 2 == 0 ? 1 : -1, t.lineTo(s.x + c.x * (p / f) + d.x * u * 4, s.y + c.y * (p / f) + d.y * u * 4); t.lineTo(a.x, a.y); }n.render.lineWidth && t.strokePath(), n.render.anchors && (t.fillStyle(r.colorToNumber(n.render.strokeStyle)), t.beginPath(), t.arc(s.x, s.y, 6, 0, 2 * Math.PI), t.arc(a.x, a.y, 6, 0, 2 * Math.PI), t.closePath(), t.fillPath()); } } },
    fromPath(t, e) { void 0 === e && (e = []); return t.replace(/L?\s*([\-\d\.e]+)[\s,]*([\-\d\.e]+)*/gi, (t, i, n) => { e.push({ x: parseFloat(i), y: parseFloat(n) }); }), e; },
    shutdown() { d.off(this.engine), this.removeAllListeners(), p.clear(this.localWorld, !1), a.clear(this.engine), this.drawDebug && this.debugGraphic.destroy(); },
    destroy() { this.shutdown(); },
  }); t.exports = v;
}, function (t, e, i) {
  const n = {}; t.exports = n; const s = i(499); const r = i(222); const o = i(1062); const a = i(1063); const h = i(1088); const l = i(1064); const u = i(195); const c = i(137); const d = i(194); const f = i(33); const p = i(67); n.create = function (t, e) {
    e = f.isElement(t) ? e : t, t = f.isElement(t) ? t : null, e = e || {}, (t || e.render) && f.warn('Engine.create: engine.render is deprecated (see docs)'); const i = {
      positionIterations: 6, velocityIterations: 4, constraintIterations: 2, enableSleeping: !1, events: [], plugin: {}, timing: { timestamp: 0, timeScale: 1 }, broadphase: { controller: l },
    }; const n = f.extend(i, e); if (t || n.render) { const r = { element: t, controller: Render }; n.render = f.extend(r, n.render); } return n.render && n.render.controller && (n.render = n.render.controller.create(n.render)), n.render && (n.render.engine = n), n.world = e.world || s.create(n.world), n.pairs = a.create(), n.broadphase = n.broadphase.controller.create(n.broadphase), n.metrics = n.metrics || { extended: !1 }, n.metrics = h.create(n.metrics), n;
  }, n.update = function (t, e, i) { e = e || 1e3 / 60, i = i || 1; let s; const l = t.world; const f = t.timing; const p = t.broadphase; let g = []; f.timestamp += e * f.timeScale; const v = { timestamp: f.timestamp }; u.trigger(t, 'beforeUpdate', v); const y = c.allBodies(l); const m = c.allConstraints(l); for (h.reset(t.metrics), t.enableSleeping && r.update(y, f.timeScale), n._bodiesApplyGravity(y, l.gravity), n._bodiesUpdate(y, e, f.timeScale, i, l.bounds), d.preSolveAll(y), s = 0; s < t.constraintIterations; s++)d.solveAll(m, f.timeScale); d.postSolveAll(y), p.controller ? (l.isModified && p.controller.clear(p), p.controller.update(p, y, t, l.isModified), g = p.pairsList) : g = y, l.isModified && c.setModified(l, !1, !1, !0); const x = p.detector(g, t); const w = t.pairs; const b = f.timestamp; for (a.update(w, x, b), a.removeOld(w, b), t.enableSleeping && r.afterCollisions(w.list, f.timeScale), w.collisionStart.length > 0 && u.trigger(t, 'collisionStart', { pairs: w.collisionStart }), o.preSolvePosition(w.list), s = 0; s < t.positionIterations; s++)o.solvePosition(w.list, y, f.timeScale); for (o.postSolvePosition(y), d.preSolveAll(y), s = 0; s < t.constraintIterations; s++)d.solveAll(m, f.timeScale); for (d.postSolveAll(y), o.preSolveVelocity(w.list), s = 0; s < t.velocityIterations; s++)o.solveVelocity(w.list, f.timeScale); return w.collisionActive.length > 0 && u.trigger(t, 'collisionActive', { pairs: w.collisionActive }), w.collisionEnd.length > 0 && u.trigger(t, 'collisionEnd', { pairs: w.collisionEnd }), h.update(t.metrics, t), n._bodiesClearForces(y), u.trigger(t, 'afterUpdate', v), t; }, n.merge = function (t, e) { if (f.extend(t, e), e.world) { t.world = e.world, n.clear(t); for (let i = c.allBodies(t.world), s = 0; s < i.length; s++) { const o = i[s]; r.set(o, !1), o.id = f.nextId(); } } }, n.clear = function (t) { const e = t.world; a.clear(t.pairs); const i = t.broadphase; if (i.controller) { const n = c.allBodies(e); i.controller.clear(i), i.controller.update(i, n, t, !0); } }, n._bodiesClearForces = function (t) { for (let e = 0; e < t.length; e++) { const i = t[e]; i.force.x = 0, i.force.y = 0, i.torque = 0; } }, n._bodiesApplyGravity = function (t, e) { const i = void 0 !== e.scale ? e.scale : 0.001; if ((e.x !== 0 || e.y !== 0) && i !== 0) for (let n = 0; n < t.length; n++) { const s = t[n]; s.ignoreGravity || s.isStatic || s.isSleeping || (s.force.y += s.mass * e.y * i, s.force.x += s.mass * e.x * i); } }, n._bodiesUpdate = function (t, e, i, n, s) { for (let r = 0; r < t.length; r++) { const o = t[r]; o.isStatic || o.isSleeping || p.update(o, e, i, n); } };
}, function (t, e, i) { const n = {}; t.exports = n; const s = i(76); const r = i(81); const o = i(33); const a = i(80); n._restingThresh = 4, n._restingThreshTangent = 6, n._positionDampen = 0.9, n._positionWarming = 0.8, n._frictionNormalMultiplier = 5, n.preSolvePosition = function (t) { let e; let i; let n; for (e = 0; e < t.length; e++)(i = t[e]).isActive && (n = i.activeContacts.length, i.collision.parentA.totalContacts += n, i.collision.parentB.totalContacts += n); }, n.solvePosition = function (t, e, i) { let s; let r; let o; let a; let h; let l; let u; let c; let d; let f; let p; let g; let v; let y; let m; let x; const w = i * n._positionDampen; for (s = 0; s < e.length; s++) { const b = e[s]; b.previousPositionImpulse.x = b.positionImpulse.x, b.previousPositionImpulse.y = b.positionImpulse.y; } for (s = 0; s < t.length; s++)(a = t[s]).isActive && !a.isSensor && (l = (h = a.collision).parentA, u = h.parentB, c = h.normal, p = l.previousPositionImpulse, g = u.previousPositionImpulse, f = h.penetration, y = g.x - p.x + f.x, m = g.y - p.y + f.y, d = (r = c.x) * y + (o = c.y) * m, a.separation = d, x = (d - a.slop) * w, (l.isStatic || u.isStatic) && (x *= 2), l.isStatic || l.isSleeping || (v = x / l.totalContacts, l.positionImpulse.x += r * v, l.positionImpulse.y += o * v), u.isStatic || u.isSleeping || (v = x / u.totalContacts, u.positionImpulse.x -= r * v, u.positionImpulse.y -= o * v)); }, n.postSolvePosition = function (t) { for (let e = 0; e < t.length; e++) { const i = t[e]; if (i.totalContacts = 0, i.positionImpulse.x !== 0 || i.positionImpulse.y !== 0) { for (let o = 0; o < i.parts.length; o++) { const h = i.parts[o]; s.translate(h.vertices, i.positionImpulse), a.update(h.bounds, h.vertices, i.velocity), h.position.x += i.positionImpulse.x, h.position.y += i.positionImpulse.y; }i.positionPrev.x += i.positionImpulse.x, i.positionPrev.y += i.positionImpulse.y, r.dot(i.positionImpulse, i.velocity) < 0 ? (i.positionImpulse.x = 0, i.positionImpulse.y = 0) : (i.positionImpulse.x *= n._positionWarming, i.positionImpulse.y *= n._positionWarming); } } }, n.preSolveVelocity = function (t) { let e; let i; let n; let s; let o; let a; let h; let l; let u; let c; let d; let f; let p; let g; const v = r._temp[0]; const y = r._temp[1]; for (e = 0; e < t.length; e++) if ((n = t[e]).isActive && !n.isSensor) for (s = n.activeContacts, a = (o = n.collision).parentA, h = o.parentB, l = o.normal, u = o.tangent, i = 0; i < s.length; i++)d = (c = s[i]).vertex, f = c.normalImpulse, p = c.tangentImpulse, f === 0 && p === 0 || (v.x = l.x * f + u.x * p, v.y = l.y * f + u.y * p, a.isStatic || a.isSleeping || (g = r.sub(d, a.position, y), a.positionPrev.x += v.x * a.inverseMass, a.positionPrev.y += v.y * a.inverseMass, a.anglePrev += r.cross(g, v) * a.inverseInertia), h.isStatic || h.isSleeping || (g = r.sub(d, h.position, y), h.positionPrev.x -= v.x * h.inverseMass, h.positionPrev.y -= v.y * h.inverseMass, h.anglePrev -= r.cross(g, v) * h.inverseInertia)); }, n.solveVelocity = function (t, e) { for (let i = e * e, s = r._temp[0], a = r._temp[1], h = r._temp[2], l = r._temp[3], u = r._temp[4], c = r._temp[5], d = 0; d < t.length; d++) { const f = t[d]; if (f.isActive && !f.isSensor) { const p = f.collision; const g = p.parentA; const v = p.parentB; const y = p.normal; const m = p.tangent; const x = f.activeContacts; const w = 1 / x.length; g.velocity.x = g.position.x - g.positionPrev.x, g.velocity.y = g.position.y - g.positionPrev.y, v.velocity.x = v.position.x - v.positionPrev.x, v.velocity.y = v.position.y - v.positionPrev.y, g.angularVelocity = g.angle - g.anglePrev, v.angularVelocity = v.angle - v.anglePrev; for (let b = 0; b < x.length; b++) { const T = x[b]; const S = T.vertex; const _ = r.sub(S, g.position, a); const A = r.sub(S, v.position, h); const C = r.add(g.velocity, r.mult(r.perp(_), g.angularVelocity), l); const M = r.add(v.velocity, r.mult(r.perp(A), v.angularVelocity), u); const P = r.sub(C, M, c); const E = r.dot(y, P); const k = r.dot(m, P); const L = Math.abs(k); const F = o.sign(k); let R = (1 + f.restitution) * E; const O = o.clamp(f.separation + E, 0, 1) * n._frictionNormalMultiplier; let D = k; let B = 1 / 0; L > f.friction * f.frictionStatic * O * i && (B = L, D = o.clamp(f.friction * F * i, -B, B)); const I = r.cross(_, y); const Y = r.cross(A, y); const X = w / (g.inverseMass + v.inverseMass + g.inverseInertia * I * I + v.inverseInertia * Y * Y); if (R *= X, D *= X, E < 0 && E * E > n._restingThresh * i)T.normalImpulse = 0; else { const z = T.normalImpulse; T.normalImpulse = Math.min(T.normalImpulse + R, 0), R = T.normalImpulse - z; } if (k * k > n._restingThreshTangent * i)T.tangentImpulse = 0; else { const N = T.tangentImpulse; T.tangentImpulse = o.clamp(T.tangentImpulse + D, -B, B), D = T.tangentImpulse - N; }s.x = y.x * R + m.x * D, s.y = y.y * R + m.y * D, g.isStatic || g.isSleeping || (g.positionPrev.x += s.x * g.inverseMass, g.positionPrev.y += s.y * g.inverseMass, g.anglePrev += r.cross(_, s) * g.inverseInertia), v.isStatic || v.isSleeping || (v.positionPrev.x -= s.x * v.inverseMass, v.positionPrev.y -= s.y * v.inverseMass, v.anglePrev -= r.cross(A, s) * v.inverseInertia); } } } }; }, function (t, e, i) {
  const n = {}; t.exports = n; const s = i(418); const r = i(33); n._pairMaxIdleLife = 1e3, n.create = function (t) {
    return r.extend({
      table: {}, list: [], collisionStart: [], collisionActive: [], collisionEnd: [],
    }, t);
  }, n.update = function (t, e, i) { let n; let r; let o; let a; const h = t.list; const l = t.table; const u = t.collisionStart; const c = t.collisionEnd; const d = t.collisionActive; for (u.length = 0, c.length = 0, d.length = 0, a = 0; a < h.length; a++)h[a].confirmedActive = !1; for (a = 0; a < e.length; a++)(n = e[a]).collided && ((o = l[r = s.id(n.bodyA, n.bodyB)]) ? (o.isActive ? d.push(o) : u.push(o), s.update(o, n, i), o.confirmedActive = !0) : (o = s.create(n, i), l[r] = o, u.push(o), h.push(o))); for (a = 0; a < h.length; a++)(o = h[a]).isActive && !o.confirmedActive && (s.setActive(o, !1, i), c.push(o)); }, n.removeOld = function (t, e) { let i; let s; let r; let o; const a = t.list; const h = t.table; const l = []; for (o = 0; o < a.length; o++)(s = (i = a[o]).collision).bodyA.isSleeping || s.bodyB.isSleeping ? i.timeUpdated = e : e - i.timeUpdated > n._pairMaxIdleLife && l.push(o); for (o = 0; o < l.length; o++) delete h[(i = a[r = l[o] - o]).id], a.splice(r, 1); }, n.clear = function (t) { return t.table = {}, t.list.length = 0, t.collisionStart.length = 0, t.collisionActive.length = 0, t.collisionEnd.length = 0, t; };
}, function (t, e, i) {
  const n = {}; t.exports = n; const s = i(418); const r = i(503); const o = i(33); n.create = function (t) {
    const e = {
      controller: n, detector: r.collisions, buckets: {}, pairs: {}, pairsList: [], bucketWidth: 48, bucketHeight: 48,
    }; return o.extend(e, t);
  }, n.update = function (t, e, i, s) { let r; let o; let a; let h; let l; const u = i.world; const c = t.buckets; let d = !1; const f = i.metrics; for (f.broadphaseTests = 0, r = 0; r < e.length; r++) { const p = e[r]; if ((!p.isSleeping || s) && !(p.bounds.max.x < u.bounds.min.x || p.bounds.min.x > u.bounds.max.x || p.bounds.max.y < u.bounds.min.y || p.bounds.min.y > u.bounds.max.y)) { const g = n._getRegion(t, p); if (!p.region || g.id !== p.region.id || s) { f.broadphaseTests += 1, p.region && !s || (p.region = g); const v = n._regionUnion(g, p.region); for (o = v.startCol; o <= v.endCol; o++) for (a = v.startRow; a <= v.endRow; a++) { h = c[l = n._getBucketId(o, a)]; const y = o >= g.startCol && o <= g.endCol && a >= g.startRow && a <= g.endRow; const m = o >= p.region.startCol && o <= p.region.endCol && a >= p.region.startRow && a <= p.region.endRow; !y && m && m && h && n._bucketRemoveBody(t, h, p), (p.region === g || y && !m || s) && (h || (h = n._createBucket(c, l)), n._bucketAddBody(t, h, p)); }p.region = g, d = !0; } } }d && (t.pairsList = n._createActivePairsList(t)); }, n.clear = function (t) { t.buckets = {}, t.pairs = {}, t.pairsList = []; }, n._regionUnion = function (t, e) { const i = Math.min(t.startCol, e.startCol); const s = Math.max(t.endCol, e.endCol); const r = Math.min(t.startRow, e.startRow); const o = Math.max(t.endRow, e.endRow); return n._createRegion(i, s, r, o); }, n._getRegion = function (t, e) { const i = e.bounds; const s = Math.floor(i.min.x / t.bucketWidth); const r = Math.floor(i.max.x / t.bucketWidth); const o = Math.floor(i.min.y / t.bucketHeight); const a = Math.floor(i.max.y / t.bucketHeight); return n._createRegion(s, r, o, a); }, n._createRegion = function (t, e, i, n) {
    return {
      id: `${t},${e},${i},${n}`, startCol: t, endCol: e, startRow: i, endRow: n,
    };
  }, n._getBucketId = function (t, e) { return `C${t}R${e}`; }, n._createBucket = function (t, e) { return t[e] = []; }, n._bucketAddBody = function (t, e, i) { for (let n = 0; n < e.length; n++) { const r = e[n]; if (!(i.id === r.id || i.isStatic && r.isStatic)) { const o = s.id(i, r); const a = t.pairs[o]; a ? a[2] += 1 : t.pairs[o] = [i, r, 1]; } }e.push(i); }, n._bucketRemoveBody = function (t, e, i) { e.splice(o.indexOf(e, i), 1); for (let n = 0; n < e.length; n++) { const r = e[n]; const a = s.id(i, r); const h = t.pairs[a]; h && (h[2] -= 1); } }, n._createActivePairsList = function (t) { let e; let i; const n = []; e = o.keys(t.pairs); for (let s = 0; s < e.length; s++)(i = t.pairs[e[s]])[2] > 0 ? n.push(i) : delete t.pairs[e[s]]; return n; };
}, function (t, e, i) { const n = {}; t.exports = n; const s = i(500); const r = i(33); n.name = 'matter-js', n.version = '0.14.2', n.uses = [], n.used = [], n.use = function () { s.use(n, Array.prototype.slice.call(arguments)); }, n.before = function (t, e) { return t = t.replace(/^Matter./, ''), r.chainPathBefore(n, t, e); }, n.after = function (t, e) { return t = t.replace(/^Matter./, ''), r.chainPathAfter(n, t, e); }; }, function (t, e, i) { const n = i(427); const s = i(0); const r = i(419); const o = i(19); const a = i(2); const h = i(186); const l = i(61); const u = i(3); const c = new s({ Extends: l, Mixins: [r.Bounce, r.Collision, r.Force, r.Friction, r.Gravity, r.Mass, r.Sensor, r.SetBody, r.Sleep, r.Static, r.Transform, r.Velocity, h], initialize(t, e, i, s, r, h) { o.call(this, t.scene, 'Image'), this.anims = new n(this), this.setTexture(s, r), this.setSizeToFrame(), this.setOrigin(), this.world = t, this._tempVec2 = new u(e, i); const l = a(h, 'shape', null); l ? this.setBody(l, h) : this.setRectangle(this.width, this.height, h), this.setPosition(e, i), this.initPipeline('TextureTintPipeline'); } }); t.exports = c; }, function (t, e, i) { const n = i(0); const s = i(419); const r = i(19); const o = i(2); const a = i(87); const h = i(186); const l = i(3); const u = new n({ Extends: a, Mixins: [s.Bounce, s.Collision, s.Force, s.Friction, s.Gravity, s.Mass, s.Sensor, s.SetBody, s.Sleep, s.Static, s.Transform, s.Velocity, h], initialize(t, e, i, n, s, a) { r.call(this, t.scene, 'Image'), this.setTexture(n, s), this.setSizeToFrame(), this.setOrigin(), this.world = t, this._tempVec2 = new l(e, i); const h = o(a, 'shape', null); h ? this.setBody(h, a) : this.setRectangle(this.width, this.height, a), this.setPosition(e, i), this.initPipeline('TextureTintPipeline'); } }); t.exports = u; }, function (t, e, i) {
  const n = {}; t.exports = n; const s = i(137); const r = i(194); const o = i(33); const a = i(67); const h = i(126); n.stack = function (t, e, i, n, r, o, h) { for (var l, u = s.create({ label: 'Stack' }), c = t, d = e, f = 0, p = 0; p < n; p++) { for (var g = 0, v = 0; v < i; v++) { const y = h(c, d, v, p, l, f); if (y) { const m = y.bounds.max.y - y.bounds.min.y; const x = y.bounds.max.x - y.bounds.min.x; m > g && (g = m), a.translate(y, { x: 0.5 * x, y: 0.5 * m }), c = y.bounds.max.x + r, s.addBody(u, y), l = y, f += 1; } else c += r; }d += g + o, c = t; } return u; }, n.chain = function (t, e, i, n, a, h) {
    for (let l = t.bodies, u = 1; u < l.length; u++) {
      const c = l[u - 1]; const d = l[u]; const f = c.bounds.max.y - c.bounds.min.y; const p = c.bounds.max.x - c.bounds.min.x; const g = d.bounds.max.y - d.bounds.min.y; const v = {
        bodyA: c, pointA: { x: p * e, y: f * i }, bodyB: d, pointB: { x: (d.bounds.max.x - d.bounds.min.x) * n, y: g * a },
      }; const y = o.extend(v, h); s.addConstraint(t, r.create(y));
    } return t.label += ' Chain', t;
  }, n.mesh = function (t, e, i, n, a) { let h; let l; let u; let c; let d; const f = t.bodies; for (h = 0; h < i; h++) { for (l = 1; l < e; l++)u = f[l - 1 + h * e], c = f[l + h * e], s.addConstraint(t, r.create(o.extend({ bodyA: u, bodyB: c }, a))); if (h > 0) for (l = 0; l < e; l++)u = f[l + (h - 1) * e], c = f[l + h * e], s.addConstraint(t, r.create(o.extend({ bodyA: u, bodyB: c }, a))), n && l > 0 && (d = f[l - 1 + (h - 1) * e], s.addConstraint(t, r.create(o.extend({ bodyA: d, bodyB: c }, a)))), n && l < e - 1 && (d = f[l + 1 + (h - 1) * e], s.addConstraint(t, r.create(o.extend({ bodyA: d, bodyB: c }, a)))); } return t.label += ' Mesh', t; }, n.pyramid = function (t, e, i, s, r, o, h) { return n.stack(t, e, i, s, r, o, (e, n, o, l, u, c) => { const d = Math.min(s, Math.ceil(i / 2)); const f = u ? u.bounds.max.x - u.bounds.min.x : 0; if (!(l > d || o < (l = d - l) || o > i - 1 - l)) return c === 1 && a.translate(u, { x: (o + (i % 2 == 1 ? 1 : -1)) * f, y: 0 }), h(t + (u ? o * f : 0) + o * r, n, o, l, u, c); }); }, n.newtonsCradle = function (t, e, i, n, o) {
    for (var a = s.create({ label: 'Newtons Cradle' }), l = 0; l < i; l++) {
      const u = h.circle(t + l * (1.9 * n), e + o, n, {
        inertia: 1 / 0, restitution: 1, friction: 0, frictionAir: 1e-4, slop: 1,
      }); const c = r.create({ pointA: { x: t + l * (1.9 * n), y: e }, bodyB: u }); s.addBody(a, u), s.addConstraint(a, c);
    } return a;
  }, n.car = function (t, e, i, n, o) {
    const l = a.nextGroup(!0); const u = 0.5 * -i + 20; const c = 0.5 * i - 20; const d = s.create({ label: 'Car' }); const f = h.rectangle(t, e, i, n, { collisionFilter: { group: l }, chamfer: { radius: 0.5 * n }, density: 2e-4 }); const p = h.circle(t + u, e + 0, o, { collisionFilter: { group: l }, friction: 0.8 }); const g = h.circle(t + c, e + 0, o, { collisionFilter: { group: l }, friction: 0.8 }); const v = r.create({
      bodyB: f, pointB: { x: u, y: 0 }, bodyA: p, stiffness: 1, length: 0,
    }); const y = r.create({
      bodyB: f, pointB: { x: c, y: 0 }, bodyA: g, stiffness: 1, length: 0,
    }); return s.addBody(d, f), s.addBody(d, p), s.addBody(d, g), s.addConstraint(d, v), s.addConstraint(d, y), d;
  }, n.softBody = function (t, e, i, s, r, a, l, u, c, d) { c = o.extend({ inertia: 1 / 0 }, c), d = o.extend({ stiffness: 0.2, render: { type: 'line', anchors: !1 } }, d); const f = n.stack(t, e, i, s, r, a, (t, e) => h.circle(t, e, u, c)); return n.mesh(f, i, s, l, d), f.label = 'Soft Body', f; };
}, function (t, e) {
  function i(t, e, i) { i = i || 0; let n; let s; let r; let o; let a; let h; let l; const u = [0, 0]; return n = t[1][1] - t[0][1], s = t[0][0] - t[1][0], r = n * t[0][0] + s * t[0][1], o = e[1][1] - e[0][1], a = e[0][0] - e[1][0], h = o * e[0][0] + a * e[0][1], T(l = n * a - o * s, 0, i) || (u[0] = (a * r - s * h) / l, u[1] = (n * h - o * r) / l), u; } function n(t, e, i, n) { const s = e[0] - t[0]; const r = e[1] - t[1]; const o = n[0] - i[0]; const a = n[1] - i[1]; if (o * r - a * s == 0) return !1; const h = (s * (i[1] - t[1]) + r * (t[0] - i[0])) / (o * r - a * s); const l = (o * (t[1] - i[1]) + a * (i[0] - t[0])) / (a * s - o * r); return h >= 0 && h <= 1 && l >= 0 && l <= 1; } function s(t, e, i) { return (e[0] - t[0]) * (i[1] - t[1]) - (i[0] - t[0]) * (e[1] - t[1]); } function r(t, e, i) { return s(t, e, i) > 0; } function o(t, e, i) { return s(t, e, i) >= 0; } function a(t, e, i) { return s(t, e, i) < 0; } function h(t, e, i) { return s(t, e, i) <= 0; }t.exports = {
    decomp(t) { const e = (function t(e) { let i = []; let n = []; let s = []; const r = []; let o = Number.MAX_VALUE; for (let a = 0; a < e.length; ++a) if (g(e, a)) for (let h = 0; h < e.length; ++h) if (m(e, a, h)) { n = t(w(e, a, h, r)), s = t(w(e, h, a, r)); for (let l = 0; l < s.length; l++)n.push(s[l]); n.length < o && (i = n, o = n.length, i.push([f(e, a), f(e, h)])); } return i; }(t)); return e.length > 0 ? (function t(e, i) { if (i.length === 0) return [e]; if (i instanceof Array && i.length && i[0] instanceof Array && i[0].length === 2 && i[0][0] instanceof Array) { for (var n = [e], s = 0; s < i.length; s++) for (var r = i[s], o = 0; o < n.length; o++) { const a = n[o]; const h = t(a, r); if (h) { n.splice(o, 1), n.push(h[0], h[1]); break; } } return n; } var r = i; var s = e.indexOf(r[0]); var o = e.indexOf(r[1]); return s !== -1 && o !== -1 && [w(e, s, o), w(e, o, s)]; }(t, e)) : [t]; }, quickDecomp: function t(e, i, n, s, l, u, c) { u = u || 100; c = c || 0; l = l || 25; i = void 0 !== i ? i : []; n = n || []; s = s || []; let v = [0, 0]; let y = [0, 0]; let m = [0, 0]; let w = 0; let T = 0; let S = 0; let _ = 0; let A = 0; let C = 0; let M = 0; const P = []; const E = []; const k = e; const L = e; if (L.length < 3) return i; c++; if (c > u) return console.warn(`quickDecomp: max level (${u}) reached.`), i; for (let F = 0; F < e.length; ++F) if (g(k, F)) { n.push(k[F]), w = T = Number.MAX_VALUE; for (var R = 0; R < e.length; ++R)r(f(k, F - 1), f(k, F), f(k, R)) && h(f(k, F - 1), f(k, F), f(k, R - 1)) && (m = b(f(k, F - 1), f(k, F), f(k, R), f(k, R - 1)), a(f(k, F + 1), f(k, F), m) && (S = d(k[F], m)) < T && (T = S, y = m, C = R)), r(f(k, F + 1), f(k, F), f(k, R + 1)) && h(f(k, F + 1), f(k, F), f(k, R)) && (m = b(f(k, F + 1), f(k, F), f(k, R), f(k, R + 1)), r(f(k, F - 1), f(k, F), m) && (S = d(k[F], m)) < w && (w = S, v = m, A = R)); if (C === (A + 1) % e.length)m[0] = (y[0] + v[0]) / 2, m[1] = (y[1] + v[1]) / 2, s.push(m), F < A ? (p(P, k, F, A + 1), P.push(m), E.push(m), C !== 0 && p(E, k, C, k.length), p(E, k, 0, F + 1)) : (F !== 0 && p(P, k, F, k.length), p(P, k, 0, A + 1), P.push(m), E.push(m), p(E, k, C, F + 1)); else { if (C > A && (A += e.length), _ = Number.MAX_VALUE, A < C) return i; for (var R = C; R <= A; ++R)o(f(k, F - 1), f(k, F), f(k, R)) && h(f(k, F + 1), f(k, F), f(k, R)) && (S = d(f(k, F), f(k, R))) < _ && x(k, F, R) && (_ = S, M = R % e.length); F < M ? (p(P, k, F, M + 1), M !== 0 && p(E, k, M, L.length), p(E, k, 0, F + 1)) : (F !== 0 && p(P, k, F, L.length), p(P, k, 0, M + 1), p(E, k, M, F + 1)); } return P.length < E.length ? (t(P, i, n, s, l, u, c), t(E, i, n, s, l, u, c)) : (t(E, i, n, s, l, u, c), t(P, i, n, s, l, u, c)), i; }i.push(e); return i; }, isSimple(t) { let e; const i = t; for (e = 0; e < i.length - 1; e++) for (let s = 0; s < e - 1; s++) if (n(i[e], i[e + 1], i[s], i[s + 1])) return !1; for (e = 1; e < i.length - 2; e++) if (n(i[0], i[i.length - 1], i[e], i[e + 1])) return !1; return !0; }, removeCollinearPoints(t, e) { for (var i = 0, n = t.length - 1; t.length > 3 && n >= 0; --n)c(f(t, n - 1), f(t, n), f(t, n + 1), e) && (t.splice(n % t.length, 1), i++); return i; }, removeDuplicatePoints(t, e) { for (let i = t.length - 1; i >= 1; --i) for (let n = t[i], s = i - 1; s >= 0; --s)S(n, t[s], e) && t.splice(i, 1); }, makeCCW(t) { for (var e = 0, i = t, n = 1; n < t.length; ++n)(i[n][1] < i[e][1] || i[n][1] === i[e][1] && i[n][0] > i[e][0]) && (e = n); return !r(f(t, e - 1), f(t, e), f(t, e + 1)) && ((function (t) { for (var e = [], i = t.length, n = 0; n !== i; n++)e.push(t.pop()); for (var n = 0; n !== i; n++)t[n] = e[n]; }(t)), !0); },
  }; const l = []; const u = []; function c(t, e, i, n) { if (n) { const r = l; const o = u; r[0] = e[0] - t[0], r[1] = e[1] - t[1], o[0] = i[0] - e[0], o[1] = i[1] - e[1]; const a = r[0] * o[0] + r[1] * o[1]; const h = Math.sqrt(r[0] * r[0] + r[1] * r[1]); const c = Math.sqrt(o[0] * o[0] + o[1] * o[1]); return Math.acos(a / (h * c)) < n; } return s(t, e, i) === 0; } function d(t, e) { const i = e[0] - t[0]; const n = e[1] - t[1]; return i * i + n * n; } function f(t, e) { const i = t.length; return t[e < 0 ? e % i + i : e % i]; } function p(t, e, i, n) { for (let s = i; s < n; s++)t.push(e[s]); } function g(t, e) { return a(f(t, e - 1), f(t, e), f(t, e + 1)); } const v = []; const y = []; function m(t, e, n) { let s; let r; const a = v; const l = y; if (o(f(t, e + 1), f(t, e), f(t, n)) && h(f(t, e - 1), f(t, e), f(t, n))) return !1; r = d(f(t, e), f(t, n)); for (let u = 0; u !== t.length; ++u) if ((u + 1) % t.length !== e && u !== e && o(f(t, e), f(t, n), f(t, u + 1)) && h(f(t, e), f(t, n), f(t, u)) && (a[0] = f(t, e), a[1] = f(t, n), l[0] = f(t, u), l[1] = f(t, u + 1), s = i(a, l), d(f(t, e), s) < r)) return !1; return !0; } function x(t, e, i) { for (let s = 0; s !== t.length; ++s) if (s !== e && s !== i && (s + 1) % t.length !== e && (s + 1) % t.length !== i && n(f(t, e), f(t, i), f(t, s), f(t, s + 1))) return !1; return !0; } function w(t, e, i, n) { const s = n || []; if ((function (t) { t.length = 0; }(s)), e < i) for (var r = e; r <= i; r++)s.push(t[r]); else { for (r = 0; r <= i; r++)s.push(t[r]); for (r = e; r < t.length; r++)s.push(t[r]); } return s; } function b(t, e, i, n, s) { s = s || 0; const r = e[1] - t[1]; const o = t[0] - e[0]; const a = r * t[0] + o * t[1]; const h = n[1] - i[1]; const l = i[0] - n[0]; const u = h * i[0] + l * i[1]; const c = r * l - h * o; return T(c, 0, s) ? [0, 0] : [(l * a - o * u) / c, (r * u - h * a) / c]; } function T(t, e, i) { return i = i || 0, Math.abs(t - e) <= i; } function S(t, e, i) { return T(t[0], e[0], i) && T(t[1], e[1], i); }
}, function (t, e, i) {
  const n = i(126); const s = i(0); const r = i(1068); const o = i(194); const a = i(1104); const h = i(1067); const l = i(1066); const u = i(504); const c = i(1090); const d = new s({
    initialize(t) { this.world = t, this.scene = t.scene, this.sys = t.scene.sys; }, rectangle(t, e, i, s, r) { const o = n.rectangle(t, e, i, s, r); return this.world.add(o), o; }, trapezoid(t, e, i, s, r, o) { const a = n.trapezoid(t, e, i, s, r, o); return this.world.add(a), a; }, circle(t, e, i, s, r) { const o = n.circle(t, e, i, s, r); return this.world.add(o), o; }, polygon(t, e, i, s, r) { const o = n.polygon(t, e, i, s, r); return this.world.add(o), o; }, fromVertices(t, e, i, s, r, o, a) { const h = n.fromVertices(t, e, i, s, r, o, a); return this.world.add(h), h; }, imageStack(t, e, i, n, s, o, a, l, u) { void 0 === a && (a = 0), void 0 === l && (l = 0), void 0 === u && (u = {}); const c = this.world; const d = this.sys.displayList; u.addToWorld = !1; const f = r.stack(i, n, s, o, a, l, (i, n) => { const s = new h(c, i, n, t, e, u); return d.add(s), s.body; }); return c.add(f), f; }, stack(t, e, i, n, s, o, a) { const h = r.stack(t, e, i, n, s, o, a); return this.world.add(h), h; }, pyramid(t, e, i, n, s, o, a) { const h = r.pyramid(t, e, i, n, s, o, a); return this.world.add(h), h; }, chain(t, e, i, n, s, o) { return r.chain(t, e, i, n, s, o); }, mesh(t, e, i, n, s) { return r.mesh(t, e, i, n, s); }, newtonsCradle(t, e, i, n, s) { const o = r.newtonsCradle(t, e, i, n, s); return this.world.add(o), o; }, car(t, e, i, n, s) { const o = r.car(t, e, i, n, s); return this.world.add(o), o; }, softBody(t, e, i, n, s, o, a, h, l, u) { const c = r.softBody(t, e, i, n, s, o, a, h, l, u); return this.world.add(c), c; }, joint(t, e, i, n, s) { return this.constraint(t, e, i, n, s); }, spring(t, e, i, n, s) { return this.constraint(t, e, i, n, s); }, constraint(t, e, i, n, s) { void 0 === n && (n = 1), void 0 === s && (s = {}), s.bodyA = t.type === 'body' ? t : t.body, s.bodyB = e.type === 'body' ? e : e.body, s.length = i, s.stiffness = n; const r = o.create(s); return this.world.add(r), r; }, worldConstraint(t, e, i, n) { void 0 === i && (i = 1), void 0 === n && (n = {}), n.bodyB = t.type === 'body' ? t : t.body, n.length = e, n.stiffness = i; const s = o.create(n); return this.world.add(s), s; }, mouseSpring(t) { return this.pointerConstraint(t); }, pointerConstraint(t) { void 0 === t && (t = {}), t.hasOwnProperty('render') || (t.render = { visible: !1 }); const e = new c(this.scene, this.world, t); return this.world.add(e.constraint), e; }, image(t, e, i, n, s) { const r = new h(this.world, t, e, i, n, s); return this.sys.displayList.add(r), r; }, tileBody(t, e) { return new u(this.world, t, e); }, sprite(t, e, i, n, s) { const r = new l(this.world, t, e, i, n, s); return this.sys.displayList.add(r), this.sys.updateList.add(r), r; }, gameObject(t, e) { return a(this.world, t, e); }, destroy() { this.world = null, this.scene = null, this.sys = null; },
  }); t.exports = d;
}, function (t, e, i) {
  const n = i(1077); const s = i(0); const r = i(224); const o = i(1076); const a = i(11); const h = i(2); const l = i(85); const u = i(95); const c = i(1108); const d = i(29); const f = i(223); const p = new s({
    Extends: a,
    initialize(t, e) {
      a.call(this), this.scene = t, this.bodies = new u(), this.gravity = h(e, 'gravity', 0), this.cellSize = h(e, 'cellSize', 64), this.collisionMap = new o(), this.timeScale = h(e, 'timeScale', 1), this.maxStep = h(e, 'maxStep', 0.05), this.enabled = !0, this.drawDebug = h(e, 'debug', !1), this.debugGraphic; const i = h(e, 'maxVelocity', 100); if (this.defaults = {
        debugShowBody: h(e, 'debugShowBody', !0), debugShowVelocity: h(e, 'debugShowVelocity', !0), bodyDebugColor: h(e, 'debugBodyColor', 16711935), velocityDebugColor: h(e, 'debugVelocityColor', 65280), maxVelocityX: h(e, 'maxVelocityX', i), maxVelocityY: h(e, 'maxVelocityY', i), minBounceVelocity: h(e, 'minBounceVelocity', 40), gravityFactor: h(e, 'gravityFactor', 1), bounciness: h(e, 'bounciness', 0),
      }, this.walls = {
        left: null, right: null, top: null, bottom: null,
      }, this.delta = 0, this._lastId = 0, h(e, 'setBounds', !1)) { const n = e.setBounds; if (typeof n === 'boolean') this.setBounds(); else { const s = h(n, 'x', 0); const r = h(n, 'y', 0); const l = h(n, 'width', t.sys.game.config.width); const c = h(n, 'height', t.sys.game.config.height); const d = h(n, 'thickness', 64); const f = h(n, 'left', !0); const p = h(n, 'right', !0); const g = h(n, 'top', !0); const v = h(n, 'bottom', !0); this.setBounds(s, r, l, c, d, f, p, g, v); } } this.drawDebug && this.createDebugGraphic();
    },
    setCollisionMap(t, e) { if (typeof t === 'string') { const i = this.scene.cache.tilemap.get(t); if (!i || i.format !== d.WELTMEISTER) return console.warn(`The specified key does not correspond to a Weltmeister tilemap: ${t}`), null; for (var n, s = i.data.layer, r = 0; r < s.length; r++) if (s[r].name === 'collision') { n = s[r]; break; } void 0 === e && (e = n.tilesize), this.collisionMap = new o(e, n.data); } else Array.isArray(t) ? this.collisionMap = new o(e, t) : console.warn(`Invalid Weltmeister collision map data: ${t}`); return this.collisionMap; },
    setCollisionMapFromTilemapLayer(t, e) { void 0 === e && (e = {}); for (var i = h(e, 'slopeProperty', null), n = h(e, 'slopeMap', null), s = h(e, 'defaultCollidingSlope', null), r = h(e, 'defaultNonCollidingSlope', 0), a = t.layer, u = a.baseTileWidth, c = [], d = 0; d < a.height; d++) { c[d] = []; for (let f = 0; f < a.width; f++) { const p = a.data[d][f]; p && p.collides ? i !== null && l(p.properties, i) ? c[d][f] = parseInt(p.properties[i], 10) : n !== null && l(n, p.index) ? c[d][f] = n[p.index] : c[d][f] = s !== null ? s : p.index : c[d][f] = r; } } return this.collisionMap = new o(u, c), this.collisionMap; },
    setBounds(t, e, i, n, s, r, o, a, h) { return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = this.scene.sys.game.config.width), void 0 === n && (n = this.scene.sys.game.config.height), void 0 === s && (s = 64), void 0 === r && (r = !0), void 0 === o && (o = !0), void 0 === a && (a = !0), void 0 === h && (h = !0), this.updateWall(r, 'left', t - s, e, s, n), this.updateWall(o, 'right', t + i, e, s, n), this.updateWall(a, 'top', t, e - s, i, s), this.updateWall(h, 'bottom', t, e + n, i, s), this; },
    updateWall(t, e, i, n, s, o) { const a = this.walls[e]; t ? a ? a.resetSize(i, n, s, o) : (this.walls[e] = this.create(i, n, s, o), this.walls[e].name = e, this.walls[e].gravityFactor = 0, this.walls[e].collides = r.FIXED) : (a && this.bodies.remove(a), this.walls[e] = null); },
    createDebugGraphic() { const t = this.scene.sys.add.graphics({ x: 0, y: 0 }); return t.setDepth(Number.MAX_VALUE), this.debugGraphic = t, this.drawDebug = !0, t; },
    getNextID() { return this._lastId++; },
    create(t, e, i, s) { const r = new n(this, t, e, i, s); return this.bodies.set(r), r; },
    remove(t) { this.bodies.delete(t); },
    pause() { return this.enabled = !1, this.emit('pause'), this; },
    resume() { return this.enabled = !0, this.emit('resume'), this; },
    update(t, e) { if (this.enabled && this.bodies.size !== 0) { let i; let n; const s = Math.min(e / 1e3, this.maxStep) * this.timeScale; this.delta = s; const r = this.bodies.entries; const o = r.length; const a = {}; const h = this.cellSize; for (i = 0; i < o; i++)(n = r[i]).enabled && n.update(s); for (i = 0; i < o; i++)(n = r[i]) && !n.skipHash() && this.checkHash(n, a, h); if (this.drawDebug) { const l = this.debugGraphic; for (l.clear(), i = 0; i < o; i++)(n = r[i]) && n.willDrawDebug() && n.drawDebug(l); } } },
    checkHash(t, e, i) { for (let n = {}, s = Math.floor(t.pos.x / i), r = Math.floor(t.pos.y / i), o = Math.floor((t.pos.x + t.size.x) / i) + 1, a = Math.floor((t.pos.y + t.size.y) / i) + 1, h = s; h < o; h++) for (let l = r; l < a; l++) if (e[h]) if (e[h][l]) { for (var u = e[h][l], c = 0; c < u.length; c++)t.touches(u[c]) && !n[u[c].id] && (n[u[c].id] = !0, this.checkBodies(t, u[c])); u.push(t); } else e[h][l] = [t]; else e[h] = {}, e[h][l] = [t]; },
    checkBodies(t, e) { t.collides === r.FIXED && e.collides === r.FIXED || (t.checkAgainst & e.type && t.check(e), e.checkAgainst & t.type && e.check(t), t.collides && e.collides && t.collides + e.collides > r.ACTIVE && c(this, t, e)); },
    setCollidesNever(t) { for (let e = 0; e < t.length; e++)t[e].collides = r.NEVER; return this; },
    setLite(t) { for (let e = 0; e < t.length; e++)t[e].collides = r.LITE; return this; },
    setPassive(t) { for (let e = 0; e < t.length; e++)t[e].collides = r.PASSIVE; return this; },
    setActive(t) { for (let e = 0; e < t.length; e++)t[e].collides = r.ACTIVE; return this; },
    setFixed(t) { for (let e = 0; e < t.length; e++)t[e].collides = r.FIXED; return this; },
    setTypeNone(t) { for (let e = 0; e < t.length; e++)t[e].type = f.NONE; return this; },
    setTypeA(t) { for (let e = 0; e < t.length; e++)t[e].type = f.A; return this; },
    setTypeB(t) { for (let e = 0; e < t.length; e++)t[e].type = f.B; return this; },
    setAvsB(t) { for (let e = 0; e < t.length; e++)t[e].type = f.A, t[e].checkAgainst = f.B; return this; },
    setBvsA(t) { for (let e = 0; e < t.length; e++)t[e].type = f.B, t[e].checkAgainst = f.A; return this; },
    setCheckAgainstNone(t) { for (let e = 0; e < t.length; e++)t[e].checkAgainst = f.NONE; return this; },
    setCheckAgainstA(t) { for (let e = 0; e < t.length; e++)t[e].checkAgainst = f.A; return this; },
    setCheckAgainstB(t) { for (let e = 0; e < t.length; e++)t[e].checkAgainst = f.B; return this; },
    shutdown() { this.removeAllListeners(); },
    destroy() { this.removeAllListeners(), this.scene = null, this.bodies.clear(), this.bodies = null, this.collisionMap = null; },
  }); t.exports = p;
}, function (t, e, i) { const n = i(0); const s = i(506); const r = i(61); const o = new n({ Extends: r, Mixins: [s.Acceleration, s.BodyScale, s.BodyType, s.Bounce, s.CheckAgainst, s.Collides, s.Debug, s.Friction, s.Gravity, s.Offset, s.SetGameObject, s.Velocity], initialize(t, e, i, n, s) { r.call(this, t.scene, e, i, n, s), this.body = t.create(e - this.frame.centerX, i - this.frame.centerY, this.width, this.height), this.body.parent = this, this.body.gameObject = this, this.size = this.body.size, this.offset = this.body.offset, this.vel = this.body.vel, this.accel = this.body.accel, this.friction = this.body.friction, this.maxVel = this.body.maxVel; } }); t.exports = o; }, function (t, e, i) { const n = i(0); const s = i(506); const r = i(87); const o = new n({ Extends: r, Mixins: [s.Acceleration, s.BodyScale, s.BodyType, s.Bounce, s.CheckAgainst, s.Collides, s.Debug, s.Friction, s.Gravity, s.Offset, s.SetGameObject, s.Velocity], initialize(t, e, i, n, s) { r.call(this, t.scene, e, i, n, s), this.body = t.create(e - this.frame.centerX, i - this.frame.centerY, this.width, this.height), this.body.parent = this, this.body.gameObject = this, this.size = this.body.size, this.offset = this.body.offset, this.vel = this.body.vel, this.accel = this.body.accel, this.friction = this.body.friction, this.maxVel = this.body.maxVel; } }); t.exports = o; }, function (t, e, i) { const n = i(0); const s = i(506); const r = new n({ Mixins: [s.Acceleration, s.BodyScale, s.BodyType, s.Bounce, s.CheckAgainst, s.Collides, s.Debug, s.Friction, s.Gravity, s.Offset, s.SetGameObject, s.Velocity], initialize(t, e, i, n, s) { this.body = t.create(e, i, n, s), this.body.parent = this, this.size = this.body.size, this.offset = this.body.offset, this.vel = this.body.vel, this.accel = this.body.accel, this.friction = this.body.friction, this.maxVel = this.body.maxVel; } }); t.exports = r; }, function (t, e, i) {
  const n = i(0); const s = i(1074); const r = i(1073); const o = i(1072); const a = new n({
    initialize(t) { this.world = t, this.sys = t.scene.sys; }, body(t, e, i, n) { return new s(this.world, t, e, i, n); }, existing(t) { const e = t.x - t.frame.centerX; const i = t.y - t.frame.centerY; const n = t.width; const s = t.height; return t.body = this.world.create(e, i, n, s), t.body.parent = t, t.body.gameObject = t, t; }, image(t, e, i, n) { const s = new r(this.world, t, e, i, n); return this.sys.displayList.add(s), s; }, sprite(t, e, i, n) { const s = new o(this.world, t, e, i, n); return this.sys.displayList.add(s), this.sys.updateList.add(s), s; }, destroy() { this.world = null, this.sys = null; },
  }); t.exports = a;
}, function (t, e, i) {
  const n = i(0); const s = i(1122); const r = new n({
    initialize(t, e) { void 0 === t && (t = 32), this.tilesize = t, this.data = Array.isArray(e) ? e : [], this.width = Array.isArray(e) ? e[0].length : 0, this.height = Array.isArray(e) ? e.length : 0, this.lastSlope = 55, this.tiledef = s; },
    trace(t, e, i, n, s, r) { const o = { collision: { x: !1, y: !1, slope: !1 }, pos: { x: t + i, y: e + n }, tile: { x: 0, y: 0 } }; if (!this.data) return o; const a = Math.ceil(Math.max(Math.abs(i), Math.abs(n)) / this.tilesize); if (a > 1) for (let h = i / a, l = n / a, u = 0; u < a && (h || l) && (this.step(o, t, e, h, l, s, r, i, n, u), t = o.pos.x, e = o.pos.y, o.collision.x && (h = 0, i = 0), o.collision.y && (l = 0, n = 0), !o.collision.slope); u++);else this.step(o, t, e, i, n, s, r, i, n, 0); return o; },
    step(t, e, i, n, s, r, o, a, h, l) { let u; let c; let d = 0; const f = this.tilesize; const p = this.width; const g = this.height; if (n) { const v = n > 0 ? r : 0; const y = n < 0 ? f : 0; const m = Math.max(Math.floor(i / f), 0); const x = Math.min(Math.ceil((i + o) / f), g); u = Math.floor((t.pos.x + v) / f); let w = Math.floor((e + v) / f); if ((l > 0 || u === w || w < 0 || w >= p) && (w = -1), u >= 0 && u < p) for (c = m; c < x && !(w !== -1 && (d = this.data[c][w]) > 1 && d <= this.lastSlope && this.checkDef(t, d, e, i, a, h, r, o, w, c)); c++) if ((d = this.data[c][u]) === 1 || d > this.lastSlope || d > 1 && this.checkDef(t, d, e, i, a, h, r, o, u, c)) { if (d > 1 && d <= this.lastSlope && t.collision.slope) break; t.collision.x = !0, t.tile.x = d, t.pos.x = u * f - v + y, e = t.pos.x, a = 0; break; } } if (s) { const b = s > 0 ? o : 0; const T = s < 0 ? f : 0; const S = Math.max(Math.floor(t.pos.x / f), 0); const _ = Math.min(Math.ceil((t.pos.x + r) / f), p); c = Math.floor((t.pos.y + b) / f); let A = Math.floor((i + b) / f); if ((l > 0 || c === A || A < 0 || A >= g) && (A = -1), c >= 0 && c < g) for (u = S; u < _ && !(A !== -1 && (d = this.data[A][u]) > 1 && d <= this.lastSlope && this.checkDef(t, d, e, i, a, h, r, o, u, A)); u++) if ((d = this.data[c][u]) === 1 || d > this.lastSlope || d > 1 && this.checkDef(t, d, e, i, a, h, r, o, u, c)) { if (d > 1 && d <= this.lastSlope && t.collision.slope) break; t.collision.y = !0, t.tile.y = d, t.pos.y = c * f - b + T; break; } } },
    checkDef(t, e, i, n, s, r, o, a, h, l) {
      const u = this.tiledef[e]; if (!u) return !1; const c = this.tilesize; const d = (h + u[0]) * c; const f = (l + u[1]) * c; const p = (u[2] - u[0]) * c; const g = (u[3] - u[1]) * c; const v = u[4]; const y = i + s + (g < 0 ? o : 0) - d; const m = n + r + (p > 0 ? a : 0) - f; if (p * m - g * y > 0) {
        if (s * -g + r * p < 0) return v; const x = Math.sqrt(p * p + g * g); const w = g / x; const b = -p / x; const T = y * w + m * b; const S = w * T; const _ = b * T; return S * S + _ * _ >= s * s + r * r ? v || p * (m - r) - g * (y - s) < 0.5 : (t.pos.x = i + s - S, t.pos.y = n + r - _, t.collision.slope = {
          x: p, y: g, nx: w, ny: b,
        }, !0);
      } return !1;
    },
  }); t.exports = r;
}, function (t, e, i) {
  const n = i(0); const s = i(224); const r = i(1124); const o = i(223); const a = i(1123); const h = new n({
    initialize(t, e, i, n, r) { void 0 === n && (n = 16), void 0 === r && (r = n), this.world = t, this.gameObject = null, this.enabled = !0, this.parent, this.id = t.getNextID(), this.name = '', this.size = { x: n, y: r }, this.offset = { x: 0, y: 0 }, this.pos = { x: e, y: i }, this.last = { x: e, y: i }, this.vel = { x: 0, y: 0 }, this.accel = { x: 0, y: 0 }, this.friction = { x: 0, y: 0 }, this.maxVel = { x: t.defaults.maxVelocityX, y: t.defaults.maxVelocityY }, this.standing = !1, this.gravityFactor = t.defaults.gravityFactor, this.bounciness = t.defaults.bounciness, this.minBounceVelocity = t.defaults.minBounceVelocity, this.accelGround = 0, this.accelAir = 0, this.jumpSpeed = 0, this.type = o.NONE, this.checkAgainst = o.NONE, this.collides = s.NEVER, this.debugShowBody = t.defaults.debugShowBody, this.debugShowVelocity = t.defaults.debugShowVelocity, this.debugBodyColor = t.defaults.bodyDebugColor, this.updateCallback, this.slopeStanding = { min: 0.767944870877505, max: 2.3736477827122884 }; },
    reset(t, e) { this.pos = { x: t, y: e }, this.last = { x: t, y: e }, this.vel = { x: 0, y: 0 }, this.accel = { x: 0, y: 0 }, this.friction = { x: 0, y: 0 }, this.maxVel = { x: 100, y: 100 }, this.standing = !1, this.gravityFactor = 1, this.bounciness = 0, this.minBounceVelocity = 40, this.accelGround = 0, this.accelAir = 0, this.jumpSpeed = 0, this.type = o.NONE, this.checkAgainst = o.NONE, this.collides = s.NEVER; },
    update(t) { const e = this.pos; this.last.x = e.x, this.last.y = e.y, this.vel.y += this.world.gravity * t * this.gravityFactor, this.vel.x = r(t, this.vel.x, this.accel.x, this.friction.x, this.maxVel.x), this.vel.y = r(t, this.vel.y, this.accel.y, this.friction.y, this.maxVel.y); const i = this.vel.x * t; const n = this.vel.y * t; const s = this.world.collisionMap.trace(e.x, e.y, i, n, this.size.x, this.size.y); this.handleMovementTrace(s) && a(this, s); const o = this.gameObject; o && (o.x = e.x - this.offset.x + o.displayOriginX * o.scaleX, o.y = e.y - this.offset.y + o.displayOriginY * o.scaleY), this.updateCallback && this.updateCallback(this); },
    drawDebug(t) { const e = this.pos; if (this.debugShowBody && (t.lineStyle(1, this.debugBodyColor, 1), t.strokeRect(e.x, e.y, this.size.x, this.size.y)), this.debugShowVelocity) { const i = e.x + this.size.x / 2; const n = e.y + this.size.y / 2; t.lineStyle(1, this.world.defaults.velocityDebugColor, 1), t.lineBetween(i, n, i + this.vel.x, n + this.vel.y); } },
    willDrawDebug() { return this.debugShowBody || this.debugShowVelocity; },
    skipHash() { return !this.enabled || this.type === 0 && this.checkAgainst === 0 && this.collides === 0; },
    touches(t) { return !(this.pos.x >= t.pos.x + t.size.x || this.pos.x + this.size.x <= t.pos.x || this.pos.y >= t.pos.y + t.size.y || this.pos.y + this.size.y <= t.pos.y); },
    resetSize(t, e, i, n) { return this.pos.x = t, this.pos.y = e, this.size.x = i, this.size.y = n, this; },
    toJSON() {
      return {
        name: this.name, size: { x: this.size.x, y: this.size.y }, pos: { x: this.pos.x, y: this.pos.y }, vel: { x: this.vel.x, y: this.vel.y }, accel: { x: this.accel.x, y: this.accel.y }, friction: { x: this.friction.x, y: this.friction.y }, maxVel: { x: this.maxVel.x, y: this.maxVel.y }, gravityFactor: this.gravityFactor, bounciness: this.bounciness, minBounceVelocity: this.minBounceVelocity, type: this.type, checkAgainst: this.checkAgainst, collides: this.collides,
      };
    },
    fromJSON() {},
    check() {},
    collideWith(t, e) { this.parent && this.parent._collideCallback && this.parent._collideCallback.call(this.parent._callbackScope, this, t, e); },
    handleMovementTrace() { return !0; },
    destroy() { this.world.remove(this), this.enabled = !1, this.world = null, this.gameObject = null, this.parent = null; },
  }); t.exports = h;
},, function (t, e, i) { t.exports = { BitmapMaskPipeline: i(421), ForwardDiffuseLightPipeline: i(420), TextureTintPipeline: i(196) }; }, function (t, e, i) {
    t.exports = {
      Utils: i(10), WebGLPipeline: i(197), WebGLRenderer: i(423), Pipelines: i(1079), BYTE: 0, SHORT: 1, UNSIGNED_BYTE: 2, UNSIGNED_SHORT: 3, FLOAT: 4,
    };
  }, function (t, e, i) { t.exports = { Canvas: i(425), WebGL: i(422) }; }, function (t, e, i) { t.exports = { CanvasRenderer: i(426), GetBlendModes: i(424), SetTransform: i(22) }; }, function (t, e, i) { t.exports = { Canvas: i(1082), Snapshot: i(1081), WebGL: i(1080) }; }, function (t, e, i) {
    const n = i(501); var s = {
      name: 'matter-wrap', version: '0.1.4', for: 'matter-js@^0.13.1', silent: !0, install(t) { t.after('Engine.update', function () { s.Engine.update(this); }); }, Engine: { update(t) { for (var e = t.world, i = n.Composite.allBodies(e), r = n.Composite.allComposites(e), o = 0; o < i.length; o += 1) { const a = i[o]; a.plugin.wrap && s.Body.wrap(a, a.plugin.wrap); } for (o = 0; o < r.length; o += 1) { const h = r[o]; h.plugin.wrap && s.Composite.wrap(h, h.plugin.wrap); } } }, Bounds: { wrap(t, e) { let i = null; let n = null; if (void 0 !== e.min.x && void 0 !== e.max.x && (t.min.x > e.max.x ? i = e.min.x - t.max.x : t.max.x < e.min.x && (i = e.max.x - t.min.x)), void 0 !== e.min.y && void 0 !== e.max.y && (t.min.y > e.max.y ? n = e.min.y - t.max.y : t.max.y < e.min.y && (n = e.max.y - t.min.y)), i !== null || n !== null) return { x: i || 0, y: n || 0 }; } }, Body: { wrap(t, e) { const i = s.Bounds.wrap(t.bounds, e); return i && n.Body.translate(t, i), i; } }, Composite: { bounds(t) { for (var e = n.Composite.allBodies(t), i = [], s = 0; s < e.length; s += 1) { const r = e[s]; i.push(r.bounds.min, r.bounds.max); } return n.Bounds.create(i); }, wrap(t, e) { const i = s.Bounds.wrap(s.Composite.bounds(t), e); return i && n.Composite.translate(t, i), i; } },
    }; t.exports = s;
  }, function (t, e, i) {
    const n = i(501); var s = {
      name: 'matter-attractors', version: '0.1.7', for: 'matter-js@^0.13.1', silent: !0, install(t) { t.after('Body.create', function () { s.Body.init(this); }), t.before('Engine.update', (t) => { s.Engine.update(t); }); }, Body: { init(t) { t.plugin.attractors = t.plugin.attractors || []; } }, Engine: { update(t) { for (let e = t.world, i = n.Composite.allBodies(e), s = 0; s < i.length; s += 1) { const r = i[s]; const o = r.plugin.attractors; if (o && o.length > 0) for (let a = s + 1; a < i.length; a += 1) for (let h = i[a], l = 0; l < o.length; l += 1) { const u = o[l]; let c = u; n.Common.isFunction(u) && (c = u(r, h)), c && n.Body.applyForce(h, h.position, c); } } } }, Attractors: { gravityConstant: 0.001, gravity(t, e) { const i = n.Vector.sub(e.position, t.position); const r = n.Vector.magnitudeSquared(i) || 1e-4; const o = n.Vector.normalise(i); const a = -s.Attractors.gravityConstant * (t.mass * e.mass / r); const h = n.Vector.mult(o, a); n.Body.applyForce(t, t.position, n.Vector.neg(h)), n.Body.applyForce(e, e.position, h); } },
    }; t.exports = s;
  }, function (t, e, i) {
    const n = i(0); const s = i(1070); const r = i(2); const o = i(4); const a = i(1085); const h = i(1065); const l = i(1084); const u = i(96); const c = i(500); const d = i(15); const f = i(1060); const p = i(76); const g = new n({
      initialize(t) { this.scene = t, this.systems = t.sys, this.config = this.getConfig(), this.world, this.add, this.verts = p, o(this.config, 'plugins.attractors', !1) && (c.register(a), c.use(h, a)), o(this.config, 'plugins.wrap', !1) && (c.register(l), c.use(h, l)), t.sys.events.once('boot', this.boot, this), t.sys.events.on('start', this.start, this); }, boot() { this.world = new f(this.scene, this.config), this.add = new s(this.world), this.systems.events.once('destroy', this.destroy, this); }, start() { this.world || (this.world = new f(this.scene, this.config), this.add = new s(this.world)); const t = this.systems.events; t.on('update', this.world.update, this.world), t.on('postupdate', this.world.postUpdate, this.world), t.once('shutdown', this.shutdown, this); }, getConfig() { const t = this.systems.game.config.physics; const e = this.systems.settings.physics; return u(r(e, 'matter', {}), r(t, 'matter', {})); }, enableAttractorPlugin() { return c.register(a), c.use(h, a), this; }, enableWrapPlugin() { return c.register(l), c.use(h, l), this; }, pause() { return this.world.pause(); }, resume() { return this.world.resume(); }, set60Hz() { return this.world.getDelta = this.world.update60Hz, this.world.autoUpdate = !0, this; }, set30Hz() { return this.world.getDelta = this.world.update30Hz, this.world.autoUpdate = !0, this; }, step(t, e) { this.world.step(t, e); }, shutdown() { const t = this.systems.events; t.off('update', this.world.update, this.world), t.off('postupdate', this.world.postUpdate, this.world), t.off('shutdown', this.shutdown, this), this.add.destroy(), this.world.destroy(), this.add = null, this.world = null; }, destroy() { this.shutdown(), this.scene.sys.events.off('start', this.start, this), this.scene = null, this.systems = null; },
    }); d.register('MatterPhysics', g, 'matterPhysics'), t.exports = g;
  }, function (t, e, i) { const n = {}; t.exports = n; i(80); const s = i(33); n.pathToVertices = function (t, e) { typeof window === 'undefined' || 'SVGPathSeg' in window || s.warn('Svg.pathToVertices: SVGPathSeg not defined, a polyfill is required.'); let i; let r; let o; let a; let h; let l; let u; let c; let d; let f; let p; const g = []; let v = 0; let y = 0; let m = 0; e = e || 15; const x = function (t, e, i) { const n = i % 2 == 1 && i > 1; if (!d || t != d.x || e != d.y) { d && n ? (f = d.x, p = d.y) : (f = 0, p = 0); const s = { x: f + t, y: p + e }; !n && d || (d = s), g.push(s), y = f + t, m = p + e; } }; const w = function (t) { const e = t.pathSegTypeAsLetter.toUpperCase(); if (e !== 'Z') { switch (e) { case 'M': case 'L': case 'T': case 'C': case 'S': case 'Q': y = t.x, m = t.y; break; case 'H': y = t.x; break; case 'V': m = t.y; }x(y, m, t.pathSegType); } }; for (n._svgPathToAbsolute(t), o = t.getTotalLength(), l = [], i = 0; i < t.pathSegList.numberOfItems; i += 1)l.push(t.pathSegList.getItem(i)); for (u = l.concat(); v < o;) { if ((h = l[t.getPathSegAtLength(v)]) != c) { for (;u.length && u[0] != h;)w(u.shift()); c = h; } switch (h.pathSegTypeAsLetter.toUpperCase()) { case 'C': case 'T': case 'S': case 'Q': case 'A': a = t.getPointAtLength(v), x(a.x, a.y, 0); }v += e; } for (i = 0, r = u.length; i < r; ++i)w(u[i]); return g; }, n._svgPathToAbsolute = function (t) { for (var e, i, n, s, r, o, a = t.pathSegList, h = 0, l = 0, u = a.numberOfItems, c = 0; c < u; ++c) { const d = a.getItem(c); const f = d.pathSegTypeAsLetter; if (/[MLHVCSQTA]/.test(f))'x' in d && (h = d.x), 'y' in d && (l = d.y); else switch ('x1' in d && (n = h + d.x1), 'x2' in d && (r = h + d.x2), 'y1' in d && (s = l + d.y1), 'y2' in d && (o = l + d.y2), 'x' in d && (h += d.x), 'y' in d && (l += d.y), f) { case 'm': a.replaceItem(t.createSVGPathSegMovetoAbs(h, l), c); break; case 'l': a.replaceItem(t.createSVGPathSegLinetoAbs(h, l), c); break; case 'h': a.replaceItem(t.createSVGPathSegLinetoHorizontalAbs(h), c); break; case 'v': a.replaceItem(t.createSVGPathSegLinetoVerticalAbs(l), c); break; case 'c': a.replaceItem(t.createSVGPathSegCurvetoCubicAbs(h, l, n, s, r, o), c); break; case 's': a.replaceItem(t.createSVGPathSegCurvetoCubicSmoothAbs(h, l, r, o), c); break; case 'q': a.replaceItem(t.createSVGPathSegCurvetoQuadraticAbs(h, l, n, s), c); break; case 't': a.replaceItem(t.createSVGPathSegCurvetoQuadraticSmoothAbs(h, l), c); break; case 'a': a.replaceItem(t.createSVGPathSegArcAbs(h, l, d.r1, d.r2, d.angle, d.largeArcFlag, d.sweepFlag), c); break; case 'z': case 'Z': h = e, l = i; }f != 'M' && f != 'm' || (e = h, i = l); } }; }, function (t, e, i) {
    const n = {}; t.exports = n; const s = i(137); const r = i(33); n.create = function (t) {
      return r.extend({
        extended: !1, narrowDetections: 0, narrowphaseTests: 0, narrowReuse: 0, narrowReuseCount: 0, midphaseTests: 0, broadphaseTests: 0, narrowEff: 1e-4, midEff: 1e-4, broadEff: 1e-4, collisions: 0, buckets: 0, bodies: 0, pairs: 0,
      }, !1, t);
    }, n.reset = function (t) { t.extended && (t.narrowDetections = 0, t.narrowphaseTests = 0, t.narrowReuse = 0, t.narrowReuseCount = 0, t.midphaseTests = 0, t.broadphaseTests = 0, t.narrowEff = 0, t.midEff = 0, t.broadEff = 0, t.collisions = 0, t.buckets = 0, t.pairs = 0, t.bodies = 0); }, n.update = function (t, e) { if (t.extended) { const i = e.world; const n = s.allBodies(i); t.collisions = t.narrowDetections, t.pairs = e.pairs.list.length, t.bodies = n.length, t.midEff = (t.narrowDetections / (t.midphaseTests || 1)).toFixed(2), t.narrowEff = (t.narrowDetections / (t.narrowphaseTests || 1)).toFixed(2), t.broadEff = (1 - t.broadphaseTests / (n.length || 1)).toFixed(2), t.narrowReuse = (t.narrowReuseCount / (t.narrowphaseTests || 1)).toFixed(2); } };
  }, function (t, e, i) { const n = {}; t.exports = n; const s = i(81); const r = i(502); const o = i(80); const a = i(126); const h = i(76); n.collides = function (t, e) { for (var i = [], n = 0; n < e.length; n++) { const s = e[n]; if (o.overlaps(s.bounds, t.bounds)) for (let a = s.parts.length === 1 ? 0 : 1; a < s.parts.length; a++) { const h = s.parts[a]; if (o.overlaps(h.bounds, t.bounds)) { const l = r.collides(h, t); if (l.collided) { i.push(l); break; } } } } return i; }, n.ray = function (t, e, i, r) { r = r || 1e-100; for (var o = s.angle(e, i), h = s.magnitude(s.sub(e, i)), l = 0.5 * (i.x + e.x), u = 0.5 * (i.y + e.y), c = a.rectangle(l, u, h, r, { angle: o }), d = n.collides(c, t), f = 0; f < d.length; f += 1) { const p = d[f]; p.body = p.bodyB = p.bodyA; } return d; }, n.region = function (t, e, i) { for (var n = [], s = 0; s < t.length; s++) { const r = t[s]; const a = o.overlaps(r.bounds, e); (a && !i || !a && i) && n.push(r); } return n; }, n.point = function (t, e) { for (var i = [], n = 0; n < t.length; n++) { const s = t[n]; if (o.contains(s.bounds, e)) for (let r = s.parts.length === 1 ? 0 : 1; r < s.parts.length; r++) { const a = s.parts[r]; if (o.contains(a.bounds, e) && h.contains(a.vertices, e)) { i.push(s); break; } } } return i; }; }, function (t, e, i) {
    const n = i(80); const s = i(0); const r = i(137); const o = i(194); const a = i(503); const h = i(2); const l = i(96); const u = i(222); const c = i(3); const d = i(76); const f = new s({
      initialize(t, e, i) {
        void 0 === i && (i = {}); this.scene = t, this.world = e; const n = h(i, 'camera', null); n ? (this.camera = n, delete i.camera) : this.camera = t.sys.cameras.main, this.pointer = null, this.active = !0, this.position = new c(), this.constraint = o.create(l(i, {
          label: 'Pointer Constraint', pointA: { x: 0, y: 0 }, pointB: { x: 0, y: 0 }, damping: 0, length: 0.01, stiffness: 0.1, angularStiffness: 1, collisionFilter: { category: 1, mask: 4294967295, group: 0 },
        })), this.world.on('beforeupdate', this.update, this), t.sys.input.on('pointerdown', this.onDown, this), t.sys.input.on('pointerup', this.onUp, this);
      },
      onDown(t) { this.pointer = t; },
      onUp() { this.pointer = null; },
      getBodyPart(t, e) { for (let i = this.constraint, n = t.parts.length > 1 ? 1 : 0; n < t.parts.length; n++) { const s = t.parts[n]; if (d.contains(s.vertices, e)) return i.bodyB = t, i.pointA.x = e.x, i.pointA.y = e.y, i.pointB.x = e.x - t.position.x, i.pointB.y = e.y - t.position.y, i.angleB = t.angle, u.set(t, !1), !0; } return !1; },
      update() { if (this.active) { const t = this.pointer; const e = this.constraint; if (t) { const i = this.position; if (this.camera.getWorldPoint(t.x, t.y, i), e.bodyB)u.set(e.bodyB, !1), e.pointA.x = i.x, e.pointA.y = i.y; else for (let s = r.allBodies(this.world.localWorld), o = 0; o < s.length; o++) { const h = s[o]; if (!h.ignorePointer && n.contains(h.bounds, i) && a.canCollide(h.collisionFilter, e.collisionFilter) && this.getBodyPart(h, i)) break; } } else e.bodyB && (e.bodyB = null); } },
      destroy() { this.world.removeConstraint(this.constraint), this.constraint = null, this.world.off('beforeupdate', this.update), this.scene.sys.input.off('pointerdown', this.onDown, this), this.scene.sys.input.off('pointerup', this.onUp, this); },
    }); t.exports = f;
  }, function (t, e, i) {
    const n = i(67); const s = {
      setAngularVelocity(t) { return n.setAngularVelocity(this.body, t), this; }, setVelocityX(t) { return this._tempVec2.set(t, this.body.velocity.y), n.setVelocity(this.body, this._tempVec2), this; }, setVelocityY(t) { return this._tempVec2.set(this.body.velocity.x, t), n.setVelocity(this.body, this._tempVec2), this; }, setVelocity(t, e) { return this._tempVec2.set(t, e), n.setVelocity(this.body, this._tempVec2), this; },
    }; t.exports = s;
  }, function (t, e, i) {
    const n = i(67); const s = i(16); const r = i(199); const o = i(198); const a = {
      x: { get() { return this.body.position.x; }, set(t) { this._tempVec2.set(t, this.y), n.setPosition(this.body, this._tempVec2); } }, y: { get() { return this.body.position.y; }, set(t) { this._tempVec2.set(this.x, t), n.setPosition(this.body, this._tempVec2); } }, scaleX: { get() { return this._scaleX; }, set(t) { const e = 1 / this._scaleX; this._scaleX = t, this._scaleX === 0 ? this.renderFlags &= -5 : this.renderFlags |= 4, n.scale(this.body, e, this._scaleY), n.scale(this.body, t, this._scaleY); } }, scaleY: { get() { return this._scaleY; }, set(t) { const e = 1 / this._scaleY; this._scaleY = t, this._scaleY === 0 ? this.renderFlags &= -5 : this.renderFlags |= 4, n.scale(this.body, this._scaleX, e), n.scale(this.body, this._scaleX, t); } }, angle: { get() { return o(this.body.angle * s.RAD_TO_DEG); }, set(t) { this.rotation = o(t) * s.DEG_TO_RAD; } }, rotation: { get() { return this.body.angle; }, set(t) { this._rotation = r(t), n.setAngle(this.body, this._rotation); } }, setPosition(t, e) { return void 0 === t && (t = 0), void 0 === e && (e = t), this._tempVec2.set(t, e), n.setPosition(this.body, this._tempVec2), this; }, setRotation(t) { return void 0 === t && (t = 0), this._rotation = r(t), n.setAngle(this.body, t), this; }, setFixedRotation() { return n.setInertia(this.body, 1 / 0), this; }, setAngle(t) { return void 0 === t && (t = 0), this.angle = t, n.setAngle(this.body, this.rotation), this; }, setScale(t, e, i) { void 0 === t && (t = 1), void 0 === e && (e = t); const s = 1 / this._scaleX; const r = 1 / this._scaleY; return this._scaleX = t, this._scaleY = e, n.scale(this.body, s, r, i), n.scale(this.body, t, e, i), this; },
    }; t.exports = a;
  }, function (t, e, i) {
    const n = i(195); const s = {
      setSleepThreshold(t) { return void 0 === t && (t = 60), this.body.sleepThreshold = t, this; }, setSleepEvents(t, e) { return this.setSleepStartEvent(t), this.setSleepEndEvent(e), this; }, setSleepStartEvent(t) { if (t) { const e = this.world; n.on(this.body, 'sleepStart', function (t) { e.emit('sleepstart', t, this); }); } else n.off(this.body, 'sleepStart'); return this; }, setSleepEndEvent(t) { if (t) { const e = this.world; n.on(this.body, 'sleepEnd', function (t) { e.emit('sleepend', t, this); }); } else n.off(this.body, 'sleepEnd'); return this; },
    }; t.exports = s;
  }, function (t, e, i) { const n = i(126); const s = i(67); const r = i(80); const o = i(33); const a = i(2); const h = i(81); const l = i(76); const u = { parseBody(t, e, i, n, r) { for (var h = a(r, 'fixtures', []), l = [], u = 0; u < h.length; u++) for (let c = this.parseFixture(h[u]), d = 0; d < c.length; d++)l.push(c[d]); const f = o.extend({}, !1, r); delete f.fixtures, delete f.type; const p = s.create(f); return s.setParts(p, l), p.render.sprite.xOffset = p.position.x / i, p.render.sprite.yOffset = p.position.y / n, s.setPosition(p, { x: t, y: e }), p; }, parseFixture(t) { let e; const i = o.extend({}, !1, t); if (delete i.circle, delete i.vertices, t.circle) { const s = a(t.circle, 'x'); const r = a(t.circle, 'y'); const h = a(t.circle, 'radius'); e = [n.circle(s, r, h, i)]; } else t.vertices && (e = this.parseVertices(t.vertices, i)); return e; }, parseVertices(t, e) { let i; let n; let a; let u; let c; const d = []; for (e = e || {}, u = 0; u < t.length; u += 1)d.push(s.create(o.extend({ position: l.centre(t[u]), vertices: t[u] }, e))); for (i = 0; i < d.length; i++) { const f = d[i]; for (n = i + 1; n < d.length; n++) { const p = d[n]; if (r.overlaps(f.bounds, p.bounds)) { const g = f.vertices; const v = p.vertices; for (a = 0; a < f.vertices.length; a++) for (c = 0; c < p.vertices.length; c++) { const y = h.magnitudeSquared(h.sub(g[(a + 1) % g.length], v[c])); const m = h.magnitudeSquared(h.sub(g[a], v[(c + 1) % v.length])); y < 5 && m < 5 && (g[a].isInternal = !0, v[c].isInternal = !0); } } } } return d; } }; t.exports = u; }, function (t, e, i) {
    const n = i(126); const s = i(67); const r = i(2); const o = i(1094); const a = i(76); const h = {
      setRectangle(t, e, i) { return this.setBody({ type: 'rectangle', width: t, height: e }, i); },
      setCircle(t, e) { return this.setBody({ type: 'circle', radius: t }, e); },
      setPolygon(t, e, i) { return this.setBody({ type: 'polygon', sides: e, radius: t }, i); },
      setTrapezoid(t, e, i, n) {
        return this.setBody({
          type: 'trapezoid', width: t, height: e, slope: i,
        }, n);
      },
      setExistingBody(t, e) { void 0 === e && (e = !0), this.body && this.world.remove(this.body), this.body = t; for (let i = 0; i < t.parts.length; i++)t.parts[i].gameObject = this; const n = this; return t.destroy = function () { n.world.remove(n.body), n.body.gameObject = null; }, e && this.world.add(t), this._originComponent && this.setOrigin(t.render.sprite.xOffset, t.render.sprite.yOffset), this; },
      setBody(t, e) { if (!t) return this; let i; typeof t === 'string' && (t = { type: t }); const h = r(t, 'type', 'rectangle'); const l = r(t, 'x', this._tempVec2.x); const u = r(t, 'y', this._tempVec2.y); const c = r(t, 'width', this.width); const d = r(t, 'height', this.height); switch (h) { case 'rectangle': i = n.rectangle(l, u, c, d, e); break; case 'circle': var f = r(t, 'radius', Math.max(c, d) / 2); var p = r(t, 'maxSides', 25); i = n.circle(l, u, f, e, p); break; case 'trapezoid': var g = r(t, 'slope', 0.5); i = n.trapezoid(l, u, c, d, g, e); break; case 'polygon': var v = r(t, 'sides', 5); var y = r(t, 'radius', Math.max(c, d) / 2); i = n.polygon(l, u, v, y, e); break; case 'fromVertices': case 'fromVerts': var m = r(t, 'verts', null); if (m) if (typeof m === 'string' && (m = a.fromPath(m)), this.body && !this.body.hasOwnProperty('temp'))s.setVertices(this.body, m), i = this.body; else { const x = r(t, 'flagInternal', !1); const w = r(t, 'removeCollinear', 0.01); const b = r(t, 'minimumArea', 10); i = n.fromVertices(l, u, m, e, x, w, b); } break; case 'fromPhysicsEditor': i = o.parseBody(l, u, c, d, t); } return i && this.setExistingBody(i, t.addToWorld), this; },
    }; t.exports = h;
  }, function (t, e) { t.exports = { setSensor(t) { return this.body.isSensor = t, this; }, isSensor() { return this.body.isSensor; } }; }, function (t, e, i) { const n = i(67); const s = { setStatic(t) { return n.setStatic(this.body, t), this; }, isStatic() { return this.body.isStatic; } }; t.exports = s; }, function (t, e, i) { const n = i(67); const s = i(3); const r = { setMass(t) { return n.setMass(this.body, t), this; }, setDensity(t) { return n.setDensity(this.body, t), this; }, centerOfMass: { get() { return new s(this.body.render.sprite.xOffset * this.width, this.body.render.sprite.yOffset * this.height); } } }; t.exports = r; }, function (t, e) { t.exports = { setIgnoreGravity(t) { return this.body.ignoreGravity = t, this; } }; }, function (t, e) { const i = { setFriction(t, e, i) { return this.body.friction = t, void 0 !== e && (this.body.frictionAir = e), void 0 !== i && (this.body.frictionStatic = i), this; }, setFrictionAir(t) { return this.body.frictionAir = t, this; }, setFrictionStatic(t) { return this.body.frictionStatic = t, this; } }; t.exports = i; }, function (t, e, i) {
    const n = i(67); const s = {
      applyForce(t) { return this._tempVec2.set(this.body.position.x, this.body.position.y), n.applyForce(this.body, this._tempVec2, t), this; }, applyForceFrom(t, e) { return n.applyForce(this.body, t, e), this; }, thrust(t) { const e = this.body.angle; return this._tempVec2.set(t * Math.cos(e), t * Math.sin(e)), n.applyForce(this.body, { x: this.body.position.x, y: this.body.position.y }, this._tempVec2), this; }, thrustLeft(t) { const e = this.body.angle - Math.PI / 2; return this._tempVec2.set(t * Math.cos(e), t * Math.sin(e)), n.applyForce(this.body, { x: this.body.position.x, y: this.body.position.y }, this._tempVec2), this; }, thrustRight(t) { const e = this.body.angle + Math.PI / 2; return this._tempVec2.set(t * Math.cos(e), t * Math.sin(e)), n.applyForce(this.body, { x: this.body.position.x, y: this.body.position.y }, this._tempVec2), this; }, thrustBack(t) { const e = this.body.angle - Math.PI; return this._tempVec2.set(t * Math.cos(e), t * Math.sin(e)), n.applyForce(this.body, { x: this.body.position.x, y: this.body.position.y }, this._tempVec2), this; },
    }; t.exports = s;
  }, function (t, e) { const i = { setCollisionCategory(t) { return this.body.collisionFilter.category = t, this; }, setCollisionGroup(t) { return this.body.collisionFilter.group = t, this; }, setCollidesWith(t) { let e = 0; if (Array.isArray(t)) for (let i = 0; i < t.length; i++)e |= t[i]; else e = t; return this.body.collisionFilter.mask = e, this; } }; t.exports = i; }, function (t, e) { t.exports = { setBounce(t) { return this.body.restitution = t, this; } }; }, function (t, e, i) { const n = i(419); const s = i(2); const r = i(3); t.exports = function (t, e, i) { void 0 === i && (i = {}); const o = e.x; const a = e.y; e.body = { temp: !0, position: { x: o, y: a } }, [n.Bounce, n.Collision, n.Force, n.Friction, n.Gravity, n.Mass, n.Sensor, n.SetBody, n.Sleep, n.Static, n.Transform, n.Velocity].forEach((t) => { for (const i in t)(n = t[i]).get && typeof n.get === 'function' || n.set && typeof n.set === 'function' ? Object.defineProperty(e, i, { get: t[i].get, set: t[i].set }) : Object.defineProperty(e, i, { value: t[i] }); let n; }), e.world = t, e._tempVec2 = new r(o, a); let h = s(i, 'shape', null); return h || (h = 'rectangle'), e.setBody(h, i), e; }; }, function (t, e, i) {
    t.exports = {
      Factory: i(1070), Image: i(1067), Matter: i(501), MatterPhysics: i(1086), PolyDecomp: i(1069), Sprite: i(1066), TileBody: i(504), World: i(1060),
    };
  }, function (t, e) { t.exports = function (t, e, i, n) { let s; let r; const o = e.pos.y + e.size.y - i.pos.y; if (n) { const a = e === n ? i : e; n.vel.y = -n.vel.y * n.bounciness + a.vel.y, s = 0, n === e && Math.abs(n.vel.y - a.vel.y) < n.minBounceVelocity && (n.standing = !0, s = a.vel.x * t.delta); const h = t.collisionMap.trace(n.pos.x, n.pos.y, s, n === e ? -o : o, n.size.x, n.size.y); n.pos.y = h.pos.y, n.pos.x = h.pos.x; } else if (t.gravity && (i.standing || e.vel.y > 0))r = t.collisionMap.trace(e.pos.x, e.pos.y, 0, -(e.pos.y + e.size.y - i.pos.y), e.size.x, e.size.y), e.pos.y = r.pos.y, e.bounciness > 0 && e.vel.y > e.minBounceVelocity ? e.vel.y *= -e.bounciness : (e.standing = !0, e.vel.y = 0); else { const l = (e.vel.y - i.vel.y) / 2; e.vel.y = -l, i.vel.y = l, s = i.vel.x * t.delta, r = t.collisionMap.trace(e.pos.x, e.pos.y, s, -o / 2, e.size.x, e.size.y), e.pos.y = r.pos.y; const u = t.collisionMap.trace(i.pos.x, i.pos.y, 0, o / 2, i.size.x, i.size.y); i.pos.y = u.pos.y; } }; }, function (t, e) { t.exports = function (t, e, i, n) { const s = e.pos.x + e.size.x - i.pos.x; if (n) { const r = e === n ? i : e; n.vel.x = -n.vel.x * n.bounciness + r.vel.x; const o = t.collisionMap.trace(n.pos.x, n.pos.y, n === e ? -s : s, 0, n.size.x, n.size.y); n.pos.x = o.pos.x; } else { const a = (e.vel.x - i.vel.x) / 2; e.vel.x = -a, i.vel.x = a; const h = t.collisionMap.trace(e.pos.x, e.pos.y, -s / 2, 0, e.size.x, e.size.y); e.pos.x = Math.floor(h.pos.x); const l = t.collisionMap.trace(i.pos.x, i.pos.y, s / 2, 0, i.size.x, i.size.y); i.pos.x = Math.ceil(l.pos.x); } }; }, function (t, e, i) { const n = i(224); const s = i(1107); const r = i(1106); t.exports = function (t, e, i) { let o = null; e.collides === n.LITE || i.collides === n.FIXED ? o = e : i.collides !== n.LITE && e.collides !== n.FIXED || (o = i), e.last.x + e.size.x > i.last.x && e.last.x < i.last.x + i.size.x ? (e.last.y < i.last.y ? r(t, e, i, o) : r(t, i, e, o), e.collideWith(i, 'y'), i.collideWith(e, 'y'), t.emit('collide', e, i, 'y')) : e.last.y + e.size.y > i.last.y && e.last.y < i.last.y + i.size.y && (e.last.x < i.last.x ? s(t, e, i, o) : s(t, i, e, o), e.collideWith(i, 'x'), i.collideWith(e, 'x'), t.emit('collide', e, i, 'x')); }; }, function (t, e, i) {
    const n = i(0); const s = i(1075); const r = i(2); const o = i(96); const a = i(15); const h = i(1071); const l = new n({
      initialize(t) { this.scene = t, this.systems = t.sys, this.config = this.getConfig(), this.world, this.add, t.sys.events.once('boot', this.boot, this), t.sys.events.on('start', this.start, this); }, boot() { this.world = new h(this.scene, this.config), this.add = new s(this.world), this.systems.events.once('destroy', this.destroy, this); }, start() { this.world || (this.world = new h(this.scene, this.config), this.add = new s(this.world)); const t = this.systems.events; t.on('update', this.world.update, this.world), t.once('shutdown', this.shutdown, this); }, getConfig() { const t = this.systems.game.config.physics; const e = this.systems.settings.physics; return o(r(e, 'impact', {}), r(t, 'impact', {})); }, pause() { return this.world.pause(); }, resume() { return this.world.resume(); }, shutdown() { const t = this.systems.events; t.off('update', this.world.update, this.world), t.off('shutdown', this.shutdown, this), this.add.destroy(), this.world.destroy(), this.add = null, this.world = null; }, destroy() { this.shutdown(), this.scene.sys.events.off('start', this.start, this), this.scene = null, this.systems = null; },
    }); a.register('ImpactPhysics', l, 'impactPhysics'), t.exports = l;
  }, function (t, e) {
    const i = {
      setVelocityX(t) { return this.vel.x = t, this; }, setVelocityY(t) { return this.vel.y = t, this; }, setVelocity(t, e) { return void 0 === e && (e = t), this.vel.x = t, this.vel.y = e, this; }, setMaxVelocity(t, e) { return void 0 === e && (e = t), this.maxVel.x = t, this.maxVel.y = e, this; },
    }; t.exports = i;
  }, function (t, e) { const i = { setGameObject(t, e) { return void 0 === e && (e = !0), t ? (this.body.gameObject = t, e && this.syncGameObject()) : this.body.gameObject = null, this; }, syncGameObject() { const t = this.body.gameObject; return t && this.setBodySize(t.width * t.scaleX, t.height * t.scaleY), this; } }; t.exports = i; }, function (t, e) { t.exports = { setOffset(t, e, i, n) { return this.body.offset.x = t, this.body.offset.y = e, i && this.setBodySize(i, n), this; } }; }, function (t, e) { t.exports = { setGravity(t) { return this.body.gravityFactor = t, this; }, gravity: { get() { return this.body.gravityFactor; }, set(t) { this.body.gravityFactor = t; } } }; }, function (t, e) { t.exports = { setFrictionX(t) { return this.friction.x = t, this; }, setFrictionY(t) { return this.friction.y = t, this; }, setFriction(t, e) { return this.friction.x = t, this.friction.y = e, this; } }; }, function (t, e) {
    t.exports = {
      setDebug(t, e, i) { return this.debugShowBody = t, this.debugShowVelocity = e, this.debugBodyColor = i, this; }, setDebugBodyColor(t) { return this.body.debugBodyColor = t, this; }, debugShowBody: { get() { return this.body.debugShowBody; }, set(t) { this.body.debugShowBody = t; } }, debugShowVelocity: { get() { return this.body.debugShowVelocity; }, set(t) { this.body.debugShowVelocity = t; } }, debugBodyColor: { get() { return this.body.debugBodyColor; }, set(t) { this.body.debugBodyColor = t; } },
    };
  }, function (t, e, i) {
    const n = i(224); const s = {
      _collideCallback: null, _callbackScope: null, setCollideCallback(t, e) { return this._collideCallback = t, e && (this._callbackScope = e), this; }, setCollidesNever() { return this.body.collides = n.NEVER, this; }, setLiteCollision() { return this.body.collides = n.LITE, this; }, setPassiveCollision() { return this.body.collides = n.PASSIVE, this; }, setActiveCollision() { return this.body.collides = n.ACTIVE, this; }, setFixedCollision() { return this.body.collides = n.FIXED, this; }, collides: { get() { return this.body.collides; }, set(t) { this.body.collides = t; } },
    }; t.exports = s;
  }, function (t, e, i) {
    const n = i(223); const s = {
      setAvsB() { return this.setTypeA(), this.setCheckAgainstB(); }, setBvsA() { return this.setTypeB(), this.setCheckAgainstA(); }, setCheckAgainstNone() { return this.body.checkAgainst = n.NONE, this; }, setCheckAgainstA() { return this.body.checkAgainst = n.A, this; }, setCheckAgainstB() { return this.body.checkAgainst = n.B, this; }, checkAgainst: { get() { return this.body.checkAgainst; }, set(t) { this.body.checkAgainst = t; } },
    }; t.exports = s;
  }, function (t, e) { t.exports = { setBounce(t) { return this.body.bounciness = t, this; }, setMinBounceVelocity(t) { return this.body.minBounceVelocity = t, this; }, bounce: { get() { return this.body.bounciness; }, set(t) { this.body.bounciness = t; } } }; }, function (t, e, i) {
    const n = i(223); const s = {
      getBodyType() { return this.body.type; }, setTypeNone() { return this.body.type = n.NONE, this; }, setTypeA() { return this.body.type = n.A, this; }, setTypeB() { return this.body.type = n.B, this; },
    }; t.exports = s;
  }, function (t, e) { const i = { setBodySize(t, e) { return void 0 === e && (e = t), this.body.size.x = Math.round(t), this.body.size.y = Math.round(e), this; }, setBodyScale(t, e) { void 0 === e && (e = t); const i = this.body.gameObject; return i ? (i.setScale(t, e), this.setBodySize(i.width * i.scaleX, i.height * i.scaleY)) : this.setBodySize(this.body.size.x * t, this.body.size.y * e); } }; t.exports = i; }, function (t, e) { t.exports = { setAccelerationX(t) { return this.accel.x = t, this; }, setAccelerationY(t) { return this.accel.y = t, this; }, setAcceleration(t, e) { return this.accel.x = t, this.accel.y = e, this; } }; }, function (t, e) {
    const i = 0.5; const n = 1 / 3; const s = 2 / 3; t.exports = {
      2: [0, 1, 1, 0, !0], 3: [0, 1, 1, i, !0], 4: [0, i, 1, 0, !0], 5: [0, 1, 1, s, !0], 6: [0, s, 1, n, !0], 7: [0, n, 1, 0, !0], 8: [i, 1, 0, 0, !0], 9: [1, 0, i, 1, !0], 10: [i, 1, 1, 0, !0], 11: [0, 0, i, 1, !0], 12: [0, 0, 1, 0, !1], 13: [1, 1, 0, 0, !0], 14: [1, i, 0, 0, !0], 15: [1, 1, 0, i, !0], 16: [1, n, 0, 0, !0], 17: [1, s, 0, n, !0], 18: [1, 1, 0, s, !0], 19: [1, 1, i, 0, !0], 20: [i, 0, 0, 1, !0], 21: [0, 1, i, 0, !0], 22: [i, 0, 1, 1, !0], 23: [1, 1, 0, 1, !1], 24: [0, 0, 1, 1, !0], 25: [0, 0, 1, i, !0], 26: [0, i, 1, 1, !0], 27: [0, 0, 1, n, !0], 28: [0, n, 1, s, !0], 29: [0, s, 1, 1, !0], 30: [n, 1, 0, 0, !0], 31: [1, 0, s, 1, !0], 32: [s, 1, 1, 0, !0], 33: [0, 0, n, 1, !0], 34: [1, 0, 1, 1, !1], 35: [1, 0, 0, 1, !0], 36: [1, i, 0, 1, !0], 37: [1, 0, 0, i, !0], 38: [1, s, 0, 1, !0], 39: [1, n, 0, s, !0], 40: [1, 0, 0, n, !0], 41: [s, 1, n, 0, !0], 42: [s, 0, n, 1, !0], 43: [n, 1, s, 0, !0], 44: [n, 0, s, 1, !0], 45: [0, 1, 0, 0, !1], 52: [1, 1, s, 0, !0], 53: [n, 0, 0, 1, !0], 54: [0, 1, n, 0, !0], 55: [s, 0, 1, 1, !0],
    };
  }, function (t, e) { t.exports = function (t, e) { if (t.standing = !1, e.collision.y && (t.bounciness > 0 && Math.abs(t.vel.y) > t.minBounceVelocity ? t.vel.y *= -t.bounciness : (t.vel.y > 0 && (t.standing = !0), t.vel.y = 0)), e.collision.x && (t.bounciness > 0 && Math.abs(t.vel.x) > t.minBounceVelocity ? t.vel.x *= -t.bounciness : t.vel.x = 0), e.collision.slope) { const i = e.collision.slope; if (t.bounciness > 0) { const n = t.vel.x * i.nx + t.vel.y * i.ny; t.vel.x = (t.vel.x - i.nx * n * 2) * t.bounciness, t.vel.y = (t.vel.y - i.ny * n * 2) * t.bounciness; } else { const s = i.x * i.x + i.y * i.y; const r = (t.vel.x * i.x + t.vel.y * i.y) / s; t.vel.x = i.x * r, t.vel.y = i.y * r; const o = Math.atan2(i.x, i.y); o > t.slopeStanding.min && o < t.slopeStanding.max && (t.standing = !0); } }t.pos.x = e.pos.x, t.pos.y = e.pos.y; }; }, function (t, e, i) { const n = i(23); t.exports = function (t, e, i, s, r) { if (i) return n(e + i * t, -r, r); if (s) { const o = s * t; return e - o > 0 ? e - o : e + o < 0 ? e + o : 0; } return n(e, -r, r); }; }, function (t, e, i) {
    t.exports = {
      Body: i(1077), COLLIDES: i(224), CollisionMap: i(1076), Factory: i(1075), Image: i(1073), ImpactBody: i(1074), ImpactPhysics: i(1109), Sprite: i(1072), TYPE: i(223), World: i(1071),
    };
  }, function (t, e, i) { t.exports = { Arcade: i(528), Impact: i(1125), Matter: i(1105) }; }, function (t, e, i) {
    (function (e) {
      i(1059); const n = i(26); const s = i(20); let r = {
        Actions: i(417), Animation: i(993), Cache: i(992), Cameras: i(991), Class: i(0), Create: i(948), Curves: i(942), Data: i(939), Display: i(937), DOM: i(908), Events: i(906), Game: i(904), GameObjects: i(876), Geom: i(274), Input: i(616), Loader: i(593), Math: i(570), Physics: i(1126), Plugins: i(498), Renderer: i(1083), Scene: i(328), Scenes: i(496), Sound: i(494), Structs: i(493), Textures: i(492), Tilemaps: i(490), Time: i(441), Tweens: i(439), Utils: i(435),
      }; r = s(!1, r, n), t.exports = r, e.Phaser = r;
    }).call(this, i(200));
  }]))));